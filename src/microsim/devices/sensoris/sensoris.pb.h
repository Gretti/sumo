// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris.proto

#ifndef PROTOBUF_sensoris_2eproto__INCLUDED
#define PROTOBUF_sensoris_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_sensoris_2eproto();
void protobuf_AssignDesc_sensoris_2eproto();
void protobuf_ShutdownFile_sensoris_2eproto();

class ADServiceAndSensorState;
class AntiLockBrakingSystemEvent;
class CrashDetectedEvent;
class DynamicStabilityControlEvent;
class EgoMotion;
class ElectronicStabilityControlEvent;
class EmergencyBrakingEvent;
class Envelope;
class EnvironmentStatus;
class ExceptionalVehicleState;
class KeyValuePairString;
class LaneBoundaryRecognition;
class LinePoint;
class MediaContainer;
class Message;
class ObjectDetection;
class Path;
class PathEvents;
class PathMedia;
class PathSegment;
class PositionEstimate;
class PositionOffset;
class ProprietaryInfo;
class RawGNSSSatData;
class RoadSignRestriction;
class SignRecognition;
class TireSlippageEvent;
class TrafficLightStatus;
class Vector3D;
class VehicleDynamics;
class VehicleMetaData;
class VehicleStatus;

enum VehicleMetaData_VehicleTypeGenericEnum {
  VehicleMetaData_VehicleTypeGenericEnum_BUS = 1,
  VehicleMetaData_VehicleTypeGenericEnum_DELIVERY_TRUCK = 2,
  VehicleMetaData_VehicleTypeGenericEnum_EMERGENCY_VEHICLE = 3,
  VehicleMetaData_VehicleTypeGenericEnum_MOTORCYCLE = 4,
  VehicleMetaData_VehicleTypeGenericEnum_PASSENGER_CAR = 5,
  VehicleMetaData_VehicleTypeGenericEnum_TAXI = 6,
  VehicleMetaData_VehicleTypeGenericEnum_TRANSPORT_TRUCK = 7
};
bool VehicleMetaData_VehicleTypeGenericEnum_IsValid(int value);
const VehicleMetaData_VehicleTypeGenericEnum VehicleMetaData_VehicleTypeGenericEnum_VehicleTypeGenericEnum_MIN = VehicleMetaData_VehicleTypeGenericEnum_BUS;
const VehicleMetaData_VehicleTypeGenericEnum VehicleMetaData_VehicleTypeGenericEnum_VehicleTypeGenericEnum_MAX = VehicleMetaData_VehicleTypeGenericEnum_TRANSPORT_TRUCK;
const int VehicleMetaData_VehicleTypeGenericEnum_VehicleTypeGenericEnum_ARRAYSIZE = VehicleMetaData_VehicleTypeGenericEnum_VehicleTypeGenericEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleMetaData_VehicleTypeGenericEnum_descriptor();
inline const ::std::string& VehicleMetaData_VehicleTypeGenericEnum_Name(VehicleMetaData_VehicleTypeGenericEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleMetaData_VehicleTypeGenericEnum_descriptor(), value);
}
inline bool VehicleMetaData_VehicleTypeGenericEnum_Parse(
    const ::std::string& name, VehicleMetaData_VehicleTypeGenericEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleMetaData_VehicleTypeGenericEnum>(
    VehicleMetaData_VehicleTypeGenericEnum_descriptor(), name, value);
}
enum VehicleMetaData_FuelTypeEnum {
  VehicleMetaData_FuelTypeEnum_FUEL_TYPE_OTHER = 1,
  VehicleMetaData_FuelTypeEnum_FUEL_TYPE_GASOLINE_L = 2,
  VehicleMetaData_FuelTypeEnum_FUEL_TYPE_DIESEL_L = 3,
  VehicleMetaData_FuelTypeEnum_FUEL_TYPE_AUTOGAS_KG = 4,
  VehicleMetaData_FuelTypeEnum_FUEL_TYPE_BATTERY_AH = 5,
  VehicleMetaData_FuelTypeEnum_FUEL_TYPE_HYDROGEN_KG = 6
};
bool VehicleMetaData_FuelTypeEnum_IsValid(int value);
const VehicleMetaData_FuelTypeEnum VehicleMetaData_FuelTypeEnum_FuelTypeEnum_MIN = VehicleMetaData_FuelTypeEnum_FUEL_TYPE_OTHER;
const VehicleMetaData_FuelTypeEnum VehicleMetaData_FuelTypeEnum_FuelTypeEnum_MAX = VehicleMetaData_FuelTypeEnum_FUEL_TYPE_HYDROGEN_KG;
const int VehicleMetaData_FuelTypeEnum_FuelTypeEnum_ARRAYSIZE = VehicleMetaData_FuelTypeEnum_FuelTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleMetaData_FuelTypeEnum_descriptor();
inline const ::std::string& VehicleMetaData_FuelTypeEnum_Name(VehicleMetaData_FuelTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleMetaData_FuelTypeEnum_descriptor(), value);
}
inline bool VehicleMetaData_FuelTypeEnum_Parse(
    const ::std::string& name, VehicleMetaData_FuelTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleMetaData_FuelTypeEnum>(
    VehicleMetaData_FuelTypeEnum_descriptor(), name, value);
}
enum PositionEstimate_PositionTypeEnum {
  PositionEstimate_PositionTypeEnum_RAW_GPS = 1,
  PositionEstimate_PositionTypeEnum_FILTERED = 2,
  PositionEstimate_PositionTypeEnum_MAP_MATCHED_REGULAR_MAP = 3,
  PositionEstimate_PositionTypeEnum_MAP_MATCHED_HD_MAP = 4,
  PositionEstimate_PositionTypeEnum_MAP_MATCHED_HD_MAP_LANE = 5
};
bool PositionEstimate_PositionTypeEnum_IsValid(int value);
const PositionEstimate_PositionTypeEnum PositionEstimate_PositionTypeEnum_PositionTypeEnum_MIN = PositionEstimate_PositionTypeEnum_RAW_GPS;
const PositionEstimate_PositionTypeEnum PositionEstimate_PositionTypeEnum_PositionTypeEnum_MAX = PositionEstimate_PositionTypeEnum_MAP_MATCHED_HD_MAP_LANE;
const int PositionEstimate_PositionTypeEnum_PositionTypeEnum_ARRAYSIZE = PositionEstimate_PositionTypeEnum_PositionTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionEstimate_PositionTypeEnum_descriptor();
inline const ::std::string& PositionEstimate_PositionTypeEnum_Name(PositionEstimate_PositionTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionEstimate_PositionTypeEnum_descriptor(), value);
}
inline bool PositionEstimate_PositionTypeEnum_Parse(
    const ::std::string& name, PositionEstimate_PositionTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionEstimate_PositionTypeEnum>(
    PositionEstimate_PositionTypeEnum_descriptor(), name, value);
}
enum PositionEstimate_SpeedDetectionEnum {
  PositionEstimate_SpeedDetectionEnum_SPEED_RAW_GPS = 1,
  PositionEstimate_SpeedDetectionEnum_SPEED_WHEEL_TICKS = 2,
  PositionEstimate_SpeedDetectionEnum_SPEED_RADAR_SONAR = 3
};
bool PositionEstimate_SpeedDetectionEnum_IsValid(int value);
const PositionEstimate_SpeedDetectionEnum PositionEstimate_SpeedDetectionEnum_SpeedDetectionEnum_MIN = PositionEstimate_SpeedDetectionEnum_SPEED_RAW_GPS;
const PositionEstimate_SpeedDetectionEnum PositionEstimate_SpeedDetectionEnum_SpeedDetectionEnum_MAX = PositionEstimate_SpeedDetectionEnum_SPEED_RADAR_SONAR;
const int PositionEstimate_SpeedDetectionEnum_SpeedDetectionEnum_ARRAYSIZE = PositionEstimate_SpeedDetectionEnum_SpeedDetectionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionEstimate_SpeedDetectionEnum_descriptor();
inline const ::std::string& PositionEstimate_SpeedDetectionEnum_Name(PositionEstimate_SpeedDetectionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionEstimate_SpeedDetectionEnum_descriptor(), value);
}
inline bool PositionEstimate_SpeedDetectionEnum_Parse(
    const ::std::string& name, PositionEstimate_SpeedDetectionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionEstimate_SpeedDetectionEnum>(
    PositionEstimate_SpeedDetectionEnum_descriptor(), name, value);
}
enum PositionEstimate_HeadingDetectionEnum {
  PositionEstimate_HeadingDetectionEnum_HEADING_RAW_GPS = 1,
  PositionEstimate_HeadingDetectionEnum_HEADING_MAGNETIC_SENSOR = 2,
  PositionEstimate_HeadingDetectionEnum_HEADING_MULTI_SENSOR_FUSION = 3,
  PositionEstimate_HeadingDetectionEnum_HEADING_BY_MAP = 4
};
bool PositionEstimate_HeadingDetectionEnum_IsValid(int value);
const PositionEstimate_HeadingDetectionEnum PositionEstimate_HeadingDetectionEnum_HeadingDetectionEnum_MIN = PositionEstimate_HeadingDetectionEnum_HEADING_RAW_GPS;
const PositionEstimate_HeadingDetectionEnum PositionEstimate_HeadingDetectionEnum_HeadingDetectionEnum_MAX = PositionEstimate_HeadingDetectionEnum_HEADING_BY_MAP;
const int PositionEstimate_HeadingDetectionEnum_HeadingDetectionEnum_ARRAYSIZE = PositionEstimate_HeadingDetectionEnum_HeadingDetectionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionEstimate_HeadingDetectionEnum_descriptor();
inline const ::std::string& PositionEstimate_HeadingDetectionEnum_Name(PositionEstimate_HeadingDetectionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionEstimate_HeadingDetectionEnum_descriptor(), value);
}
inline bool PositionEstimate_HeadingDetectionEnum_Parse(
    const ::std::string& name, PositionEstimate_HeadingDetectionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionEstimate_HeadingDetectionEnum>(
    PositionEstimate_HeadingDetectionEnum_descriptor(), name, value);
}
enum VehicleStatus_TransmissionModeEnum {
  VehicleStatus_TransmissionModeEnum_PARK = 1,
  VehicleStatus_TransmissionModeEnum_COASTING = 2,
  VehicleStatus_TransmissionModeEnum_DRIVE = 3,
  VehicleStatus_TransmissionModeEnum_REVERSE = 4
};
bool VehicleStatus_TransmissionModeEnum_IsValid(int value);
const VehicleStatus_TransmissionModeEnum VehicleStatus_TransmissionModeEnum_TransmissionModeEnum_MIN = VehicleStatus_TransmissionModeEnum_PARK;
const VehicleStatus_TransmissionModeEnum VehicleStatus_TransmissionModeEnum_TransmissionModeEnum_MAX = VehicleStatus_TransmissionModeEnum_REVERSE;
const int VehicleStatus_TransmissionModeEnum_TransmissionModeEnum_ARRAYSIZE = VehicleStatus_TransmissionModeEnum_TransmissionModeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleStatus_TransmissionModeEnum_descriptor();
inline const ::std::string& VehicleStatus_TransmissionModeEnum_Name(VehicleStatus_TransmissionModeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleStatus_TransmissionModeEnum_descriptor(), value);
}
inline bool VehicleStatus_TransmissionModeEnum_Parse(
    const ::std::string& name, VehicleStatus_TransmissionModeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleStatus_TransmissionModeEnum>(
    VehicleStatus_TransmissionModeEnum_descriptor(), name, value);
}
enum VehicleStatus_LightStateBitfield {
  VehicleStatus_LightStateBitfield_LOWBEAMS = 1,
  VehicleStatus_LightStateBitfield_HIGHBEAMS = 2,
  VehicleStatus_LightStateBitfield_FOGLAMP_FRONT = 4,
  VehicleStatus_LightStateBitfield_FOGLAMP_REAR = 8,
  VehicleStatus_LightStateBitfield_HAZARD = 16,
  VehicleStatus_LightStateBitfield_LEFT_TURN = 32,
  VehicleStatus_LightStateBitfield_RIGHT_TURN = 64
};
bool VehicleStatus_LightStateBitfield_IsValid(int value);
const VehicleStatus_LightStateBitfield VehicleStatus_LightStateBitfield_LightStateBitfield_MIN = VehicleStatus_LightStateBitfield_LOWBEAMS;
const VehicleStatus_LightStateBitfield VehicleStatus_LightStateBitfield_LightStateBitfield_MAX = VehicleStatus_LightStateBitfield_RIGHT_TURN;
const int VehicleStatus_LightStateBitfield_LightStateBitfield_ARRAYSIZE = VehicleStatus_LightStateBitfield_LightStateBitfield_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleStatus_LightStateBitfield_descriptor();
inline const ::std::string& VehicleStatus_LightStateBitfield_Name(VehicleStatus_LightStateBitfield value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleStatus_LightStateBitfield_descriptor(), value);
}
inline bool VehicleStatus_LightStateBitfield_Parse(
    const ::std::string& name, VehicleStatus_LightStateBitfield* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleStatus_LightStateBitfield>(
    VehicleStatus_LightStateBitfield_descriptor(), name, value);
}
enum VehicleStatus_WiperStateEnum {
  VehicleStatus_WiperStateEnum_WIPING_OFF = 1,
  VehicleStatus_WiperStateEnum_WIPING_SLOW = 2,
  VehicleStatus_WiperStateEnum_WIPING_MEDIUM = 3,
  VehicleStatus_WiperStateEnum_WIPING_FAST = 4,
  VehicleStatus_WiperStateEnum_WIPING_INTERVALL = 5
};
bool VehicleStatus_WiperStateEnum_IsValid(int value);
const VehicleStatus_WiperStateEnum VehicleStatus_WiperStateEnum_WiperStateEnum_MIN = VehicleStatus_WiperStateEnum_WIPING_OFF;
const VehicleStatus_WiperStateEnum VehicleStatus_WiperStateEnum_WiperStateEnum_MAX = VehicleStatus_WiperStateEnum_WIPING_INTERVALL;
const int VehicleStatus_WiperStateEnum_WiperStateEnum_ARRAYSIZE = VehicleStatus_WiperStateEnum_WiperStateEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleStatus_WiperStateEnum_descriptor();
inline const ::std::string& VehicleStatus_WiperStateEnum_Name(VehicleStatus_WiperStateEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleStatus_WiperStateEnum_descriptor(), value);
}
inline bool VehicleStatus_WiperStateEnum_Parse(
    const ::std::string& name, VehicleStatus_WiperStateEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleStatus_WiperStateEnum>(
    VehicleStatus_WiperStateEnum_descriptor(), name, value);
}
enum VehicleStatus_MaintenanceLightStateBitfield {
  VehicleStatus_MaintenanceLightStateBitfield_WARNING_ENGINE_CONTROL = 1,
  VehicleStatus_MaintenanceLightStateBitfield_WARNING_OIL_PRESSURE = 2,
  VehicleStatus_MaintenanceLightStateBitfield_WARNING_COOLANT_TEMP = 4,
  VehicleStatus_MaintenanceLightStateBitfield_WARNING_VEHICLE_SERVICE = 8,
  VehicleStatus_MaintenanceLightStateBitfield_WARNING_BATTERY_CHARGING = 16,
  VehicleStatus_MaintenanceLightStateBitfield_WARNING_TIRE_PRESSURE = 32,
  VehicleStatus_MaintenanceLightStateBitfield_WARNING_LAMP_OUT = 64,
  VehicleStatus_MaintenanceLightStateBitfield_WARNING_OTHER_HIGH_PRIO = 128,
  VehicleStatus_MaintenanceLightStateBitfield_WARNING_OTHER_LOW_PRIO = 256
};
bool VehicleStatus_MaintenanceLightStateBitfield_IsValid(int value);
const VehicleStatus_MaintenanceLightStateBitfield VehicleStatus_MaintenanceLightStateBitfield_MaintenanceLightStateBitfield_MIN = VehicleStatus_MaintenanceLightStateBitfield_WARNING_ENGINE_CONTROL;
const VehicleStatus_MaintenanceLightStateBitfield VehicleStatus_MaintenanceLightStateBitfield_MaintenanceLightStateBitfield_MAX = VehicleStatus_MaintenanceLightStateBitfield_WARNING_OTHER_LOW_PRIO;
const int VehicleStatus_MaintenanceLightStateBitfield_MaintenanceLightStateBitfield_ARRAYSIZE = VehicleStatus_MaintenanceLightStateBitfield_MaintenanceLightStateBitfield_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleStatus_MaintenanceLightStateBitfield_descriptor();
inline const ::std::string& VehicleStatus_MaintenanceLightStateBitfield_Name(VehicleStatus_MaintenanceLightStateBitfield value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleStatus_MaintenanceLightStateBitfield_descriptor(), value);
}
inline bool VehicleStatus_MaintenanceLightStateBitfield_Parse(
    const ::std::string& name, VehicleStatus_MaintenanceLightStateBitfield* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleStatus_MaintenanceLightStateBitfield>(
    VehicleStatus_MaintenanceLightStateBitfield_descriptor(), name, value);
}
enum PositionOffset_LateralOffsetSimpleEnum {
  PositionOffset_LateralOffsetSimpleEnum_LEFT = 1,
  PositionOffset_LateralOffsetSimpleEnum_MIDDLE = 2,
  PositionOffset_LateralOffsetSimpleEnum_RIGHT = 3
};
bool PositionOffset_LateralOffsetSimpleEnum_IsValid(int value);
const PositionOffset_LateralOffsetSimpleEnum PositionOffset_LateralOffsetSimpleEnum_LateralOffsetSimpleEnum_MIN = PositionOffset_LateralOffsetSimpleEnum_LEFT;
const PositionOffset_LateralOffsetSimpleEnum PositionOffset_LateralOffsetSimpleEnum_LateralOffsetSimpleEnum_MAX = PositionOffset_LateralOffsetSimpleEnum_RIGHT;
const int PositionOffset_LateralOffsetSimpleEnum_LateralOffsetSimpleEnum_ARRAYSIZE = PositionOffset_LateralOffsetSimpleEnum_LateralOffsetSimpleEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionOffset_LateralOffsetSimpleEnum_descriptor();
inline const ::std::string& PositionOffset_LateralOffsetSimpleEnum_Name(PositionOffset_LateralOffsetSimpleEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionOffset_LateralOffsetSimpleEnum_descriptor(), value);
}
inline bool PositionOffset_LateralOffsetSimpleEnum_Parse(
    const ::std::string& name, PositionOffset_LateralOffsetSimpleEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionOffset_LateralOffsetSimpleEnum>(
    PositionOffset_LateralOffsetSimpleEnum_descriptor(), name, value);
}
enum PositionOffset_LongitudinalOffsetSimpleEnum {
  PositionOffset_LongitudinalOffsetSimpleEnum_FRONT = 1,
  PositionOffset_LongitudinalOffsetSimpleEnum_CENTER = 2,
  PositionOffset_LongitudinalOffsetSimpleEnum_BACK = 3
};
bool PositionOffset_LongitudinalOffsetSimpleEnum_IsValid(int value);
const PositionOffset_LongitudinalOffsetSimpleEnum PositionOffset_LongitudinalOffsetSimpleEnum_LongitudinalOffsetSimpleEnum_MIN = PositionOffset_LongitudinalOffsetSimpleEnum_FRONT;
const PositionOffset_LongitudinalOffsetSimpleEnum PositionOffset_LongitudinalOffsetSimpleEnum_LongitudinalOffsetSimpleEnum_MAX = PositionOffset_LongitudinalOffsetSimpleEnum_BACK;
const int PositionOffset_LongitudinalOffsetSimpleEnum_LongitudinalOffsetSimpleEnum_ARRAYSIZE = PositionOffset_LongitudinalOffsetSimpleEnum_LongitudinalOffsetSimpleEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionOffset_LongitudinalOffsetSimpleEnum_descriptor();
inline const ::std::string& PositionOffset_LongitudinalOffsetSimpleEnum_Name(PositionOffset_LongitudinalOffsetSimpleEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionOffset_LongitudinalOffsetSimpleEnum_descriptor(), value);
}
inline bool PositionOffset_LongitudinalOffsetSimpleEnum_Parse(
    const ::std::string& name, PositionOffset_LongitudinalOffsetSimpleEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionOffset_LongitudinalOffsetSimpleEnum>(
    PositionOffset_LongitudinalOffsetSimpleEnum_descriptor(), name, value);
}
enum PositionOffset_VerticalOffsetSimpleEnum {
  PositionOffset_VerticalOffsetSimpleEnum_ABOVE = 1,
  PositionOffset_VerticalOffsetSimpleEnum_AT_LEVEL = 2,
  PositionOffset_VerticalOffsetSimpleEnum_BELOW = 3
};
bool PositionOffset_VerticalOffsetSimpleEnum_IsValid(int value);
const PositionOffset_VerticalOffsetSimpleEnum PositionOffset_VerticalOffsetSimpleEnum_VerticalOffsetSimpleEnum_MIN = PositionOffset_VerticalOffsetSimpleEnum_ABOVE;
const PositionOffset_VerticalOffsetSimpleEnum PositionOffset_VerticalOffsetSimpleEnum_VerticalOffsetSimpleEnum_MAX = PositionOffset_VerticalOffsetSimpleEnum_BELOW;
const int PositionOffset_VerticalOffsetSimpleEnum_VerticalOffsetSimpleEnum_ARRAYSIZE = PositionOffset_VerticalOffsetSimpleEnum_VerticalOffsetSimpleEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionOffset_VerticalOffsetSimpleEnum_descriptor();
inline const ::std::string& PositionOffset_VerticalOffsetSimpleEnum_Name(PositionOffset_VerticalOffsetSimpleEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionOffset_VerticalOffsetSimpleEnum_descriptor(), value);
}
inline bool PositionOffset_VerticalOffsetSimpleEnum_Parse(
    const ::std::string& name, PositionOffset_VerticalOffsetSimpleEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionOffset_VerticalOffsetSimpleEnum>(
    PositionOffset_VerticalOffsetSimpleEnum_descriptor(), name, value);
}
enum RoadSignRestriction_RestrictionType {
  RoadSignRestriction_RestrictionType_RAIN = 1,
  RoadSignRestriction_RestrictionType_SNOW = 2,
  RoadSignRestriction_RestrictionType_TIME = 3,
  RoadSignRestriction_RestrictionType_SEASON = 4,
  RoadSignRestriction_RestrictionType_FOG = 5,
  RoadSignRestriction_RestrictionType_SCHOOL = 6,
  RoadSignRestriction_RestrictionType_TRUCKS = 7,
  RoadSignRestriction_RestrictionType_TRAILER = 8,
  RoadSignRestriction_RestrictionType_STARTING_IN = 101,
  RoadSignRestriction_RestrictionType_VALID_FOR = 102,
  RoadSignRestriction_RestrictionType_IN_RIGHT_DIRECTION = 103,
  RoadSignRestriction_RestrictionType_IN_LEFT_DIRECTION = 104,
  RoadSignRestriction_RestrictionType_ZONE = 105,
  RoadSignRestriction_RestrictionType_ANY_PICTURE = 1000,
  RoadSignRestriction_RestrictionType_ANY_TEXT = 1001,
  RoadSignRestriction_RestrictionType_ANY_RESTRICTION = 1002,
  RoadSignRestriction_RestrictionType_GARBAGE = 1003,
  RoadSignRestriction_RestrictionType_NIGHT = 1004,
  RoadSignRestriction_RestrictionType_WORKDAYS = 1005,
  RoadSignRestriction_RestrictionType_WORKDAYS_AND_TIME = 1006,
  RoadSignRestriction_RestrictionType_MON2FRI_AND_TIME = 1007,
  RoadSignRestriction_RestrictionType_MOTORCYCLE = 1008,
  RoadSignRestriction_RestrictionType_PASSENGER_CAR_TRAILER = 1009,
  RoadSignRestriction_RestrictionType_TRACTORS_MAY_BE_PASSED = 1010,
  RoadSignRestriction_RestrictionType_TRUCK_BUS_CAR_TRAILER = 1011,
  RoadSignRestriction_RestrictionType_WEIGHT = 1012,
  RoadSignRestriction_RestrictionType_WET = 1013,
  RoadSignRestriction_RestrictionType_ICY = 1014,
  RoadSignRestriction_RestrictionType_X_WAY = 1015,
  RoadSignRestriction_RestrictionType_PASSENGER_CAR = 1016,
  RoadSignRestriction_RestrictionType_UNKNOWN_RESTRICTION = 9999
};
bool RoadSignRestriction_RestrictionType_IsValid(int value);
const RoadSignRestriction_RestrictionType RoadSignRestriction_RestrictionType_RestrictionType_MIN = RoadSignRestriction_RestrictionType_RAIN;
const RoadSignRestriction_RestrictionType RoadSignRestriction_RestrictionType_RestrictionType_MAX = RoadSignRestriction_RestrictionType_UNKNOWN_RESTRICTION;
const int RoadSignRestriction_RestrictionType_RestrictionType_ARRAYSIZE = RoadSignRestriction_RestrictionType_RestrictionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadSignRestriction_RestrictionType_descriptor();
inline const ::std::string& RoadSignRestriction_RestrictionType_Name(RoadSignRestriction_RestrictionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadSignRestriction_RestrictionType_descriptor(), value);
}
inline bool RoadSignRestriction_RestrictionType_Parse(
    const ::std::string& name, RoadSignRestriction_RestrictionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadSignRestriction_RestrictionType>(
    RoadSignRestriction_RestrictionType_descriptor(), name, value);
}
enum SignRecognition_RoadSignTypeEnum {
  SignRecognition_RoadSignTypeEnum_SPEED_LIMIT_START = 1,
  SignRecognition_RoadSignTypeEnum_SPEED_LIMIT_END = 2,
  SignRecognition_RoadSignTypeEnum_NO_OVERTAKING_PASSENGER_CARS_START = 3,
  SignRecognition_RoadSignTypeEnum_NO_OVERTAKING_PASSENGER_CARS_END = 4,
  SignRecognition_RoadSignTypeEnum_NO_OVERTAKING_TRUCKS_START = 5,
  SignRecognition_RoadSignTypeEnum_NO_OVERTAKING_TRUCKS_END = 6,
  SignRecognition_RoadSignTypeEnum_ALL_RESTRICTIONS_END = 7,
  SignRecognition_RoadSignTypeEnum_CITY_START = 8,
  SignRecognition_RoadSignTypeEnum_CITY_END = 9,
  SignRecognition_RoadSignTypeEnum_MOTORWAY_START = 10,
  SignRecognition_RoadSignTypeEnum_MOTORWAY_END = 11,
  SignRecognition_RoadSignTypeEnum_CONSTRUCTION_START = 12,
  SignRecognition_RoadSignTypeEnum_CONSTRUCTION_END = 13,
  SignRecognition_RoadSignTypeEnum_PROTECTED_OVERTAKING_EXTRALANE = 14,
  SignRecognition_RoadSignTypeEnum_PROTECTED_OVERTAKING_EXTRALANE_RIGHTSIDE = 15,
  SignRecognition_RoadSignTypeEnum_PROTECTED_OVERTAKING_EXTRALANE_LEFTSIDE = 16,
  SignRecognition_RoadSignTypeEnum_LANE_MERGE_RIGHT = 17,
  SignRecognition_RoadSignTypeEnum_LANE_MERGE_LEFT = 18,
  SignRecognition_RoadSignTypeEnum_LANE_MERGE_CENTER = 19,
  SignRecognition_RoadSignTypeEnum_RAILWAY_CROSSING_PROTECTED = 20,
  SignRecognition_RoadSignTypeEnum_RAILWAY_CROSSING_UNPROTECTED = 21,
  SignRecognition_RoadSignTypeEnum_ROAD_NARROWS = 22,
  SignRecognition_RoadSignTypeEnum_SHARP_CURVE = 23,
  SignRecognition_RoadSignTypeEnum_SHARP_CURVE_LEFT = 24,
  SignRecognition_RoadSignTypeEnum_SHARP_CURVE_RIGHT = 25,
  SignRecognition_RoadSignTypeEnum_WINDING_ROAD_STARTING_LEFT = 26,
  SignRecognition_RoadSignTypeEnum_WINDING_ROAD_STARTING_RIGHT = 27,
  SignRecognition_RoadSignTypeEnum_STEEP_HILL = 28,
  SignRecognition_RoadSignTypeEnum_STEEP_HILL_UPWARDS = 29,
  SignRecognition_RoadSignTypeEnum_STEEP_HILL_DOWNWARDS = 30,
  SignRecognition_RoadSignTypeEnum_STOP_SIGN = 31,
  SignRecognition_RoadSignTypeEnum_LATERAL_WIND = 32,
  SignRecognition_RoadSignTypeEnum_GENERAL_WARNING = 33,
  SignRecognition_RoadSignTypeEnum_RISK_OF_GROUNDING = 34,
  SignRecognition_RoadSignTypeEnum_ANIMAL_CROSSING = 35,
  SignRecognition_RoadSignTypeEnum_ICY_CONDITIONS = 36,
  SignRecognition_RoadSignTypeEnum_SLIPPERY_ROAD = 37,
  SignRecognition_RoadSignTypeEnum_FALLING_ROCKS = 38,
  SignRecognition_RoadSignTypeEnum_SCHOOL_ZONE = 39,
  SignRecognition_RoadSignTypeEnum_TRAMWAY_CROSSING = 40,
  SignRecognition_RoadSignTypeEnum_CONGESTION_HAZARD = 41,
  SignRecognition_RoadSignTypeEnum_ACCIDENT_HAZARD = 42,
  SignRecognition_RoadSignTypeEnum_PRIORITY_OVER_ONCOMING_TRAFFIC = 43,
  SignRecognition_RoadSignTypeEnum_YIELD_TO_ONCOMING_TRAFFIC = 44,
  SignRecognition_RoadSignTypeEnum_PREFERENCE_ROAD_START = 45,
  SignRecognition_RoadSignTypeEnum_PREFERENCE_ROAD_END = 46,
  SignRecognition_RoadSignTypeEnum_ENVIRONMENTAL_ZONE_START = 1000,
  SignRecognition_RoadSignTypeEnum_ENVIRONMENTAL_ZONE_END = 1001,
  SignRecognition_RoadSignTypeEnum_RESIDENTIAL_AREA_START = 1002,
  SignRecognition_RoadSignTypeEnum_RESIDENTIAL_AREA_END = 1003,
  SignRecognition_RoadSignTypeEnum_HIGHWAY_START = 1004,
  SignRecognition_RoadSignTypeEnum_HIGHWAY_END = 1005,
  SignRecognition_RoadSignTypeEnum_ZONE_START = 1006,
  SignRecognition_RoadSignTypeEnum_ZONE_END = 1007,
  SignRecognition_RoadSignTypeEnum_ROUNDABOUT = 1008,
  SignRecognition_RoadSignTypeEnum_PASS_THIS_SIDE_RIGHT = 1009,
  SignRecognition_RoadSignTypeEnum_PASS_THIS_SIDE_LEFT = 1010,
  SignRecognition_RoadSignTypeEnum_NO_ENTRY = 1011,
  SignRecognition_RoadSignTypeEnum_ENVIRONMENTAL_ZONE_GREEN_START = 1012,
  SignRecognition_RoadSignTypeEnum_UNEVEN_ROAD = 1014,
  SignRecognition_RoadSignTypeEnum_GENERAL_PRIORITIES_RULE = 1016,
  SignRecognition_RoadSignTypeEnum_DANGER_NARROW_ROAD = 1017,
  SignRecognition_RoadSignTypeEnum_DANGER_CHILDREN = 1018,
  SignRecognition_RoadSignTypeEnum_DANGER_PEDESTRIANS = 1019,
  SignRecognition_RoadSignTypeEnum_DANGER_CYCLIST = 1020,
  SignRecognition_RoadSignTypeEnum_ROAD_NARROWS_LEFT = 1022,
  SignRecognition_RoadSignTypeEnum_ROAD_NARROWS_RIGHT = 1023,
  SignRecognition_RoadSignTypeEnum_GRAVEL = 1100,
  SignRecognition_RoadSignTypeEnum_CONTRAFLOW_TRAFFIC = 1101,
  SignRecognition_RoadSignTypeEnum_DRAWBRIDGE = 1102,
  SignRecognition_RoadSignTypeEnum_QUAYWALL = 1103,
  SignRecognition_RoadSignTypeEnum_TRAFFICLIGHT = 1104,
  SignRecognition_RoadSignTypeEnum_ZEBRA_CROSSING_HAZARD = 1105,
  SignRecognition_RoadSignTypeEnum_CATTLE_CROSSING = 1106,
  SignRecognition_RoadSignTypeEnum_PLANES_CROSSING = 1107,
  SignRecognition_RoadSignTypeEnum_BUS_CROSSING = 1108,
  SignRecognition_RoadSignTypeEnum_PRECEDENCE_FOR_CONTRAFLOW_TRAFFIC = 1109,
  SignRecognition_RoadSignTypeEnum_TURN_LEFT = 1110,
  SignRecognition_RoadSignTypeEnum_TURN_RIGHT = 1111,
  SignRecognition_RoadSignTypeEnum_NO_TURN = 1112,
  SignRecognition_RoadSignTypeEnum_TURN_LEFT_OR_RIGHT = 1113,
  SignRecognition_RoadSignTypeEnum_DRIVE_LEFT = 1114,
  SignRecognition_RoadSignTypeEnum_DRIVE_RIGHT = 1115,
  SignRecognition_RoadSignTypeEnum_NO_TURN_RIGHT = 1116,
  SignRecognition_RoadSignTypeEnum_NO_TURN_LEFT = 1117,
  SignRecognition_RoadSignTypeEnum_ONEWAY_LEFT = 1118,
  SignRecognition_RoadSignTypeEnum_ONEWAY_RIGHT = 1119,
  SignRecognition_RoadSignTypeEnum_BUSSTOP = 1120,
  SignRecognition_RoadSignTypeEnum_BICYCLE_LANE = 1121,
  SignRecognition_RoadSignTypeEnum_HORSERIDING_LANE = 1122,
  SignRecognition_RoadSignTypeEnum_PEDESTRIAN_LANE = 1123,
  SignRecognition_RoadSignTypeEnum_PEDESTRIAN_AND_BICYCLE_LANE = 1124,
  SignRecognition_RoadSignTypeEnum_BICYCLE_BESIDES_PEDESTRIAN_LANE = 1125,
  SignRecognition_RoadSignTypeEnum_PEDESTRIAN_BESIDES_BICYCLE_LANE = 1126,
  SignRecognition_RoadSignTypeEnum_PEDESTRIAN_ZONE_START = 1127,
  SignRecognition_RoadSignTypeEnum_PEDESTRIAN_ZONE_END = 1128,
  SignRecognition_RoadSignTypeEnum_BICYCLE_ZONE_START = 1129,
  SignRecognition_RoadSignTypeEnum_BICYCLE_ZONE_END = 1130,
  SignRecognition_RoadSignTypeEnum_NO_PARKING_ZONE_START = 1131,
  SignRecognition_RoadSignTypeEnum_NO_PARKING_ZONE_END = 1132,
  SignRecognition_RoadSignTypeEnum_BUS_LANE = 1133,
  SignRecognition_RoadSignTypeEnum_NO_MOTORVEHICLES = 1134,
  SignRecognition_RoadSignTypeEnum_NO_TRUCKS = 1135,
  SignRecognition_RoadSignTypeEnum_NO_BICYCLE = 1136,
  SignRecognition_RoadSignTypeEnum_NO_MOTORCYCLE = 1137,
  SignRecognition_RoadSignTypeEnum_NO_SCOOTER = 1138,
  SignRecognition_RoadSignTypeEnum_NO_HORSERIDING = 1139,
  SignRecognition_RoadSignTypeEnum_NO_PEDESTRIANS = 1140,
  SignRecognition_RoadSignTypeEnum_NO_MOTORVEHICLES_AND_MOTORCYCLE = 1141,
  SignRecognition_RoadSignTypeEnum_NO_DANGEROUSGOODS = 1142,
  SignRecognition_RoadSignTypeEnum_RESTRICTED_WEIGHT = 1143,
  SignRecognition_RoadSignTypeEnum_RESTRICTED_AXLE_WEIGHT = 1144,
  SignRecognition_RoadSignTypeEnum_RESTRICTED_WIDTH = 1145,
  SignRecognition_RoadSignTypeEnum_RESTRICTED_HEIGHT = 1146,
  SignRecognition_RoadSignTypeEnum_RESTRICTED_LENGTH = 1147,
  SignRecognition_RoadSignTypeEnum_SNOW_CHAINS_MANDATORY = 1148,
  SignRecognition_RoadSignTypeEnum_NO_WATER_HAZARDOUS_GOODS = 1149,
  SignRecognition_RoadSignTypeEnum_NO_UTURN = 1150,
  SignRecognition_RoadSignTypeEnum_PROHIBITED_MINIMUM_GAP_DECEED = 1151,
  SignRecognition_RoadSignTypeEnum_MANDATORY_MINIMUM_SPEED_START = 1152,
  SignRecognition_RoadSignTypeEnum_MANDATORY_MINIMUM_SPEED_END = 1153,
  SignRecognition_RoadSignTypeEnum_NO_STOPPING_TO_LEFT = 1154,
  SignRecognition_RoadSignTypeEnum_NO_STOPPING_TO_RIGHT = 1155,
  SignRecognition_RoadSignTypeEnum_NO_STOPPING_TO_BOTH = 1156,
  SignRecognition_RoadSignTypeEnum_NO_STOPPING = 1157,
  SignRecognition_RoadSignTypeEnum_NO_PARKING_TO_LEFT = 1158,
  SignRecognition_RoadSignTypeEnum_NO_PARKING_TO_RIGHT = 1159,
  SignRecognition_RoadSignTypeEnum_NO_PARKING_TO_BOTH = 1160,
  SignRecognition_RoadSignTypeEnum_NO_PARKING = 1161,
  SignRecognition_RoadSignTypeEnum_PRIORITY_OVER_CONTRAFLOW_TRAFFIC = 1162,
  SignRecognition_RoadSignTypeEnum_ZEBRA_CROSSING = 1163,
  SignRecognition_RoadSignTypeEnum_HAF_RIGHT = 1164,
  SignRecognition_RoadSignTypeEnum_HAF_LEFT = 1165,
  SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_STRAIGHT = 1200,
  SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_LEFT = 1201,
  SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_RIGHT = 1202,
  SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_STRAIGHTLEFT = 1203,
  SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_STRAIGHTRIGHT = 1204,
  SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_LEFTRIGHT = 1205,
  SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_MERGELEFT = 1206,
  SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_MERGERIGHT = 1207,
  SignRecognition_RoadSignTypeEnum_UNKNOWN_SIGN = 9999
};
bool SignRecognition_RoadSignTypeEnum_IsValid(int value);
const SignRecognition_RoadSignTypeEnum SignRecognition_RoadSignTypeEnum_RoadSignTypeEnum_MIN = SignRecognition_RoadSignTypeEnum_SPEED_LIMIT_START;
const SignRecognition_RoadSignTypeEnum SignRecognition_RoadSignTypeEnum_RoadSignTypeEnum_MAX = SignRecognition_RoadSignTypeEnum_UNKNOWN_SIGN;
const int SignRecognition_RoadSignTypeEnum_RoadSignTypeEnum_ARRAYSIZE = SignRecognition_RoadSignTypeEnum_RoadSignTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignRecognition_RoadSignTypeEnum_descriptor();
inline const ::std::string& SignRecognition_RoadSignTypeEnum_Name(SignRecognition_RoadSignTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignRecognition_RoadSignTypeEnum_descriptor(), value);
}
inline bool SignRecognition_RoadSignTypeEnum_Parse(
    const ::std::string& name, SignRecognition_RoadSignTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignRecognition_RoadSignTypeEnum>(
    SignRecognition_RoadSignTypeEnum_descriptor(), name, value);
}
enum SignRecognition_RoadSignPermanencyEnum {
  SignRecognition_RoadSignPermanencyEnum_STATIC = 1,
  SignRecognition_RoadSignPermanencyEnum_VARIABLE = 2
};
bool SignRecognition_RoadSignPermanencyEnum_IsValid(int value);
const SignRecognition_RoadSignPermanencyEnum SignRecognition_RoadSignPermanencyEnum_RoadSignPermanencyEnum_MIN = SignRecognition_RoadSignPermanencyEnum_STATIC;
const SignRecognition_RoadSignPermanencyEnum SignRecognition_RoadSignPermanencyEnum_RoadSignPermanencyEnum_MAX = SignRecognition_RoadSignPermanencyEnum_VARIABLE;
const int SignRecognition_RoadSignPermanencyEnum_RoadSignPermanencyEnum_ARRAYSIZE = SignRecognition_RoadSignPermanencyEnum_RoadSignPermanencyEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignRecognition_RoadSignPermanencyEnum_descriptor();
inline const ::std::string& SignRecognition_RoadSignPermanencyEnum_Name(SignRecognition_RoadSignPermanencyEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignRecognition_RoadSignPermanencyEnum_descriptor(), value);
}
inline bool SignRecognition_RoadSignPermanencyEnum_Parse(
    const ::std::string& name, SignRecognition_RoadSignPermanencyEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignRecognition_RoadSignPermanencyEnum>(
    SignRecognition_RoadSignPermanencyEnum_descriptor(), name, value);
}
enum SignRecognition_RoadSignDependenciesEnum {
  SignRecognition_RoadSignDependenciesEnum_RAIN = 1,
  SignRecognition_RoadSignDependenciesEnum_SNOW = 2,
  SignRecognition_RoadSignDependenciesEnum_TIME = 3,
  SignRecognition_RoadSignDependenciesEnum_SEASON = 4,
  SignRecognition_RoadSignDependenciesEnum_FOG = 5,
  SignRecognition_RoadSignDependenciesEnum_SCHOOL = 6,
  SignRecognition_RoadSignDependenciesEnum_TRUCKS = 7,
  SignRecognition_RoadSignDependenciesEnum_TRAILER = 8,
  SignRecognition_RoadSignDependenciesEnum_ANY_PICTURE = 1000,
  SignRecognition_RoadSignDependenciesEnum_ANY_TEXT = 1001,
  SignRecognition_RoadSignDependenciesEnum_ANY_RESTRICTION = 1002,
  SignRecognition_RoadSignDependenciesEnum_GARBAGE = 1003,
  SignRecognition_RoadSignDependenciesEnum_NIGHT = 1004,
  SignRecognition_RoadSignDependenciesEnum_WORKDAYS = 1005,
  SignRecognition_RoadSignDependenciesEnum_WORKDAYS_AND_TIME = 1006,
  SignRecognition_RoadSignDependenciesEnum_MON2FRI_AND_TIME = 1007,
  SignRecognition_RoadSignDependenciesEnum_MOTORCYCLE = 1008,
  SignRecognition_RoadSignDependenciesEnum_PASSENGER_CAR_TRAILER = 1009,
  SignRecognition_RoadSignDependenciesEnum_TRACTORS_MAY_BE_PASSED = 1010,
  SignRecognition_RoadSignDependenciesEnum_TRUCK_BUS_CAR_TRAILER = 1011,
  SignRecognition_RoadSignDependenciesEnum_WEIGHT = 1012,
  SignRecognition_RoadSignDependenciesEnum_WET = 1013,
  SignRecognition_RoadSignDependenciesEnum_ICY = 1014,
  SignRecognition_RoadSignDependenciesEnum_X_WAY = 1015,
  SignRecognition_RoadSignDependenciesEnum_PASSENGER_CAR = 1016,
  SignRecognition_RoadSignDependenciesEnum_UNKNOWN_DEPENDENCY = 9999
};
bool SignRecognition_RoadSignDependenciesEnum_IsValid(int value);
const SignRecognition_RoadSignDependenciesEnum SignRecognition_RoadSignDependenciesEnum_RoadSignDependenciesEnum_MIN = SignRecognition_RoadSignDependenciesEnum_RAIN;
const SignRecognition_RoadSignDependenciesEnum SignRecognition_RoadSignDependenciesEnum_RoadSignDependenciesEnum_MAX = SignRecognition_RoadSignDependenciesEnum_UNKNOWN_DEPENDENCY;
const int SignRecognition_RoadSignDependenciesEnum_RoadSignDependenciesEnum_ARRAYSIZE = SignRecognition_RoadSignDependenciesEnum_RoadSignDependenciesEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignRecognition_RoadSignDependenciesEnum_descriptor();
inline const ::std::string& SignRecognition_RoadSignDependenciesEnum_Name(SignRecognition_RoadSignDependenciesEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignRecognition_RoadSignDependenciesEnum_descriptor(), value);
}
inline bool SignRecognition_RoadSignDependenciesEnum_Parse(
    const ::std::string& name, SignRecognition_RoadSignDependenciesEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignRecognition_RoadSignDependenciesEnum>(
    SignRecognition_RoadSignDependenciesEnum_descriptor(), name, value);
}
enum SignRecognition_RoadSignValidityEnum {
  SignRecognition_RoadSignValidityEnum_STARTING_IN = 1,
  SignRecognition_RoadSignValidityEnum_VALID_FOR = 2,
  SignRecognition_RoadSignValidityEnum_IN_RIGHT_DIRECTION = 3,
  SignRecognition_RoadSignValidityEnum_IN_LEFT_DIRECTION = 4,
  SignRecognition_RoadSignValidityEnum_ZONE = 5,
  SignRecognition_RoadSignValidityEnum_UNKNOWN_VALIDITY = 9999
};
bool SignRecognition_RoadSignValidityEnum_IsValid(int value);
const SignRecognition_RoadSignValidityEnum SignRecognition_RoadSignValidityEnum_RoadSignValidityEnum_MIN = SignRecognition_RoadSignValidityEnum_STARTING_IN;
const SignRecognition_RoadSignValidityEnum SignRecognition_RoadSignValidityEnum_RoadSignValidityEnum_MAX = SignRecognition_RoadSignValidityEnum_UNKNOWN_VALIDITY;
const int SignRecognition_RoadSignValidityEnum_RoadSignValidityEnum_ARRAYSIZE = SignRecognition_RoadSignValidityEnum_RoadSignValidityEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignRecognition_RoadSignValidityEnum_descriptor();
inline const ::std::string& SignRecognition_RoadSignValidityEnum_Name(SignRecognition_RoadSignValidityEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignRecognition_RoadSignValidityEnum_descriptor(), value);
}
inline bool SignRecognition_RoadSignValidityEnum_Parse(
    const ::std::string& name, SignRecognition_RoadSignValidityEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignRecognition_RoadSignValidityEnum>(
    SignRecognition_RoadSignValidityEnum_descriptor(), name, value);
}
enum SignRecognition_RoadSignRecognitionTypeEnum {
  SignRecognition_RoadSignRecognitionTypeEnum_SIGN_DETECTED = 1,
  SignRecognition_RoadSignRecognitionTypeEnum_SIGN_NOT_DETECTED = 2
};
bool SignRecognition_RoadSignRecognitionTypeEnum_IsValid(int value);
const SignRecognition_RoadSignRecognitionTypeEnum SignRecognition_RoadSignRecognitionTypeEnum_RoadSignRecognitionTypeEnum_MIN = SignRecognition_RoadSignRecognitionTypeEnum_SIGN_DETECTED;
const SignRecognition_RoadSignRecognitionTypeEnum SignRecognition_RoadSignRecognitionTypeEnum_RoadSignRecognitionTypeEnum_MAX = SignRecognition_RoadSignRecognitionTypeEnum_SIGN_NOT_DETECTED;
const int SignRecognition_RoadSignRecognitionTypeEnum_RoadSignRecognitionTypeEnum_ARRAYSIZE = SignRecognition_RoadSignRecognitionTypeEnum_RoadSignRecognitionTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignRecognition_RoadSignRecognitionTypeEnum_descriptor();
inline const ::std::string& SignRecognition_RoadSignRecognitionTypeEnum_Name(SignRecognition_RoadSignRecognitionTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignRecognition_RoadSignRecognitionTypeEnum_descriptor(), value);
}
inline bool SignRecognition_RoadSignRecognitionTypeEnum_Parse(
    const ::std::string& name, SignRecognition_RoadSignRecognitionTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignRecognition_RoadSignRecognitionTypeEnum>(
    SignRecognition_RoadSignRecognitionTypeEnum_descriptor(), name, value);
}
enum LinePoint_LinePointTypeEnum {
  LinePoint_LinePointTypeEnum_START = 1,
  LinePoint_LinePointTypeEnum_END = 2,
  LinePoint_LinePointTypeEnum_MIDDLE = 3
};
bool LinePoint_LinePointTypeEnum_IsValid(int value);
const LinePoint_LinePointTypeEnum LinePoint_LinePointTypeEnum_LinePointTypeEnum_MIN = LinePoint_LinePointTypeEnum_START;
const LinePoint_LinePointTypeEnum LinePoint_LinePointTypeEnum_LinePointTypeEnum_MAX = LinePoint_LinePointTypeEnum_MIDDLE;
const int LinePoint_LinePointTypeEnum_LinePointTypeEnum_ARRAYSIZE = LinePoint_LinePointTypeEnum_LinePointTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LinePoint_LinePointTypeEnum_descriptor();
inline const ::std::string& LinePoint_LinePointTypeEnum_Name(LinePoint_LinePointTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LinePoint_LinePointTypeEnum_descriptor(), value);
}
inline bool LinePoint_LinePointTypeEnum_Parse(
    const ::std::string& name, LinePoint_LinePointTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LinePoint_LinePointTypeEnum>(
    LinePoint_LinePointTypeEnum_descriptor(), name, value);
}
enum LaneBoundaryRecognition_LaneBoundaryTypeEnum {
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_SINGLE_SOLID_PAINT = 1,
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_DOUBLE_SOLID_PAINT = 2,
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_LONG_DASHED_PAINT = 3,
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_SHORT_DASHED_PAINT = 4,
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_SHADED_AREA_PAINT = 5,
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_DASHED_BLOCKS = 6,
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_DOUBLE_LINE_DASHED_SOLID_PAINT = 7,
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_DOUBLE_LINE_SOLID_DASHED_PAINT = 8,
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_PHYSICAL_DIVIDER = 9,
  LaneBoundaryRecognition_LaneBoundaryTypeEnum_DOUBLE_DASHED_LINES = 10
};
bool LaneBoundaryRecognition_LaneBoundaryTypeEnum_IsValid(int value);
const LaneBoundaryRecognition_LaneBoundaryTypeEnum LaneBoundaryRecognition_LaneBoundaryTypeEnum_LaneBoundaryTypeEnum_MIN = LaneBoundaryRecognition_LaneBoundaryTypeEnum_SINGLE_SOLID_PAINT;
const LaneBoundaryRecognition_LaneBoundaryTypeEnum LaneBoundaryRecognition_LaneBoundaryTypeEnum_LaneBoundaryTypeEnum_MAX = LaneBoundaryRecognition_LaneBoundaryTypeEnum_DOUBLE_DASHED_LINES;
const int LaneBoundaryRecognition_LaneBoundaryTypeEnum_LaneBoundaryTypeEnum_ARRAYSIZE = LaneBoundaryRecognition_LaneBoundaryTypeEnum_LaneBoundaryTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundaryRecognition_LaneBoundaryTypeEnum_descriptor();
inline const ::std::string& LaneBoundaryRecognition_LaneBoundaryTypeEnum_Name(LaneBoundaryRecognition_LaneBoundaryTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_descriptor(), value);
}
inline bool LaneBoundaryRecognition_LaneBoundaryTypeEnum_Parse(
    const ::std::string& name, LaneBoundaryRecognition_LaneBoundaryTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundaryRecognition_LaneBoundaryTypeEnum>(
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_descriptor(), name, value);
}
enum LaneBoundaryRecognition_LaneBoundaryColorEnum {
  LaneBoundaryRecognition_LaneBoundaryColorEnum_WHITE = 1,
  LaneBoundaryRecognition_LaneBoundaryColorEnum_YELLOW = 2,
  LaneBoundaryRecognition_LaneBoundaryColorEnum_BLUE = 3
};
bool LaneBoundaryRecognition_LaneBoundaryColorEnum_IsValid(int value);
const LaneBoundaryRecognition_LaneBoundaryColorEnum LaneBoundaryRecognition_LaneBoundaryColorEnum_LaneBoundaryColorEnum_MIN = LaneBoundaryRecognition_LaneBoundaryColorEnum_WHITE;
const LaneBoundaryRecognition_LaneBoundaryColorEnum LaneBoundaryRecognition_LaneBoundaryColorEnum_LaneBoundaryColorEnum_MAX = LaneBoundaryRecognition_LaneBoundaryColorEnum_BLUE;
const int LaneBoundaryRecognition_LaneBoundaryColorEnum_LaneBoundaryColorEnum_ARRAYSIZE = LaneBoundaryRecognition_LaneBoundaryColorEnum_LaneBoundaryColorEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundaryRecognition_LaneBoundaryColorEnum_descriptor();
inline const ::std::string& LaneBoundaryRecognition_LaneBoundaryColorEnum_Name(LaneBoundaryRecognition_LaneBoundaryColorEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundaryRecognition_LaneBoundaryColorEnum_descriptor(), value);
}
inline bool LaneBoundaryRecognition_LaneBoundaryColorEnum_Parse(
    const ::std::string& name, LaneBoundaryRecognition_LaneBoundaryColorEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundaryRecognition_LaneBoundaryColorEnum>(
    LaneBoundaryRecognition_LaneBoundaryColorEnum_descriptor(), name, value);
}
enum EnvironmentStatus_LightConditionsEnum {
  EnvironmentStatus_LightConditionsEnum_GENERAL_DAYLIGHT = 1,
  EnvironmentStatus_LightConditionsEnum_GENERAL_DARK = 2,
  EnvironmentStatus_LightConditionsEnum_DAYLIGHT_SUN = 3,
  EnvironmentStatus_LightConditionsEnum_DAYLIGHT_CLOUD = 4,
  EnvironmentStatus_LightConditionsEnum_DUSK_OR_DAWN = 5,
  EnvironmentStatus_LightConditionsEnum_NIGHT_LUMINATED = 6,
  EnvironmentStatus_LightConditionsEnum_NIGHT_DARK = 7
};
bool EnvironmentStatus_LightConditionsEnum_IsValid(int value);
const EnvironmentStatus_LightConditionsEnum EnvironmentStatus_LightConditionsEnum_LightConditionsEnum_MIN = EnvironmentStatus_LightConditionsEnum_GENERAL_DAYLIGHT;
const EnvironmentStatus_LightConditionsEnum EnvironmentStatus_LightConditionsEnum_LightConditionsEnum_MAX = EnvironmentStatus_LightConditionsEnum_NIGHT_DARK;
const int EnvironmentStatus_LightConditionsEnum_LightConditionsEnum_ARRAYSIZE = EnvironmentStatus_LightConditionsEnum_LightConditionsEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnvironmentStatus_LightConditionsEnum_descriptor();
inline const ::std::string& EnvironmentStatus_LightConditionsEnum_Name(EnvironmentStatus_LightConditionsEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnvironmentStatus_LightConditionsEnum_descriptor(), value);
}
inline bool EnvironmentStatus_LightConditionsEnum_Parse(
    const ::std::string& name, EnvironmentStatus_LightConditionsEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnvironmentStatus_LightConditionsEnum>(
    EnvironmentStatus_LightConditionsEnum_descriptor(), name, value);
}
enum EnvironmentStatus_PrecipitationEnum {
  EnvironmentStatus_PrecipitationEnum_NONE = 1,
  EnvironmentStatus_PrecipitationEnum_RAIN = 2,
  EnvironmentStatus_PrecipitationEnum_HAIL = 3,
  EnvironmentStatus_PrecipitationEnum_SNOW = 4
};
bool EnvironmentStatus_PrecipitationEnum_IsValid(int value);
const EnvironmentStatus_PrecipitationEnum EnvironmentStatus_PrecipitationEnum_PrecipitationEnum_MIN = EnvironmentStatus_PrecipitationEnum_NONE;
const EnvironmentStatus_PrecipitationEnum EnvironmentStatus_PrecipitationEnum_PrecipitationEnum_MAX = EnvironmentStatus_PrecipitationEnum_SNOW;
const int EnvironmentStatus_PrecipitationEnum_PrecipitationEnum_ARRAYSIZE = EnvironmentStatus_PrecipitationEnum_PrecipitationEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnvironmentStatus_PrecipitationEnum_descriptor();
inline const ::std::string& EnvironmentStatus_PrecipitationEnum_Name(EnvironmentStatus_PrecipitationEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnvironmentStatus_PrecipitationEnum_descriptor(), value);
}
inline bool EnvironmentStatus_PrecipitationEnum_Parse(
    const ::std::string& name, EnvironmentStatus_PrecipitationEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnvironmentStatus_PrecipitationEnum>(
    EnvironmentStatus_PrecipitationEnum_descriptor(), name, value);
}
enum EnvironmentStatus_RoadSurfaceTypeEnum {
  EnvironmentStatus_RoadSurfaceTypeEnum_ASPHALT = 1,
  EnvironmentStatus_RoadSurfaceTypeEnum_CONCRETE = 2,
  EnvironmentStatus_RoadSurfaceTypeEnum_PAVED = 3,
  EnvironmentStatus_RoadSurfaceTypeEnum_GRAVEL = 4,
  EnvironmentStatus_RoadSurfaceTypeEnum_ICEORSNOW = 5,
  EnvironmentStatus_RoadSurfaceTypeEnum_UNKNOWN = 6
};
bool EnvironmentStatus_RoadSurfaceTypeEnum_IsValid(int value);
const EnvironmentStatus_RoadSurfaceTypeEnum EnvironmentStatus_RoadSurfaceTypeEnum_RoadSurfaceTypeEnum_MIN = EnvironmentStatus_RoadSurfaceTypeEnum_ASPHALT;
const EnvironmentStatus_RoadSurfaceTypeEnum EnvironmentStatus_RoadSurfaceTypeEnum_RoadSurfaceTypeEnum_MAX = EnvironmentStatus_RoadSurfaceTypeEnum_UNKNOWN;
const int EnvironmentStatus_RoadSurfaceTypeEnum_RoadSurfaceTypeEnum_ARRAYSIZE = EnvironmentStatus_RoadSurfaceTypeEnum_RoadSurfaceTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnvironmentStatus_RoadSurfaceTypeEnum_descriptor();
inline const ::std::string& EnvironmentStatus_RoadSurfaceTypeEnum_Name(EnvironmentStatus_RoadSurfaceTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnvironmentStatus_RoadSurfaceTypeEnum_descriptor(), value);
}
inline bool EnvironmentStatus_RoadSurfaceTypeEnum_Parse(
    const ::std::string& name, EnvironmentStatus_RoadSurfaceTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnvironmentStatus_RoadSurfaceTypeEnum>(
    EnvironmentStatus_RoadSurfaceTypeEnum_descriptor(), name, value);
}
enum TrafficLightStatus_LightStatus {
  TrafficLightStatus_LightStatus_OFF = 1,
  TrafficLightStatus_LightStatus_ON = 2,
  TrafficLightStatus_LightStatus_BLINKING = 3
};
bool TrafficLightStatus_LightStatus_IsValid(int value);
const TrafficLightStatus_LightStatus TrafficLightStatus_LightStatus_LightStatus_MIN = TrafficLightStatus_LightStatus_OFF;
const TrafficLightStatus_LightStatus TrafficLightStatus_LightStatus_LightStatus_MAX = TrafficLightStatus_LightStatus_BLINKING;
const int TrafficLightStatus_LightStatus_LightStatus_ARRAYSIZE = TrafficLightStatus_LightStatus_LightStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightStatus_LightStatus_descriptor();
inline const ::std::string& TrafficLightStatus_LightStatus_Name(TrafficLightStatus_LightStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightStatus_LightStatus_descriptor(), value);
}
inline bool TrafficLightStatus_LightStatus_Parse(
    const ::std::string& name, TrafficLightStatus_LightStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightStatus_LightStatus>(
    TrafficLightStatus_LightStatus_descriptor(), name, value);
}
enum ObjectDetection_ObjectTypeEnum {
  ObjectDetection_ObjectTypeEnum_MOVING_GENERAL = 1,
  ObjectDetection_ObjectTypeEnum_STATIC_GENERAL = 2,
  ObjectDetection_ObjectTypeEnum_STATIC_GENERAL_VERTICAL = 3,
  ObjectDetection_ObjectTypeEnum_STATIC_GENERAL_TRANSVERSAL = 4,
  ObjectDetection_ObjectTypeEnum_STATIC_GENERAL_LATERAL = 5,
  ObjectDetection_ObjectTypeEnum_MOVING_VEHICLE = 6,
  ObjectDetection_ObjectTypeEnum_MOVING_TRUCK = 7,
  ObjectDetection_ObjectTypeEnum_MOVING_BIKE = 8,
  ObjectDetection_ObjectTypeEnum_MOVING_PERSON = 9,
  ObjectDetection_ObjectTypeEnum_STATIC_BRIDGE = 10,
  ObjectDetection_ObjectTypeEnum_STATIC_TUNNEL = 11,
  ObjectDetection_ObjectTypeEnum_STATIC_POLE = 12,
  ObjectDetection_ObjectTypeEnum_STATIC_BAR = 13,
  ObjectDetection_ObjectTypeEnum_STATIC_TREE = 14,
  ObjectDetection_ObjectTypeEnum_STATIC_WALL = 15,
  ObjectDetection_ObjectTypeEnum_STATIC_BOLLARD = 16,
  ObjectDetection_ObjectTypeEnum_STATIC_GUIDERAIL = 17,
  ObjectDetection_ObjectTypeEnum_STATIC_TRAFFICISLAND = 18,
  ObjectDetection_ObjectTypeEnum_STATIC_SIGN = 19,
  ObjectDetection_ObjectTypeEnum_STATIC_TRAFFIC_LIGHT = 20
};
bool ObjectDetection_ObjectTypeEnum_IsValid(int value);
const ObjectDetection_ObjectTypeEnum ObjectDetection_ObjectTypeEnum_ObjectTypeEnum_MIN = ObjectDetection_ObjectTypeEnum_MOVING_GENERAL;
const ObjectDetection_ObjectTypeEnum ObjectDetection_ObjectTypeEnum_ObjectTypeEnum_MAX = ObjectDetection_ObjectTypeEnum_STATIC_TRAFFIC_LIGHT;
const int ObjectDetection_ObjectTypeEnum_ObjectTypeEnum_ARRAYSIZE = ObjectDetection_ObjectTypeEnum_ObjectTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectDetection_ObjectTypeEnum_descriptor();
inline const ::std::string& ObjectDetection_ObjectTypeEnum_Name(ObjectDetection_ObjectTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectDetection_ObjectTypeEnum_descriptor(), value);
}
inline bool ObjectDetection_ObjectTypeEnum_Parse(
    const ::std::string& name, ObjectDetection_ObjectTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectDetection_ObjectTypeEnum>(
    ObjectDetection_ObjectTypeEnum_descriptor(), name, value);
}
enum RawGNSSSatData_RawGNSSSatDataType {
  RawGNSSSatData_RawGNSSSatDataType_RINEX = 1
};
bool RawGNSSSatData_RawGNSSSatDataType_IsValid(int value);
const RawGNSSSatData_RawGNSSSatDataType RawGNSSSatData_RawGNSSSatDataType_RawGNSSSatDataType_MIN = RawGNSSSatData_RawGNSSSatDataType_RINEX;
const RawGNSSSatData_RawGNSSSatDataType RawGNSSSatData_RawGNSSSatDataType_RawGNSSSatDataType_MAX = RawGNSSSatData_RawGNSSSatDataType_RINEX;
const int RawGNSSSatData_RawGNSSSatDataType_RawGNSSSatDataType_ARRAYSIZE = RawGNSSSatData_RawGNSSSatDataType_RawGNSSSatDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RawGNSSSatData_RawGNSSSatDataType_descriptor();
inline const ::std::string& RawGNSSSatData_RawGNSSSatDataType_Name(RawGNSSSatData_RawGNSSSatDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RawGNSSSatData_RawGNSSSatDataType_descriptor(), value);
}
inline bool RawGNSSSatData_RawGNSSSatDataType_Parse(
    const ::std::string& name, RawGNSSSatData_RawGNSSSatDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RawGNSSSatData_RawGNSSSatDataType>(
    RawGNSSSatData_RawGNSSSatDataType_descriptor(), name, value);
}
enum MediaContainer_MediaTypeEnum {
  MediaContainer_MediaTypeEnum_OTHER = 1,
  MediaContainer_MediaTypeEnum_IMAGE = 2,
  MediaContainer_MediaTypeEnum_VIDEO = 3,
  MediaContainer_MediaTypeEnum_AUDIO = 4
};
bool MediaContainer_MediaTypeEnum_IsValid(int value);
const MediaContainer_MediaTypeEnum MediaContainer_MediaTypeEnum_MediaTypeEnum_MIN = MediaContainer_MediaTypeEnum_OTHER;
const MediaContainer_MediaTypeEnum MediaContainer_MediaTypeEnum_MediaTypeEnum_MAX = MediaContainer_MediaTypeEnum_AUDIO;
const int MediaContainer_MediaTypeEnum_MediaTypeEnum_ARRAYSIZE = MediaContainer_MediaTypeEnum_MediaTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MediaContainer_MediaTypeEnum_descriptor();
inline const ::std::string& MediaContainer_MediaTypeEnum_Name(MediaContainer_MediaTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MediaContainer_MediaTypeEnum_descriptor(), value);
}
inline bool MediaContainer_MediaTypeEnum_Parse(
    const ::std::string& name, MediaContainer_MediaTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MediaContainer_MediaTypeEnum>(
    MediaContainer_MediaTypeEnum_descriptor(), name, value);
}
enum WheelReferenceBitfield {
  frontAxleLeft = 1,
  frontAxleRight = 2,
  rearAxleLeft = 4,
  rearAxleRight = 8
};
bool WheelReferenceBitfield_IsValid(int value);
const WheelReferenceBitfield WheelReferenceBitfield_MIN = frontAxleLeft;
const WheelReferenceBitfield WheelReferenceBitfield_MAX = rearAxleRight;
const int WheelReferenceBitfield_ARRAYSIZE = WheelReferenceBitfield_MAX + 1;

const ::google::protobuf::EnumDescriptor* WheelReferenceBitfield_descriptor();
inline const ::std::string& WheelReferenceBitfield_Name(WheelReferenceBitfield value) {
  return ::google::protobuf::internal::NameOfEnum(
    WheelReferenceBitfield_descriptor(), value);
}
inline bool WheelReferenceBitfield_Parse(
    const ::std::string& name, WheelReferenceBitfield* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WheelReferenceBitfield>(
    WheelReferenceBitfield_descriptor(), name, value);
}
// ===================================================================

class KeyValuePairString : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyValuePairString) */ {
 public:
  KeyValuePairString();
  virtual ~KeyValuePairString();

  KeyValuePairString(const KeyValuePairString& from);

  inline KeyValuePairString& operator=(const KeyValuePairString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValuePairString& default_instance();

  void Swap(KeyValuePairString* other);

  // implements Message ----------------------------------------------

  inline KeyValuePairString* New() const { return New(NULL); }

  KeyValuePairString* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyValuePairString& from);
  void MergeFrom(const KeyValuePairString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyValuePairString* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:KeyValuePairString)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static KeyValuePairString* default_instance_;
};
// -------------------------------------------------------------------

class Vector3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vector3D) */ {
 public:
  Vector3D();
  virtual ~Vector3D();

  Vector3D(const Vector3D& from);

  inline Vector3D& operator=(const Vector3D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3D& default_instance();

  void Swap(Vector3D* other);

  // implements Message ----------------------------------------------

  inline Vector3D* New() const { return New(NULL); }

  Vector3D* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3D& from);
  void MergeFrom(const Vector3D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double longitudinalValue = 1;
  bool has_longitudinalvalue() const;
  void clear_longitudinalvalue();
  static const int kLongitudinalValueFieldNumber = 1;
  double longitudinalvalue() const;
  void set_longitudinalvalue(double value);

  // required double lateralValue = 2;
  bool has_lateralvalue() const;
  void clear_lateralvalue();
  static const int kLateralValueFieldNumber = 2;
  double lateralvalue() const;
  void set_lateralvalue(double value);

  // required double verticalValue = 3;
  bool has_verticalvalue() const;
  void clear_verticalvalue();
  static const int kVerticalValueFieldNumber = 3;
  double verticalvalue() const;
  void set_verticalvalue(double value);

  // optional double longitudinalAccuracy = 4;
  bool has_longitudinalaccuracy() const;
  void clear_longitudinalaccuracy();
  static const int kLongitudinalAccuracyFieldNumber = 4;
  double longitudinalaccuracy() const;
  void set_longitudinalaccuracy(double value);

  // optional double lateralAccuary = 5;
  bool has_lateralaccuary() const;
  void clear_lateralaccuary();
  static const int kLateralAccuaryFieldNumber = 5;
  double lateralaccuary() const;
  void set_lateralaccuary(double value);

  // optional double verticalAccuracy = 6;
  bool has_verticalaccuracy() const;
  void clear_verticalaccuracy();
  static const int kVerticalAccuracyFieldNumber = 6;
  double verticalaccuracy() const;
  void set_verticalaccuracy(double value);

  // @@protoc_insertion_point(class_scope:Vector3D)
 private:
  inline void set_has_longitudinalvalue();
  inline void clear_has_longitudinalvalue();
  inline void set_has_lateralvalue();
  inline void clear_has_lateralvalue();
  inline void set_has_verticalvalue();
  inline void clear_has_verticalvalue();
  inline void set_has_longitudinalaccuracy();
  inline void clear_has_longitudinalaccuracy();
  inline void set_has_lateralaccuary();
  inline void clear_has_lateralaccuary();
  inline void set_has_verticalaccuracy();
  inline void clear_has_verticalaccuracy();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double longitudinalvalue_;
  double lateralvalue_;
  double verticalvalue_;
  double longitudinalaccuracy_;
  double lateralaccuary_;
  double verticalaccuracy_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static Vector3D* default_instance_;
};
// -------------------------------------------------------------------

class VehicleMetaData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VehicleMetaData) */ {
 public:
  VehicleMetaData();
  virtual ~VehicleMetaData();

  VehicleMetaData(const VehicleMetaData& from);

  inline VehicleMetaData& operator=(const VehicleMetaData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleMetaData& default_instance();

  void Swap(VehicleMetaData* other);

  // implements Message ----------------------------------------------

  inline VehicleMetaData* New() const { return New(NULL); }

  VehicleMetaData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleMetaData& from);
  void MergeFrom(const VehicleMetaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleMetaData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VehicleMetaData_VehicleTypeGenericEnum VehicleTypeGenericEnum;
  static const VehicleTypeGenericEnum BUS =
    VehicleMetaData_VehicleTypeGenericEnum_BUS;
  static const VehicleTypeGenericEnum DELIVERY_TRUCK =
    VehicleMetaData_VehicleTypeGenericEnum_DELIVERY_TRUCK;
  static const VehicleTypeGenericEnum EMERGENCY_VEHICLE =
    VehicleMetaData_VehicleTypeGenericEnum_EMERGENCY_VEHICLE;
  static const VehicleTypeGenericEnum MOTORCYCLE =
    VehicleMetaData_VehicleTypeGenericEnum_MOTORCYCLE;
  static const VehicleTypeGenericEnum PASSENGER_CAR =
    VehicleMetaData_VehicleTypeGenericEnum_PASSENGER_CAR;
  static const VehicleTypeGenericEnum TAXI =
    VehicleMetaData_VehicleTypeGenericEnum_TAXI;
  static const VehicleTypeGenericEnum TRANSPORT_TRUCK =
    VehicleMetaData_VehicleTypeGenericEnum_TRANSPORT_TRUCK;
  static inline bool VehicleTypeGenericEnum_IsValid(int value) {
    return VehicleMetaData_VehicleTypeGenericEnum_IsValid(value);
  }
  static const VehicleTypeGenericEnum VehicleTypeGenericEnum_MIN =
    VehicleMetaData_VehicleTypeGenericEnum_VehicleTypeGenericEnum_MIN;
  static const VehicleTypeGenericEnum VehicleTypeGenericEnum_MAX =
    VehicleMetaData_VehicleTypeGenericEnum_VehicleTypeGenericEnum_MAX;
  static const int VehicleTypeGenericEnum_ARRAYSIZE =
    VehicleMetaData_VehicleTypeGenericEnum_VehicleTypeGenericEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VehicleTypeGenericEnum_descriptor() {
    return VehicleMetaData_VehicleTypeGenericEnum_descriptor();
  }
  static inline const ::std::string& VehicleTypeGenericEnum_Name(VehicleTypeGenericEnum value) {
    return VehicleMetaData_VehicleTypeGenericEnum_Name(value);
  }
  static inline bool VehicleTypeGenericEnum_Parse(const ::std::string& name,
      VehicleTypeGenericEnum* value) {
    return VehicleMetaData_VehicleTypeGenericEnum_Parse(name, value);
  }

  typedef VehicleMetaData_FuelTypeEnum FuelTypeEnum;
  static const FuelTypeEnum FUEL_TYPE_OTHER =
    VehicleMetaData_FuelTypeEnum_FUEL_TYPE_OTHER;
  static const FuelTypeEnum FUEL_TYPE_GASOLINE_L =
    VehicleMetaData_FuelTypeEnum_FUEL_TYPE_GASOLINE_L;
  static const FuelTypeEnum FUEL_TYPE_DIESEL_L =
    VehicleMetaData_FuelTypeEnum_FUEL_TYPE_DIESEL_L;
  static const FuelTypeEnum FUEL_TYPE_AUTOGAS_KG =
    VehicleMetaData_FuelTypeEnum_FUEL_TYPE_AUTOGAS_KG;
  static const FuelTypeEnum FUEL_TYPE_BATTERY_AH =
    VehicleMetaData_FuelTypeEnum_FUEL_TYPE_BATTERY_AH;
  static const FuelTypeEnum FUEL_TYPE_HYDROGEN_KG =
    VehicleMetaData_FuelTypeEnum_FUEL_TYPE_HYDROGEN_KG;
  static inline bool FuelTypeEnum_IsValid(int value) {
    return VehicleMetaData_FuelTypeEnum_IsValid(value);
  }
  static const FuelTypeEnum FuelTypeEnum_MIN =
    VehicleMetaData_FuelTypeEnum_FuelTypeEnum_MIN;
  static const FuelTypeEnum FuelTypeEnum_MAX =
    VehicleMetaData_FuelTypeEnum_FuelTypeEnum_MAX;
  static const int FuelTypeEnum_ARRAYSIZE =
    VehicleMetaData_FuelTypeEnum_FuelTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FuelTypeEnum_descriptor() {
    return VehicleMetaData_FuelTypeEnum_descriptor();
  }
  static inline const ::std::string& FuelTypeEnum_Name(FuelTypeEnum value) {
    return VehicleMetaData_FuelTypeEnum_Name(value);
  }
  static inline bool FuelTypeEnum_Parse(const ::std::string& name,
      FuelTypeEnum* value) {
    return VehicleMetaData_FuelTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .VehicleMetaData.VehicleTypeGenericEnum vehicleTypeGeneric = 1;
  bool has_vehicletypegeneric() const;
  void clear_vehicletypegeneric();
  static const int kVehicleTypeGenericFieldNumber = 1;
  ::VehicleMetaData_VehicleTypeGenericEnum vehicletypegeneric() const;
  void set_vehicletypegeneric(::VehicleMetaData_VehicleTypeGenericEnum value);

  // repeated .KeyValuePairString vehicleSpecificMetaData = 2;
  int vehiclespecificmetadata_size() const;
  void clear_vehiclespecificmetadata();
  static const int kVehicleSpecificMetaDataFieldNumber = 2;
  const ::KeyValuePairString& vehiclespecificmetadata(int index) const;
  ::KeyValuePairString* mutable_vehiclespecificmetadata(int index);
  ::KeyValuePairString* add_vehiclespecificmetadata();
  ::google::protobuf::RepeatedPtrField< ::KeyValuePairString >*
      mutable_vehiclespecificmetadata();
  const ::google::protobuf::RepeatedPtrField< ::KeyValuePairString >&
      vehiclespecificmetadata() const;

  // required double vehicleReferencePointDeltaAboveGround_m = 3;
  bool has_vehiclereferencepointdeltaaboveground_m() const;
  void clear_vehiclereferencepointdeltaaboveground_m();
  static const int kVehicleReferencePointDeltaAboveGroundMFieldNumber = 3;
  double vehiclereferencepointdeltaaboveground_m() const;
  void set_vehiclereferencepointdeltaaboveground_m(double value);

  // optional double curvatureAccuracy_1pm = 4 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_curvatureaccuracy_1pm() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_curvatureaccuracy_1pm();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kCurvatureAccuracy1PmFieldNumber = 4;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR double curvatureaccuracy_1pm() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_curvatureaccuracy_1pm(double value);

  // optional double slopeAccuracy_percent = 5 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_slopeaccuracy_percent() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_slopeaccuracy_percent();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kSlopeAccuracyPercentFieldNumber = 5;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR double slopeaccuracy_percent() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_slopeaccuracy_percent(double value);

  // optional double vehicleLength_m = 6;
  bool has_vehiclelength_m() const;
  void clear_vehiclelength_m();
  static const int kVehicleLengthMFieldNumber = 6;
  double vehiclelength_m() const;
  void set_vehiclelength_m(double value);

  // optional double vehicleWidth_m = 7;
  bool has_vehiclewidth_m() const;
  void clear_vehiclewidth_m();
  static const int kVehicleWidthMFieldNumber = 7;
  double vehiclewidth_m() const;
  void set_vehiclewidth_m(double value);

  // optional double vehicleHeight_m = 8;
  bool has_vehicleheight_m() const;
  void clear_vehicleheight_m();
  static const int kVehicleHeightMFieldNumber = 8;
  double vehicleheight_m() const;
  void set_vehicleheight_m(double value);

  // optional double primaryFuelTankVolume = 9;
  bool has_primaryfueltankvolume() const;
  void clear_primaryfueltankvolume();
  static const int kPrimaryFuelTankVolumeFieldNumber = 9;
  double primaryfueltankvolume() const;
  void set_primaryfueltankvolume(double value);

  // optional .VehicleMetaData.FuelTypeEnum primaryFuelType = 10;
  bool has_primaryfueltype() const;
  void clear_primaryfueltype();
  static const int kPrimaryFuelTypeFieldNumber = 10;
  ::VehicleMetaData_FuelTypeEnum primaryfueltype() const;
  void set_primaryfueltype(::VehicleMetaData_FuelTypeEnum value);

  // optional double secondaryFuelTankVolume = 11;
  bool has_secondaryfueltankvolume() const;
  void clear_secondaryfueltankvolume();
  static const int kSecondaryFuelTankVolumeFieldNumber = 11;
  double secondaryfueltankvolume() const;
  void set_secondaryfueltankvolume(double value);

  // optional .VehicleMetaData.FuelTypeEnum secondaryFuelType = 12;
  bool has_secondaryfueltype() const;
  void clear_secondaryfueltype();
  static const int kSecondaryFuelTypeFieldNumber = 12;
  ::VehicleMetaData_FuelTypeEnum secondaryfueltype() const;
  void set_secondaryfueltype(::VehicleMetaData_FuelTypeEnum value);

  // @@protoc_insertion_point(class_scope:VehicleMetaData)
 private:
  inline void set_has_vehicletypegeneric();
  inline void clear_has_vehicletypegeneric();
  inline void set_has_vehiclereferencepointdeltaaboveground_m();
  inline void clear_has_vehiclereferencepointdeltaaboveground_m();
  inline void set_has_curvatureaccuracy_1pm();
  inline void clear_has_curvatureaccuracy_1pm();
  inline void set_has_slopeaccuracy_percent();
  inline void clear_has_slopeaccuracy_percent();
  inline void set_has_vehiclelength_m();
  inline void clear_has_vehiclelength_m();
  inline void set_has_vehiclewidth_m();
  inline void clear_has_vehiclewidth_m();
  inline void set_has_vehicleheight_m();
  inline void clear_has_vehicleheight_m();
  inline void set_has_primaryfueltankvolume();
  inline void clear_has_primaryfueltankvolume();
  inline void set_has_primaryfueltype();
  inline void clear_has_primaryfueltype();
  inline void set_has_secondaryfueltankvolume();
  inline void clear_has_secondaryfueltankvolume();
  inline void set_has_secondaryfueltype();
  inline void clear_has_secondaryfueltype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::KeyValuePairString > vehiclespecificmetadata_;
  double vehiclereferencepointdeltaaboveground_m_;
  double curvatureaccuracy_1pm_;
  double slopeaccuracy_percent_;
  int vehicletypegeneric_;
  int primaryfueltype_;
  double vehiclelength_m_;
  double vehiclewidth_m_;
  double vehicleheight_m_;
  double primaryfueltankvolume_;
  double secondaryfueltankvolume_;
  int secondaryfueltype_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static VehicleMetaData* default_instance_;
};
// -------------------------------------------------------------------

class Envelope : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Envelope) */ {
 public:
  Envelope();
  virtual ~Envelope();

  Envelope(const Envelope& from);

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();

  void Swap(Envelope* other);

  // implements Message ----------------------------------------------

  inline Envelope* New() const { return New(NULL); }

  Envelope* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Envelope* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // required string submitter = 2;
  bool has_submitter() const;
  void clear_submitter();
  static const int kSubmitterFieldNumber = 2;
  const ::std::string& submitter() const;
  void set_submitter(const ::std::string& value);
  void set_submitter(const char* value);
  void set_submitter(const char* value, size_t size);
  ::std::string* mutable_submitter();
  ::std::string* release_submitter();
  void set_allocated_submitter(::std::string* submitter);

  // required .VehicleMetaData vehicleMetaData = 3;
  bool has_vehiclemetadata() const;
  void clear_vehiclemetadata();
  static const int kVehicleMetaDataFieldNumber = 3;
  const ::VehicleMetaData& vehiclemetadata() const;
  ::VehicleMetaData* mutable_vehiclemetadata();
  ::VehicleMetaData* release_vehiclemetadata();
  void set_allocated_vehiclemetadata(::VehicleMetaData* vehiclemetadata);

  // optional int64 transientVehicleID = 4;
  bool has_transientvehicleid() const;
  void clear_transientvehicleid();
  static const int kTransientVehicleIDFieldNumber = 4;
  ::google::protobuf::int64 transientvehicleid() const;
  void set_transientvehicleid(::google::protobuf::int64 value);

  // optional int64 vehicleProfileID = 5;
  bool has_vehicleprofileid() const;
  void clear_vehicleprofileid();
  static const int kVehicleProfileIDFieldNumber = 5;
  ::google::protobuf::int64 vehicleprofileid() const;
  void set_vehicleprofileid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Envelope)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_submitter();
  inline void clear_has_submitter();
  inline void set_has_vehiclemetadata();
  inline void clear_has_vehiclemetadata();
  inline void set_has_transientvehicleid();
  inline void clear_has_transientvehicleid();
  inline void set_has_vehicleprofileid();
  inline void clear_has_vehicleprofileid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr submitter_;
  ::VehicleMetaData* vehiclemetadata_;
  ::google::protobuf::int64 transientvehicleid_;
  ::google::protobuf::int64 vehicleprofileid_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static Envelope* default_instance_;
};
// -------------------------------------------------------------------

class PositionEstimate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PositionEstimate) */ {
 public:
  PositionEstimate();
  virtual ~PositionEstimate();

  PositionEstimate(const PositionEstimate& from);

  inline PositionEstimate& operator=(const PositionEstimate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionEstimate& default_instance();

  void Swap(PositionEstimate* other);

  // implements Message ----------------------------------------------

  inline PositionEstimate* New() const { return New(NULL); }

  PositionEstimate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PositionEstimate& from);
  void MergeFrom(const PositionEstimate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PositionEstimate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PositionEstimate_PositionTypeEnum PositionTypeEnum;
  static const PositionTypeEnum RAW_GPS =
    PositionEstimate_PositionTypeEnum_RAW_GPS;
  static const PositionTypeEnum FILTERED =
    PositionEstimate_PositionTypeEnum_FILTERED;
  static const PositionTypeEnum MAP_MATCHED_REGULAR_MAP =
    PositionEstimate_PositionTypeEnum_MAP_MATCHED_REGULAR_MAP;
  static const PositionTypeEnum MAP_MATCHED_HD_MAP =
    PositionEstimate_PositionTypeEnum_MAP_MATCHED_HD_MAP;
  static const PositionTypeEnum MAP_MATCHED_HD_MAP_LANE =
    PositionEstimate_PositionTypeEnum_MAP_MATCHED_HD_MAP_LANE;
  static inline bool PositionTypeEnum_IsValid(int value) {
    return PositionEstimate_PositionTypeEnum_IsValid(value);
  }
  static const PositionTypeEnum PositionTypeEnum_MIN =
    PositionEstimate_PositionTypeEnum_PositionTypeEnum_MIN;
  static const PositionTypeEnum PositionTypeEnum_MAX =
    PositionEstimate_PositionTypeEnum_PositionTypeEnum_MAX;
  static const int PositionTypeEnum_ARRAYSIZE =
    PositionEstimate_PositionTypeEnum_PositionTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PositionTypeEnum_descriptor() {
    return PositionEstimate_PositionTypeEnum_descriptor();
  }
  static inline const ::std::string& PositionTypeEnum_Name(PositionTypeEnum value) {
    return PositionEstimate_PositionTypeEnum_Name(value);
  }
  static inline bool PositionTypeEnum_Parse(const ::std::string& name,
      PositionTypeEnum* value) {
    return PositionEstimate_PositionTypeEnum_Parse(name, value);
  }

  typedef PositionEstimate_SpeedDetectionEnum SpeedDetectionEnum;
  static const SpeedDetectionEnum SPEED_RAW_GPS =
    PositionEstimate_SpeedDetectionEnum_SPEED_RAW_GPS;
  static const SpeedDetectionEnum SPEED_WHEEL_TICKS =
    PositionEstimate_SpeedDetectionEnum_SPEED_WHEEL_TICKS;
  static const SpeedDetectionEnum SPEED_RADAR_SONAR =
    PositionEstimate_SpeedDetectionEnum_SPEED_RADAR_SONAR;
  static inline bool SpeedDetectionEnum_IsValid(int value) {
    return PositionEstimate_SpeedDetectionEnum_IsValid(value);
  }
  static const SpeedDetectionEnum SpeedDetectionEnum_MIN =
    PositionEstimate_SpeedDetectionEnum_SpeedDetectionEnum_MIN;
  static const SpeedDetectionEnum SpeedDetectionEnum_MAX =
    PositionEstimate_SpeedDetectionEnum_SpeedDetectionEnum_MAX;
  static const int SpeedDetectionEnum_ARRAYSIZE =
    PositionEstimate_SpeedDetectionEnum_SpeedDetectionEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpeedDetectionEnum_descriptor() {
    return PositionEstimate_SpeedDetectionEnum_descriptor();
  }
  static inline const ::std::string& SpeedDetectionEnum_Name(SpeedDetectionEnum value) {
    return PositionEstimate_SpeedDetectionEnum_Name(value);
  }
  static inline bool SpeedDetectionEnum_Parse(const ::std::string& name,
      SpeedDetectionEnum* value) {
    return PositionEstimate_SpeedDetectionEnum_Parse(name, value);
  }

  typedef PositionEstimate_HeadingDetectionEnum HeadingDetectionEnum;
  static const HeadingDetectionEnum HEADING_RAW_GPS =
    PositionEstimate_HeadingDetectionEnum_HEADING_RAW_GPS;
  static const HeadingDetectionEnum HEADING_MAGNETIC_SENSOR =
    PositionEstimate_HeadingDetectionEnum_HEADING_MAGNETIC_SENSOR;
  static const HeadingDetectionEnum HEADING_MULTI_SENSOR_FUSION =
    PositionEstimate_HeadingDetectionEnum_HEADING_MULTI_SENSOR_FUSION;
  static const HeadingDetectionEnum HEADING_BY_MAP =
    PositionEstimate_HeadingDetectionEnum_HEADING_BY_MAP;
  static inline bool HeadingDetectionEnum_IsValid(int value) {
    return PositionEstimate_HeadingDetectionEnum_IsValid(value);
  }
  static const HeadingDetectionEnum HeadingDetectionEnum_MIN =
    PositionEstimate_HeadingDetectionEnum_HeadingDetectionEnum_MIN;
  static const HeadingDetectionEnum HeadingDetectionEnum_MAX =
    PositionEstimate_HeadingDetectionEnum_HeadingDetectionEnum_MAX;
  static const int HeadingDetectionEnum_ARRAYSIZE =
    PositionEstimate_HeadingDetectionEnum_HeadingDetectionEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HeadingDetectionEnum_descriptor() {
    return PositionEstimate_HeadingDetectionEnum_descriptor();
  }
  static inline const ::std::string& HeadingDetectionEnum_Name(HeadingDetectionEnum value) {
    return PositionEstimate_HeadingDetectionEnum_Name(value);
  }
  static inline bool HeadingDetectionEnum_Parse(const ::std::string& name,
      HeadingDetectionEnum* value) {
    return PositionEstimate_HeadingDetectionEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // required .PositionEstimate.PositionTypeEnum positionType = 2;
  bool has_positiontype() const;
  void clear_positiontype();
  static const int kPositionTypeFieldNumber = 2;
  ::PositionEstimate_PositionTypeEnum positiontype() const;
  void set_positiontype(::PositionEstimate_PositionTypeEnum value);

  // optional bool interpolatedPoint = 3;
  bool has_interpolatedpoint() const;
  void clear_interpolatedpoint();
  static const int kInterpolatedPointFieldNumber = 3;
  bool interpolatedpoint() const;
  void set_interpolatedpoint(bool value);

  // required double longitude_deg = 4;
  bool has_longitude_deg() const;
  void clear_longitude_deg();
  static const int kLongitudeDegFieldNumber = 4;
  double longitude_deg() const;
  void set_longitude_deg(double value);

  // required double latitude_deg = 5;
  bool has_latitude_deg() const;
  void clear_latitude_deg();
  static const int kLatitudeDegFieldNumber = 5;
  double latitude_deg() const;
  void set_latitude_deg(double value);

  // required double horizontalAccuracy_m = 6;
  bool has_horizontalaccuracy_m() const;
  void clear_horizontalaccuracy_m();
  static const int kHorizontalAccuracyMFieldNumber = 6;
  double horizontalaccuracy_m() const;
  void set_horizontalaccuracy_m(double value);

  // optional double altitude_m = 7;
  bool has_altitude_m() const;
  void clear_altitude_m();
  static const int kAltitudeMFieldNumber = 7;
  double altitude_m() const;
  void set_altitude_m(double value);

  // optional double heading_deg = 8;
  bool has_heading_deg() const;
  void clear_heading_deg();
  static const int kHeadingDegFieldNumber = 8;
  double heading_deg() const;
  void set_heading_deg(double value);

  // optional double speed_mps = 9;
  bool has_speed_mps() const;
  void clear_speed_mps();
  static const int kSpeedMpsFieldNumber = 9;
  double speed_mps() const;
  void set_speed_mps(double value);

  // optional double altitudeAccuracy_m = 10;
  bool has_altitudeaccuracy_m() const;
  void clear_altitudeaccuracy_m();
  static const int kAltitudeAccuracyMFieldNumber = 10;
  double altitudeaccuracy_m() const;
  void set_altitudeaccuracy_m(double value);

  // optional double headingAccuracy_deg = 11;
  bool has_headingaccuracy_deg() const;
  void clear_headingaccuracy_deg();
  static const int kHeadingAccuracyDegFieldNumber = 11;
  double headingaccuracy_deg() const;
  void set_headingaccuracy_deg(double value);

  // optional double speedAccuracy_mps = 12;
  bool has_speedaccuracy_mps() const;
  void clear_speedaccuracy_mps();
  static const int kSpeedAccuracyMpsFieldNumber = 12;
  double speedaccuracy_mps() const;
  void set_speedaccuracy_mps(double value);

  // optional .PositionEstimate.SpeedDetectionEnum speedDetectionType = 13;
  bool has_speeddetectiontype() const;
  void clear_speeddetectiontype();
  static const int kSpeedDetectionTypeFieldNumber = 13;
  ::PositionEstimate_SpeedDetectionEnum speeddetectiontype() const;
  void set_speeddetectiontype(::PositionEstimate_SpeedDetectionEnum value);

  // optional .PositionEstimate.HeadingDetectionEnum headingDetectionType = 14;
  bool has_headingdetectiontype() const;
  void clear_headingdetectiontype();
  static const int kHeadingDetectionTypeFieldNumber = 14;
  ::PositionEstimate_HeadingDetectionEnum headingdetectiontype() const;
  void set_headingdetectiontype(::PositionEstimate_HeadingDetectionEnum value);

  // optional .Vector3D vehicleReferencedOrientationVector_deg = 15;
  bool has_vehiclereferencedorientationvector_deg() const;
  void clear_vehiclereferencedorientationvector_deg();
  static const int kVehicleReferencedOrientationVectorDegFieldNumber = 15;
  const ::Vector3D& vehiclereferencedorientationvector_deg() const;
  ::Vector3D* mutable_vehiclereferencedorientationvector_deg();
  ::Vector3D* release_vehiclereferencedorientationvector_deg();
  void set_allocated_vehiclereferencedorientationvector_deg(::Vector3D* vehiclereferencedorientationvector_deg);

  // optional int32 currentLaneEstimate = 16;
  bool has_currentlaneestimate() const;
  void clear_currentlaneestimate();
  static const int kCurrentLaneEstimateFieldNumber = 16;
  ::google::protobuf::int32 currentlaneestimate() const;
  void set_currentlaneestimate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PositionEstimate)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_positiontype();
  inline void clear_has_positiontype();
  inline void set_has_interpolatedpoint();
  inline void clear_has_interpolatedpoint();
  inline void set_has_longitude_deg();
  inline void clear_has_longitude_deg();
  inline void set_has_latitude_deg();
  inline void clear_has_latitude_deg();
  inline void set_has_horizontalaccuracy_m();
  inline void clear_has_horizontalaccuracy_m();
  inline void set_has_altitude_m();
  inline void clear_has_altitude_m();
  inline void set_has_heading_deg();
  inline void clear_has_heading_deg();
  inline void set_has_speed_mps();
  inline void clear_has_speed_mps();
  inline void set_has_altitudeaccuracy_m();
  inline void clear_has_altitudeaccuracy_m();
  inline void set_has_headingaccuracy_deg();
  inline void clear_has_headingaccuracy_deg();
  inline void set_has_speedaccuracy_mps();
  inline void clear_has_speedaccuracy_mps();
  inline void set_has_speeddetectiontype();
  inline void clear_has_speeddetectiontype();
  inline void set_has_headingdetectiontype();
  inline void clear_has_headingdetectiontype();
  inline void set_has_vehiclereferencedorientationvector_deg();
  inline void clear_has_vehiclereferencedorientationvector_deg();
  inline void set_has_currentlaneestimate();
  inline void clear_has_currentlaneestimate();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  int positiontype_;
  bool interpolatedpoint_;
  double longitude_deg_;
  double latitude_deg_;
  double horizontalaccuracy_m_;
  double altitude_m_;
  double heading_deg_;
  double speed_mps_;
  double altitudeaccuracy_m_;
  double headingaccuracy_deg_;
  double speedaccuracy_mps_;
  int speeddetectiontype_;
  int headingdetectiontype_;
  ::Vector3D* vehiclereferencedorientationvector_deg_;
  ::google::protobuf::int32 currentlaneestimate_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static PositionEstimate* default_instance_;
};
// -------------------------------------------------------------------

class PathSegment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PathSegment) */ {
 public:
  PathSegment();
  virtual ~PathSegment();

  PathSegment(const PathSegment& from);

  inline PathSegment& operator=(const PathSegment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathSegment& default_instance();

  void Swap(PathSegment* other);

  // implements Message ----------------------------------------------

  inline PathSegment* New() const { return New(NULL); }

  PathSegment* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PathSegment& from);
  void MergeFrom(const PathSegment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PathSegment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PositionEstimate positionEstimate = 1;
  int positionestimate_size() const;
  void clear_positionestimate();
  static const int kPositionEstimateFieldNumber = 1;
  const ::PositionEstimate& positionestimate(int index) const;
  ::PositionEstimate* mutable_positionestimate(int index);
  ::PositionEstimate* add_positionestimate();
  ::google::protobuf::RepeatedPtrField< ::PositionEstimate >*
      mutable_positionestimate();
  const ::google::protobuf::RepeatedPtrField< ::PositionEstimate >&
      positionestimate() const;

  // @@protoc_insertion_point(class_scope:PathSegment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PositionEstimate > positionestimate_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static PathSegment* default_instance_;
};
// -------------------------------------------------------------------

class Path : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Path) */ {
 public:
  Path();
  virtual ~Path();

  Path(const Path& from);

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Path& default_instance();

  void Swap(Path* other);

  // implements Message ----------------------------------------------

  inline Path* New() const { return New(NULL); }

  Path* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Path* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PositionEstimate positionEstimate = 1;
  int positionestimate_size() const;
  void clear_positionestimate();
  static const int kPositionEstimateFieldNumber = 1;
  const ::PositionEstimate& positionestimate(int index) const;
  ::PositionEstimate* mutable_positionestimate(int index);
  ::PositionEstimate* add_positionestimate();
  ::google::protobuf::RepeatedPtrField< ::PositionEstimate >*
      mutable_positionestimate();
  const ::google::protobuf::RepeatedPtrField< ::PositionEstimate >&
      positionestimate() const;

  // repeated .PathSegment positionSegments = 2 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR int positionsegments_size() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_positionsegments();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kPositionSegmentsFieldNumber = 2;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::PathSegment& positionsegments(int index) const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::PathSegment* mutable_positionsegments(int index);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::PathSegment* add_positionsegments();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField< ::PathSegment >*
      mutable_positionsegments();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField< ::PathSegment >&
      positionsegments() const;

  // @@protoc_insertion_point(class_scope:Path)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PositionEstimate > positionestimate_;
  ::google::protobuf::RepeatedPtrField< ::PathSegment > positionsegments_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static Path* default_instance_;
};
// -------------------------------------------------------------------

class VehicleStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VehicleStatus) */ {
 public:
  VehicleStatus();
  virtual ~VehicleStatus();

  VehicleStatus(const VehicleStatus& from);

  inline VehicleStatus& operator=(const VehicleStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleStatus& default_instance();

  void Swap(VehicleStatus* other);

  // implements Message ----------------------------------------------

  inline VehicleStatus* New() const { return New(NULL); }

  VehicleStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleStatus& from);
  void MergeFrom(const VehicleStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VehicleStatus_TransmissionModeEnum TransmissionModeEnum;
  static const TransmissionModeEnum PARK =
    VehicleStatus_TransmissionModeEnum_PARK;
  static const TransmissionModeEnum COASTING =
    VehicleStatus_TransmissionModeEnum_COASTING;
  static const TransmissionModeEnum DRIVE =
    VehicleStatus_TransmissionModeEnum_DRIVE;
  static const TransmissionModeEnum REVERSE =
    VehicleStatus_TransmissionModeEnum_REVERSE;
  static inline bool TransmissionModeEnum_IsValid(int value) {
    return VehicleStatus_TransmissionModeEnum_IsValid(value);
  }
  static const TransmissionModeEnum TransmissionModeEnum_MIN =
    VehicleStatus_TransmissionModeEnum_TransmissionModeEnum_MIN;
  static const TransmissionModeEnum TransmissionModeEnum_MAX =
    VehicleStatus_TransmissionModeEnum_TransmissionModeEnum_MAX;
  static const int TransmissionModeEnum_ARRAYSIZE =
    VehicleStatus_TransmissionModeEnum_TransmissionModeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransmissionModeEnum_descriptor() {
    return VehicleStatus_TransmissionModeEnum_descriptor();
  }
  static inline const ::std::string& TransmissionModeEnum_Name(TransmissionModeEnum value) {
    return VehicleStatus_TransmissionModeEnum_Name(value);
  }
  static inline bool TransmissionModeEnum_Parse(const ::std::string& name,
      TransmissionModeEnum* value) {
    return VehicleStatus_TransmissionModeEnum_Parse(name, value);
  }

  typedef VehicleStatus_LightStateBitfield LightStateBitfield;
  static const LightStateBitfield LOWBEAMS =
    VehicleStatus_LightStateBitfield_LOWBEAMS;
  static const LightStateBitfield HIGHBEAMS =
    VehicleStatus_LightStateBitfield_HIGHBEAMS;
  static const LightStateBitfield FOGLAMP_FRONT =
    VehicleStatus_LightStateBitfield_FOGLAMP_FRONT;
  static const LightStateBitfield FOGLAMP_REAR =
    VehicleStatus_LightStateBitfield_FOGLAMP_REAR;
  static const LightStateBitfield HAZARD =
    VehicleStatus_LightStateBitfield_HAZARD;
  static const LightStateBitfield LEFT_TURN =
    VehicleStatus_LightStateBitfield_LEFT_TURN;
  static const LightStateBitfield RIGHT_TURN =
    VehicleStatus_LightStateBitfield_RIGHT_TURN;
  static inline bool LightStateBitfield_IsValid(int value) {
    return VehicleStatus_LightStateBitfield_IsValid(value);
  }
  static const LightStateBitfield LightStateBitfield_MIN =
    VehicleStatus_LightStateBitfield_LightStateBitfield_MIN;
  static const LightStateBitfield LightStateBitfield_MAX =
    VehicleStatus_LightStateBitfield_LightStateBitfield_MAX;
  static const int LightStateBitfield_ARRAYSIZE =
    VehicleStatus_LightStateBitfield_LightStateBitfield_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LightStateBitfield_descriptor() {
    return VehicleStatus_LightStateBitfield_descriptor();
  }
  static inline const ::std::string& LightStateBitfield_Name(LightStateBitfield value) {
    return VehicleStatus_LightStateBitfield_Name(value);
  }
  static inline bool LightStateBitfield_Parse(const ::std::string& name,
      LightStateBitfield* value) {
    return VehicleStatus_LightStateBitfield_Parse(name, value);
  }

  typedef VehicleStatus_WiperStateEnum WiperStateEnum;
  static const WiperStateEnum WIPING_OFF =
    VehicleStatus_WiperStateEnum_WIPING_OFF;
  static const WiperStateEnum WIPING_SLOW =
    VehicleStatus_WiperStateEnum_WIPING_SLOW;
  static const WiperStateEnum WIPING_MEDIUM =
    VehicleStatus_WiperStateEnum_WIPING_MEDIUM;
  static const WiperStateEnum WIPING_FAST =
    VehicleStatus_WiperStateEnum_WIPING_FAST;
  static const WiperStateEnum WIPING_INTERVALL =
    VehicleStatus_WiperStateEnum_WIPING_INTERVALL;
  static inline bool WiperStateEnum_IsValid(int value) {
    return VehicleStatus_WiperStateEnum_IsValid(value);
  }
  static const WiperStateEnum WiperStateEnum_MIN =
    VehicleStatus_WiperStateEnum_WiperStateEnum_MIN;
  static const WiperStateEnum WiperStateEnum_MAX =
    VehicleStatus_WiperStateEnum_WiperStateEnum_MAX;
  static const int WiperStateEnum_ARRAYSIZE =
    VehicleStatus_WiperStateEnum_WiperStateEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WiperStateEnum_descriptor() {
    return VehicleStatus_WiperStateEnum_descriptor();
  }
  static inline const ::std::string& WiperStateEnum_Name(WiperStateEnum value) {
    return VehicleStatus_WiperStateEnum_Name(value);
  }
  static inline bool WiperStateEnum_Parse(const ::std::string& name,
      WiperStateEnum* value) {
    return VehicleStatus_WiperStateEnum_Parse(name, value);
  }

  typedef VehicleStatus_MaintenanceLightStateBitfield MaintenanceLightStateBitfield;
  static const MaintenanceLightStateBitfield WARNING_ENGINE_CONTROL =
    VehicleStatus_MaintenanceLightStateBitfield_WARNING_ENGINE_CONTROL;
  static const MaintenanceLightStateBitfield WARNING_OIL_PRESSURE =
    VehicleStatus_MaintenanceLightStateBitfield_WARNING_OIL_PRESSURE;
  static const MaintenanceLightStateBitfield WARNING_COOLANT_TEMP =
    VehicleStatus_MaintenanceLightStateBitfield_WARNING_COOLANT_TEMP;
  static const MaintenanceLightStateBitfield WARNING_VEHICLE_SERVICE =
    VehicleStatus_MaintenanceLightStateBitfield_WARNING_VEHICLE_SERVICE;
  static const MaintenanceLightStateBitfield WARNING_BATTERY_CHARGING =
    VehicleStatus_MaintenanceLightStateBitfield_WARNING_BATTERY_CHARGING;
  static const MaintenanceLightStateBitfield WARNING_TIRE_PRESSURE =
    VehicleStatus_MaintenanceLightStateBitfield_WARNING_TIRE_PRESSURE;
  static const MaintenanceLightStateBitfield WARNING_LAMP_OUT =
    VehicleStatus_MaintenanceLightStateBitfield_WARNING_LAMP_OUT;
  static const MaintenanceLightStateBitfield WARNING_OTHER_HIGH_PRIO =
    VehicleStatus_MaintenanceLightStateBitfield_WARNING_OTHER_HIGH_PRIO;
  static const MaintenanceLightStateBitfield WARNING_OTHER_LOW_PRIO =
    VehicleStatus_MaintenanceLightStateBitfield_WARNING_OTHER_LOW_PRIO;
  static inline bool MaintenanceLightStateBitfield_IsValid(int value) {
    return VehicleStatus_MaintenanceLightStateBitfield_IsValid(value);
  }
  static const MaintenanceLightStateBitfield MaintenanceLightStateBitfield_MIN =
    VehicleStatus_MaintenanceLightStateBitfield_MaintenanceLightStateBitfield_MIN;
  static const MaintenanceLightStateBitfield MaintenanceLightStateBitfield_MAX =
    VehicleStatus_MaintenanceLightStateBitfield_MaintenanceLightStateBitfield_MAX;
  static const int MaintenanceLightStateBitfield_ARRAYSIZE =
    VehicleStatus_MaintenanceLightStateBitfield_MaintenanceLightStateBitfield_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MaintenanceLightStateBitfield_descriptor() {
    return VehicleStatus_MaintenanceLightStateBitfield_descriptor();
  }
  static inline const ::std::string& MaintenanceLightStateBitfield_Name(MaintenanceLightStateBitfield value) {
    return VehicleStatus_MaintenanceLightStateBitfield_Name(value);
  }
  static inline bool MaintenanceLightStateBitfield_Parse(const ::std::string& name,
      MaintenanceLightStateBitfield* value) {
    return VehicleStatus_MaintenanceLightStateBitfield_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // optional .VehicleStatus.TransmissionModeEnum transmissionMode = 2;
  bool has_transmissionmode() const;
  void clear_transmissionmode();
  static const int kTransmissionModeFieldNumber = 2;
  ::VehicleStatus_TransmissionModeEnum transmissionmode() const;
  void set_transmissionmode(::VehicleStatus_TransmissionModeEnum value);

  // optional int64 lightStateBitfield = 3;
  bool has_lightstatebitfield() const;
  void clear_lightstatebitfield();
  static const int kLightStateBitfieldFieldNumber = 3;
  ::google::protobuf::int64 lightstatebitfield() const;
  void set_lightstatebitfield(::google::protobuf::int64 value);

  // optional .VehicleStatus.WiperStateEnum wiperState = 4;
  bool has_wiperstate() const;
  void clear_wiperstate();
  static const int kWiperStateFieldNumber = 4;
  ::VehicleStatus_WiperStateEnum wiperstate() const;
  void set_wiperstate(::VehicleStatus_WiperStateEnum value);

  // optional double temperatureExternal_cel = 5 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_temperatureexternal_cel() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_temperatureexternal_cel();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kTemperatureExternalCelFieldNumber = 5;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR double temperatureexternal_cel() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_temperatureexternal_cel(double value);

  // optional int32 wiperSpeed_wpm = 6;
  bool has_wiperspeed_wpm() const;
  void clear_wiperspeed_wpm();
  static const int kWiperSpeedWpmFieldNumber = 6;
  ::google::protobuf::int32 wiperspeed_wpm() const;
  void set_wiperspeed_wpm(::google::protobuf::int32 value);

  // optional int64 driveWheelReference = 7;
  bool has_drivewheelreference() const;
  void clear_drivewheelreference();
  static const int kDriveWheelReferenceFieldNumber = 7;
  ::google::protobuf::int64 drivewheelreference() const;
  void set_drivewheelreference(::google::protobuf::int64 value);

  // optional double chassisClearance_m = 8;
  bool has_chassisclearance_m() const;
  void clear_chassisclearance_m();
  static const int kChassisClearanceMFieldNumber = 8;
  double chassisclearance_m() const;
  void set_chassisclearance_m(double value);

  // optional double mileage_km = 9;
  bool has_mileage_km() const;
  void clear_mileage_km();
  static const int kMileageKmFieldNumber = 9;
  double mileage_km() const;
  void set_mileage_km(double value);

  // optional double primaryFuelState = 10;
  bool has_primaryfuelstate() const;
  void clear_primaryfuelstate();
  static const int kPrimaryFuelStateFieldNumber = 10;
  double primaryfuelstate() const;
  void set_primaryfuelstate(double value);

  // optional double primaryFuelStateAccuracy = 11;
  bool has_primaryfuelstateaccuracy() const;
  void clear_primaryfuelstateaccuracy();
  static const int kPrimaryFuelStateAccuracyFieldNumber = 11;
  double primaryfuelstateaccuracy() const;
  void set_primaryfuelstateaccuracy(double value);

  // optional double estimatedPrimaryRange_km = 12;
  bool has_estimatedprimaryrange_km() const;
  void clear_estimatedprimaryrange_km();
  static const int kEstimatedPrimaryRangeKmFieldNumber = 12;
  double estimatedprimaryrange_km() const;
  void set_estimatedprimaryrange_km(double value);

  // optional double secondaryFuelState = 13;
  bool has_secondaryfuelstate() const;
  void clear_secondaryfuelstate();
  static const int kSecondaryFuelStateFieldNumber = 13;
  double secondaryfuelstate() const;
  void set_secondaryfuelstate(double value);

  // optional double secondaryFuelStateAccuracy = 14;
  bool has_secondaryfuelstateaccuracy() const;
  void clear_secondaryfuelstateaccuracy();
  static const int kSecondaryFuelStateAccuracyFieldNumber = 14;
  double secondaryfuelstateaccuracy() const;
  void set_secondaryfuelstateaccuracy(double value);

  // optional double estimatedSecondaryRange_km = 15;
  bool has_estimatedsecondaryrange_km() const;
  void clear_estimatedsecondaryrange_km();
  static const int kEstimatedSecondaryRangeKmFieldNumber = 15;
  double estimatedsecondaryrange_km() const;
  void set_estimatedsecondaryrange_km(double value);

  // optional .VehicleStatus.MaintenanceLightStateBitfield maintenanceLightState = 16;
  bool has_maintenancelightstate() const;
  void clear_maintenancelightstate();
  static const int kMaintenanceLightStateFieldNumber = 16;
  ::VehicleStatus_MaintenanceLightStateBitfield maintenancelightstate() const;
  void set_maintenancelightstate(::VehicleStatus_MaintenanceLightStateBitfield value);

  // @@protoc_insertion_point(class_scope:VehicleStatus)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_transmissionmode();
  inline void clear_has_transmissionmode();
  inline void set_has_lightstatebitfield();
  inline void clear_has_lightstatebitfield();
  inline void set_has_wiperstate();
  inline void clear_has_wiperstate();
  inline void set_has_temperatureexternal_cel();
  inline void clear_has_temperatureexternal_cel();
  inline void set_has_wiperspeed_wpm();
  inline void clear_has_wiperspeed_wpm();
  inline void set_has_drivewheelreference();
  inline void clear_has_drivewheelreference();
  inline void set_has_chassisclearance_m();
  inline void clear_has_chassisclearance_m();
  inline void set_has_mileage_km();
  inline void clear_has_mileage_km();
  inline void set_has_primaryfuelstate();
  inline void clear_has_primaryfuelstate();
  inline void set_has_primaryfuelstateaccuracy();
  inline void clear_has_primaryfuelstateaccuracy();
  inline void set_has_estimatedprimaryrange_km();
  inline void clear_has_estimatedprimaryrange_km();
  inline void set_has_secondaryfuelstate();
  inline void clear_has_secondaryfuelstate();
  inline void set_has_secondaryfuelstateaccuracy();
  inline void clear_has_secondaryfuelstateaccuracy();
  inline void set_has_estimatedsecondaryrange_km();
  inline void clear_has_estimatedsecondaryrange_km();
  inline void set_has_maintenancelightstate();
  inline void clear_has_maintenancelightstate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  ::google::protobuf::int64 lightstatebitfield_;
  int transmissionmode_;
  int wiperstate_;
  double temperatureexternal_cel_;
  ::google::protobuf::int64 drivewheelreference_;
  double chassisclearance_m_;
  double mileage_km_;
  double primaryfuelstate_;
  double primaryfuelstateaccuracy_;
  ::google::protobuf::int32 wiperspeed_wpm_;
  int maintenancelightstate_;
  double estimatedprimaryrange_km_;
  double secondaryfuelstate_;
  double secondaryfuelstateaccuracy_;
  double estimatedsecondaryrange_km_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static VehicleStatus* default_instance_;
};
// -------------------------------------------------------------------

class VehicleDynamics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VehicleDynamics) */ {
 public:
  VehicleDynamics();
  virtual ~VehicleDynamics();

  VehicleDynamics(const VehicleDynamics& from);

  inline VehicleDynamics& operator=(const VehicleDynamics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleDynamics& default_instance();

  void Swap(VehicleDynamics* other);

  // implements Message ----------------------------------------------

  inline VehicleDynamics* New() const { return New(NULL); }

  VehicleDynamics* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleDynamics& from);
  void MergeFrom(const VehicleDynamics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleDynamics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // optional double curvature_1pm = 2;
  bool has_curvature_1pm() const;
  void clear_curvature_1pm();
  static const int kCurvature1PmFieldNumber = 2;
  double curvature_1pm() const;
  void set_curvature_1pm(double value);

  // optional double slope_percent = 3;
  bool has_slope_percent() const;
  void clear_slope_percent();
  static const int kSlopePercentFieldNumber = 3;
  double slope_percent() const;
  void set_slope_percent(double value);

  // optional double curvatureAccuracy_1pm = 4;
  bool has_curvatureaccuracy_1pm() const;
  void clear_curvatureaccuracy_1pm();
  static const int kCurvatureAccuracy1PmFieldNumber = 4;
  double curvatureaccuracy_1pm() const;
  void set_curvatureaccuracy_1pm(double value);

  // optional double slopeAccuracy_percent = 5;
  bool has_slopeaccuracy_percent() const;
  void clear_slopeaccuracy_percent();
  static const int kSlopeAccuracyPercentFieldNumber = 5;
  double slopeaccuracy_percent() const;
  void set_slopeaccuracy_percent(double value);

  // optional int32 averageSuspensionTravel_mm = 6;
  bool has_averagesuspensiontravel_mm() const;
  void clear_averagesuspensiontravel_mm();
  static const int kAverageSuspensionTravelMmFieldNumber = 6;
  ::google::protobuf::int32 averagesuspensiontravel_mm() const;
  void set_averagesuspensiontravel_mm(::google::protobuf::int32 value);

  // optional .Vector3D averageAccelerationVector_mps2 = 7;
  bool has_averageaccelerationvector_mps2() const;
  void clear_averageaccelerationvector_mps2();
  static const int kAverageAccelerationVectorMps2FieldNumber = 7;
  const ::Vector3D& averageaccelerationvector_mps2() const;
  ::Vector3D* mutable_averageaccelerationvector_mps2();
  ::Vector3D* release_averageaccelerationvector_mps2();
  void set_allocated_averageaccelerationvector_mps2(::Vector3D* averageaccelerationvector_mps2);

  // optional .Vector3D averageRotationRateVector_omega = 8;
  bool has_averagerotationratevector_omega() const;
  void clear_averagerotationratevector_omega();
  static const int kAverageRotationRateVectorOmegaFieldNumber = 8;
  const ::Vector3D& averagerotationratevector_omega() const;
  ::Vector3D* mutable_averagerotationratevector_omega();
  ::Vector3D* release_averagerotationratevector_omega();
  void set_allocated_averagerotationratevector_omega(::Vector3D* averagerotationratevector_omega);

  // optional .Vector3D averageSpeedVector_mps = 1000;
  bool has_averagespeedvector_mps() const;
  void clear_averagespeedvector_mps();
  static const int kAverageSpeedVectorMpsFieldNumber = 1000;
  const ::Vector3D& averagespeedvector_mps() const;
  ::Vector3D* mutable_averagespeedvector_mps();
  ::Vector3D* release_averagespeedvector_mps();
  void set_allocated_averagespeedvector_mps(::Vector3D* averagespeedvector_mps);

  // optional .Vector3D relativePositionVector_m = 1001;
  bool has_relativepositionvector_m() const;
  void clear_relativepositionvector_m();
  static const int kRelativePositionVectorMFieldNumber = 1001;
  const ::Vector3D& relativepositionvector_m() const;
  ::Vector3D* mutable_relativepositionvector_m();
  ::Vector3D* release_relativepositionvector_m();
  void set_allocated_relativepositionvector_m(::Vector3D* relativepositionvector_m);

  // @@protoc_insertion_point(class_scope:VehicleDynamics)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_curvature_1pm();
  inline void clear_has_curvature_1pm();
  inline void set_has_slope_percent();
  inline void clear_has_slope_percent();
  inline void set_has_curvatureaccuracy_1pm();
  inline void clear_has_curvatureaccuracy_1pm();
  inline void set_has_slopeaccuracy_percent();
  inline void clear_has_slopeaccuracy_percent();
  inline void set_has_averagesuspensiontravel_mm();
  inline void clear_has_averagesuspensiontravel_mm();
  inline void set_has_averageaccelerationvector_mps2();
  inline void clear_has_averageaccelerationvector_mps2();
  inline void set_has_averagerotationratevector_omega();
  inline void clear_has_averagerotationratevector_omega();
  inline void set_has_averagespeedvector_mps();
  inline void clear_has_averagespeedvector_mps();
  inline void set_has_relativepositionvector_m();
  inline void clear_has_relativepositionvector_m();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  double curvature_1pm_;
  double slope_percent_;
  double curvatureaccuracy_1pm_;
  double slopeaccuracy_percent_;
  ::Vector3D* averageaccelerationvector_mps2_;
  ::Vector3D* averagerotationratevector_omega_;
  ::Vector3D* averagespeedvector_mps_;
  ::Vector3D* relativepositionvector_m_;
  ::google::protobuf::int32 averagesuspensiontravel_mm_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static VehicleDynamics* default_instance_;
};
// -------------------------------------------------------------------

class PositionOffset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PositionOffset) */ {
 public:
  PositionOffset();
  virtual ~PositionOffset();

  PositionOffset(const PositionOffset& from);

  inline PositionOffset& operator=(const PositionOffset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionOffset& default_instance();

  void Swap(PositionOffset* other);

  // implements Message ----------------------------------------------

  inline PositionOffset* New() const { return New(NULL); }

  PositionOffset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PositionOffset& from);
  void MergeFrom(const PositionOffset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PositionOffset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PositionOffset_LateralOffsetSimpleEnum LateralOffsetSimpleEnum;
  static const LateralOffsetSimpleEnum LEFT =
    PositionOffset_LateralOffsetSimpleEnum_LEFT;
  static const LateralOffsetSimpleEnum MIDDLE =
    PositionOffset_LateralOffsetSimpleEnum_MIDDLE;
  static const LateralOffsetSimpleEnum RIGHT =
    PositionOffset_LateralOffsetSimpleEnum_RIGHT;
  static inline bool LateralOffsetSimpleEnum_IsValid(int value) {
    return PositionOffset_LateralOffsetSimpleEnum_IsValid(value);
  }
  static const LateralOffsetSimpleEnum LateralOffsetSimpleEnum_MIN =
    PositionOffset_LateralOffsetSimpleEnum_LateralOffsetSimpleEnum_MIN;
  static const LateralOffsetSimpleEnum LateralOffsetSimpleEnum_MAX =
    PositionOffset_LateralOffsetSimpleEnum_LateralOffsetSimpleEnum_MAX;
  static const int LateralOffsetSimpleEnum_ARRAYSIZE =
    PositionOffset_LateralOffsetSimpleEnum_LateralOffsetSimpleEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LateralOffsetSimpleEnum_descriptor() {
    return PositionOffset_LateralOffsetSimpleEnum_descriptor();
  }
  static inline const ::std::string& LateralOffsetSimpleEnum_Name(LateralOffsetSimpleEnum value) {
    return PositionOffset_LateralOffsetSimpleEnum_Name(value);
  }
  static inline bool LateralOffsetSimpleEnum_Parse(const ::std::string& name,
      LateralOffsetSimpleEnum* value) {
    return PositionOffset_LateralOffsetSimpleEnum_Parse(name, value);
  }

  typedef PositionOffset_LongitudinalOffsetSimpleEnum LongitudinalOffsetSimpleEnum;
  static const LongitudinalOffsetSimpleEnum FRONT =
    PositionOffset_LongitudinalOffsetSimpleEnum_FRONT;
  static const LongitudinalOffsetSimpleEnum CENTER =
    PositionOffset_LongitudinalOffsetSimpleEnum_CENTER;
  static const LongitudinalOffsetSimpleEnum BACK =
    PositionOffset_LongitudinalOffsetSimpleEnum_BACK;
  static inline bool LongitudinalOffsetSimpleEnum_IsValid(int value) {
    return PositionOffset_LongitudinalOffsetSimpleEnum_IsValid(value);
  }
  static const LongitudinalOffsetSimpleEnum LongitudinalOffsetSimpleEnum_MIN =
    PositionOffset_LongitudinalOffsetSimpleEnum_LongitudinalOffsetSimpleEnum_MIN;
  static const LongitudinalOffsetSimpleEnum LongitudinalOffsetSimpleEnum_MAX =
    PositionOffset_LongitudinalOffsetSimpleEnum_LongitudinalOffsetSimpleEnum_MAX;
  static const int LongitudinalOffsetSimpleEnum_ARRAYSIZE =
    PositionOffset_LongitudinalOffsetSimpleEnum_LongitudinalOffsetSimpleEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LongitudinalOffsetSimpleEnum_descriptor() {
    return PositionOffset_LongitudinalOffsetSimpleEnum_descriptor();
  }
  static inline const ::std::string& LongitudinalOffsetSimpleEnum_Name(LongitudinalOffsetSimpleEnum value) {
    return PositionOffset_LongitudinalOffsetSimpleEnum_Name(value);
  }
  static inline bool LongitudinalOffsetSimpleEnum_Parse(const ::std::string& name,
      LongitudinalOffsetSimpleEnum* value) {
    return PositionOffset_LongitudinalOffsetSimpleEnum_Parse(name, value);
  }

  typedef PositionOffset_VerticalOffsetSimpleEnum VerticalOffsetSimpleEnum;
  static const VerticalOffsetSimpleEnum ABOVE =
    PositionOffset_VerticalOffsetSimpleEnum_ABOVE;
  static const VerticalOffsetSimpleEnum AT_LEVEL =
    PositionOffset_VerticalOffsetSimpleEnum_AT_LEVEL;
  static const VerticalOffsetSimpleEnum BELOW =
    PositionOffset_VerticalOffsetSimpleEnum_BELOW;
  static inline bool VerticalOffsetSimpleEnum_IsValid(int value) {
    return PositionOffset_VerticalOffsetSimpleEnum_IsValid(value);
  }
  static const VerticalOffsetSimpleEnum VerticalOffsetSimpleEnum_MIN =
    PositionOffset_VerticalOffsetSimpleEnum_VerticalOffsetSimpleEnum_MIN;
  static const VerticalOffsetSimpleEnum VerticalOffsetSimpleEnum_MAX =
    PositionOffset_VerticalOffsetSimpleEnum_VerticalOffsetSimpleEnum_MAX;
  static const int VerticalOffsetSimpleEnum_ARRAYSIZE =
    PositionOffset_VerticalOffsetSimpleEnum_VerticalOffsetSimpleEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VerticalOffsetSimpleEnum_descriptor() {
    return PositionOffset_VerticalOffsetSimpleEnum_descriptor();
  }
  static inline const ::std::string& VerticalOffsetSimpleEnum_Name(VerticalOffsetSimpleEnum value) {
    return PositionOffset_VerticalOffsetSimpleEnum_Name(value);
  }
  static inline bool VerticalOffsetSimpleEnum_Parse(const ::std::string& name,
      VerticalOffsetSimpleEnum* value) {
    return PositionOffset_VerticalOffsetSimpleEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double lateralOffset_m = 1;
  bool has_lateraloffset_m() const;
  void clear_lateraloffset_m();
  static const int kLateralOffsetMFieldNumber = 1;
  double lateraloffset_m() const;
  void set_lateraloffset_m(double value);

  // optional .PositionOffset.LateralOffsetSimpleEnum lateralOffsetSimple = 2;
  bool has_lateraloffsetsimple() const;
  void clear_lateraloffsetsimple();
  static const int kLateralOffsetSimpleFieldNumber = 2;
  ::PositionOffset_LateralOffsetSimpleEnum lateraloffsetsimple() const;
  void set_lateraloffsetsimple(::PositionOffset_LateralOffsetSimpleEnum value);

  // optional double longitudinalOffset_m = 3;
  bool has_longitudinaloffset_m() const;
  void clear_longitudinaloffset_m();
  static const int kLongitudinalOffsetMFieldNumber = 3;
  double longitudinaloffset_m() const;
  void set_longitudinaloffset_m(double value);

  // optional .PositionOffset.LongitudinalOffsetSimpleEnum longitudinalOffsetSimple = 4;
  bool has_longitudinaloffsetsimple() const;
  void clear_longitudinaloffsetsimple();
  static const int kLongitudinalOffsetSimpleFieldNumber = 4;
  ::PositionOffset_LongitudinalOffsetSimpleEnum longitudinaloffsetsimple() const;
  void set_longitudinaloffsetsimple(::PositionOffset_LongitudinalOffsetSimpleEnum value);

  // optional double verticalOffset_m = 5;
  bool has_verticaloffset_m() const;
  void clear_verticaloffset_m();
  static const int kVerticalOffsetMFieldNumber = 5;
  double verticaloffset_m() const;
  void set_verticaloffset_m(double value);

  // optional .PositionOffset.VerticalOffsetSimpleEnum verticalOffsetSimple = 6;
  bool has_verticaloffsetsimple() const;
  void clear_verticaloffsetsimple();
  static const int kVerticalOffsetSimpleFieldNumber = 6;
  ::PositionOffset_VerticalOffsetSimpleEnum verticaloffsetsimple() const;
  void set_verticaloffsetsimple(::PositionOffset_VerticalOffsetSimpleEnum value);

  // optional double lateralOffsetAccuracy_m = 7;
  bool has_lateraloffsetaccuracy_m() const;
  void clear_lateraloffsetaccuracy_m();
  static const int kLateralOffsetAccuracyMFieldNumber = 7;
  double lateraloffsetaccuracy_m() const;
  void set_lateraloffsetaccuracy_m(double value);

  // optional double longitudinalOffsetAccuracy_m = 8;
  bool has_longitudinaloffsetaccuracy_m() const;
  void clear_longitudinaloffsetaccuracy_m();
  static const int kLongitudinalOffsetAccuracyMFieldNumber = 8;
  double longitudinaloffsetaccuracy_m() const;
  void set_longitudinaloffsetaccuracy_m(double value);

  // optional double verticalOffsetAccuracy_m = 9;
  bool has_verticaloffsetaccuracy_m() const;
  void clear_verticaloffsetaccuracy_m();
  static const int kVerticalOffsetAccuracyMFieldNumber = 9;
  double verticaloffsetaccuracy_m() const;
  void set_verticaloffsetaccuracy_m(double value);

  // @@protoc_insertion_point(class_scope:PositionOffset)
 private:
  inline void set_has_lateraloffset_m();
  inline void clear_has_lateraloffset_m();
  inline void set_has_lateraloffsetsimple();
  inline void clear_has_lateraloffsetsimple();
  inline void set_has_longitudinaloffset_m();
  inline void clear_has_longitudinaloffset_m();
  inline void set_has_longitudinaloffsetsimple();
  inline void clear_has_longitudinaloffsetsimple();
  inline void set_has_verticaloffset_m();
  inline void clear_has_verticaloffset_m();
  inline void set_has_verticaloffsetsimple();
  inline void clear_has_verticaloffsetsimple();
  inline void set_has_lateraloffsetaccuracy_m();
  inline void clear_has_lateraloffsetaccuracy_m();
  inline void set_has_longitudinaloffsetaccuracy_m();
  inline void clear_has_longitudinaloffsetaccuracy_m();
  inline void set_has_verticaloffsetaccuracy_m();
  inline void clear_has_verticaloffsetaccuracy_m();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double lateraloffset_m_;
  double longitudinaloffset_m_;
  int lateraloffsetsimple_;
  int longitudinaloffsetsimple_;
  double verticaloffset_m_;
  double lateraloffsetaccuracy_m_;
  double longitudinaloffsetaccuracy_m_;
  double verticaloffsetaccuracy_m_;
  int verticaloffsetsimple_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static PositionOffset* default_instance_;
};
// -------------------------------------------------------------------

class RoadSignRestriction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoadSignRestriction) */ {
 public:
  RoadSignRestriction();
  virtual ~RoadSignRestriction();

  RoadSignRestriction(const RoadSignRestriction& from);

  inline RoadSignRestriction& operator=(const RoadSignRestriction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadSignRestriction& default_instance();

  void Swap(RoadSignRestriction* other);

  // implements Message ----------------------------------------------

  inline RoadSignRestriction* New() const { return New(NULL); }

  RoadSignRestriction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoadSignRestriction& from);
  void MergeFrom(const RoadSignRestriction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoadSignRestriction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoadSignRestriction_RestrictionType RestrictionType;
  static const RestrictionType RAIN =
    RoadSignRestriction_RestrictionType_RAIN;
  static const RestrictionType SNOW =
    RoadSignRestriction_RestrictionType_SNOW;
  static const RestrictionType TIME =
    RoadSignRestriction_RestrictionType_TIME;
  static const RestrictionType SEASON =
    RoadSignRestriction_RestrictionType_SEASON;
  static const RestrictionType FOG =
    RoadSignRestriction_RestrictionType_FOG;
  static const RestrictionType SCHOOL =
    RoadSignRestriction_RestrictionType_SCHOOL;
  static const RestrictionType TRUCKS =
    RoadSignRestriction_RestrictionType_TRUCKS;
  static const RestrictionType TRAILER =
    RoadSignRestriction_RestrictionType_TRAILER;
  static const RestrictionType STARTING_IN =
    RoadSignRestriction_RestrictionType_STARTING_IN;
  static const RestrictionType VALID_FOR =
    RoadSignRestriction_RestrictionType_VALID_FOR;
  static const RestrictionType IN_RIGHT_DIRECTION =
    RoadSignRestriction_RestrictionType_IN_RIGHT_DIRECTION;
  static const RestrictionType IN_LEFT_DIRECTION =
    RoadSignRestriction_RestrictionType_IN_LEFT_DIRECTION;
  static const RestrictionType ZONE =
    RoadSignRestriction_RestrictionType_ZONE;
  static const RestrictionType ANY_PICTURE =
    RoadSignRestriction_RestrictionType_ANY_PICTURE;
  static const RestrictionType ANY_TEXT =
    RoadSignRestriction_RestrictionType_ANY_TEXT;
  static const RestrictionType ANY_RESTRICTION =
    RoadSignRestriction_RestrictionType_ANY_RESTRICTION;
  static const RestrictionType GARBAGE =
    RoadSignRestriction_RestrictionType_GARBAGE;
  static const RestrictionType NIGHT =
    RoadSignRestriction_RestrictionType_NIGHT;
  static const RestrictionType WORKDAYS =
    RoadSignRestriction_RestrictionType_WORKDAYS;
  static const RestrictionType WORKDAYS_AND_TIME =
    RoadSignRestriction_RestrictionType_WORKDAYS_AND_TIME;
  static const RestrictionType MON2FRI_AND_TIME =
    RoadSignRestriction_RestrictionType_MON2FRI_AND_TIME;
  static const RestrictionType MOTORCYCLE =
    RoadSignRestriction_RestrictionType_MOTORCYCLE;
  static const RestrictionType PASSENGER_CAR_TRAILER =
    RoadSignRestriction_RestrictionType_PASSENGER_CAR_TRAILER;
  static const RestrictionType TRACTORS_MAY_BE_PASSED =
    RoadSignRestriction_RestrictionType_TRACTORS_MAY_BE_PASSED;
  static const RestrictionType TRUCK_BUS_CAR_TRAILER =
    RoadSignRestriction_RestrictionType_TRUCK_BUS_CAR_TRAILER;
  static const RestrictionType WEIGHT =
    RoadSignRestriction_RestrictionType_WEIGHT;
  static const RestrictionType WET =
    RoadSignRestriction_RestrictionType_WET;
  static const RestrictionType ICY =
    RoadSignRestriction_RestrictionType_ICY;
  static const RestrictionType X_WAY =
    RoadSignRestriction_RestrictionType_X_WAY;
  static const RestrictionType PASSENGER_CAR =
    RoadSignRestriction_RestrictionType_PASSENGER_CAR;
  static const RestrictionType UNKNOWN_RESTRICTION =
    RoadSignRestriction_RestrictionType_UNKNOWN_RESTRICTION;
  static inline bool RestrictionType_IsValid(int value) {
    return RoadSignRestriction_RestrictionType_IsValid(value);
  }
  static const RestrictionType RestrictionType_MIN =
    RoadSignRestriction_RestrictionType_RestrictionType_MIN;
  static const RestrictionType RestrictionType_MAX =
    RoadSignRestriction_RestrictionType_RestrictionType_MAX;
  static const int RestrictionType_ARRAYSIZE =
    RoadSignRestriction_RestrictionType_RestrictionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RestrictionType_descriptor() {
    return RoadSignRestriction_RestrictionType_descriptor();
  }
  static inline const ::std::string& RestrictionType_Name(RestrictionType value) {
    return RoadSignRestriction_RestrictionType_Name(value);
  }
  static inline bool RestrictionType_Parse(const ::std::string& name,
      RestrictionType* value) {
    return RoadSignRestriction_RestrictionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .RoadSignRestriction.RestrictionType restrictionType = 1;
  bool has_restrictiontype() const;
  void clear_restrictiontype();
  static const int kRestrictionTypeFieldNumber = 1;
  ::RoadSignRestriction_RestrictionType restrictiontype() const;
  void set_restrictiontype(::RoadSignRestriction_RestrictionType value);

  // optional string restrictionValue = 2;
  bool has_restrictionvalue() const;
  void clear_restrictionvalue();
  static const int kRestrictionValueFieldNumber = 2;
  const ::std::string& restrictionvalue() const;
  void set_restrictionvalue(const ::std::string& value);
  void set_restrictionvalue(const char* value);
  void set_restrictionvalue(const char* value, size_t size);
  ::std::string* mutable_restrictionvalue();
  ::std::string* release_restrictionvalue();
  void set_allocated_restrictionvalue(::std::string* restrictionvalue);

  // optional uint32 restrictionConfidence_percent = 3;
  bool has_restrictionconfidence_percent() const;
  void clear_restrictionconfidence_percent();
  static const int kRestrictionConfidencePercentFieldNumber = 3;
  ::google::protobuf::uint32 restrictionconfidence_percent() const;
  void set_restrictionconfidence_percent(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RoadSignRestriction)
 private:
  inline void set_has_restrictiontype();
  inline void clear_has_restrictiontype();
  inline void set_has_restrictionvalue();
  inline void clear_has_restrictionvalue();
  inline void set_has_restrictionconfidence_percent();
  inline void clear_has_restrictionconfidence_percent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr restrictionvalue_;
  int restrictiontype_;
  ::google::protobuf::uint32 restrictionconfidence_percent_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static RoadSignRestriction* default_instance_;
};
// -------------------------------------------------------------------

class SignRecognition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SignRecognition) */ {
 public:
  SignRecognition();
  virtual ~SignRecognition();

  SignRecognition(const SignRecognition& from);

  inline SignRecognition& operator=(const SignRecognition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignRecognition& default_instance();

  void Swap(SignRecognition* other);

  // implements Message ----------------------------------------------

  inline SignRecognition* New() const { return New(NULL); }

  SignRecognition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignRecognition& from);
  void MergeFrom(const SignRecognition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignRecognition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SignRecognition_RoadSignTypeEnum RoadSignTypeEnum;
  static const RoadSignTypeEnum SPEED_LIMIT_START =
    SignRecognition_RoadSignTypeEnum_SPEED_LIMIT_START;
  static const RoadSignTypeEnum SPEED_LIMIT_END =
    SignRecognition_RoadSignTypeEnum_SPEED_LIMIT_END;
  static const RoadSignTypeEnum NO_OVERTAKING_PASSENGER_CARS_START =
    SignRecognition_RoadSignTypeEnum_NO_OVERTAKING_PASSENGER_CARS_START;
  static const RoadSignTypeEnum NO_OVERTAKING_PASSENGER_CARS_END =
    SignRecognition_RoadSignTypeEnum_NO_OVERTAKING_PASSENGER_CARS_END;
  static const RoadSignTypeEnum NO_OVERTAKING_TRUCKS_START =
    SignRecognition_RoadSignTypeEnum_NO_OVERTAKING_TRUCKS_START;
  static const RoadSignTypeEnum NO_OVERTAKING_TRUCKS_END =
    SignRecognition_RoadSignTypeEnum_NO_OVERTAKING_TRUCKS_END;
  static const RoadSignTypeEnum ALL_RESTRICTIONS_END =
    SignRecognition_RoadSignTypeEnum_ALL_RESTRICTIONS_END;
  static const RoadSignTypeEnum CITY_START =
    SignRecognition_RoadSignTypeEnum_CITY_START;
  static const RoadSignTypeEnum CITY_END =
    SignRecognition_RoadSignTypeEnum_CITY_END;
  static const RoadSignTypeEnum MOTORWAY_START =
    SignRecognition_RoadSignTypeEnum_MOTORWAY_START;
  static const RoadSignTypeEnum MOTORWAY_END =
    SignRecognition_RoadSignTypeEnum_MOTORWAY_END;
  static const RoadSignTypeEnum CONSTRUCTION_START =
    SignRecognition_RoadSignTypeEnum_CONSTRUCTION_START;
  static const RoadSignTypeEnum CONSTRUCTION_END =
    SignRecognition_RoadSignTypeEnum_CONSTRUCTION_END;
  static const RoadSignTypeEnum PROTECTED_OVERTAKING_EXTRALANE =
    SignRecognition_RoadSignTypeEnum_PROTECTED_OVERTAKING_EXTRALANE;
  static const RoadSignTypeEnum PROTECTED_OVERTAKING_EXTRALANE_RIGHTSIDE =
    SignRecognition_RoadSignTypeEnum_PROTECTED_OVERTAKING_EXTRALANE_RIGHTSIDE;
  static const RoadSignTypeEnum PROTECTED_OVERTAKING_EXTRALANE_LEFTSIDE =
    SignRecognition_RoadSignTypeEnum_PROTECTED_OVERTAKING_EXTRALANE_LEFTSIDE;
  static const RoadSignTypeEnum LANE_MERGE_RIGHT =
    SignRecognition_RoadSignTypeEnum_LANE_MERGE_RIGHT;
  static const RoadSignTypeEnum LANE_MERGE_LEFT =
    SignRecognition_RoadSignTypeEnum_LANE_MERGE_LEFT;
  static const RoadSignTypeEnum LANE_MERGE_CENTER =
    SignRecognition_RoadSignTypeEnum_LANE_MERGE_CENTER;
  static const RoadSignTypeEnum RAILWAY_CROSSING_PROTECTED =
    SignRecognition_RoadSignTypeEnum_RAILWAY_CROSSING_PROTECTED;
  static const RoadSignTypeEnum RAILWAY_CROSSING_UNPROTECTED =
    SignRecognition_RoadSignTypeEnum_RAILWAY_CROSSING_UNPROTECTED;
  static const RoadSignTypeEnum ROAD_NARROWS =
    SignRecognition_RoadSignTypeEnum_ROAD_NARROWS;
  static const RoadSignTypeEnum SHARP_CURVE =
    SignRecognition_RoadSignTypeEnum_SHARP_CURVE;
  static const RoadSignTypeEnum SHARP_CURVE_LEFT =
    SignRecognition_RoadSignTypeEnum_SHARP_CURVE_LEFT;
  static const RoadSignTypeEnum SHARP_CURVE_RIGHT =
    SignRecognition_RoadSignTypeEnum_SHARP_CURVE_RIGHT;
  static const RoadSignTypeEnum WINDING_ROAD_STARTING_LEFT =
    SignRecognition_RoadSignTypeEnum_WINDING_ROAD_STARTING_LEFT;
  static const RoadSignTypeEnum WINDING_ROAD_STARTING_RIGHT =
    SignRecognition_RoadSignTypeEnum_WINDING_ROAD_STARTING_RIGHT;
  static const RoadSignTypeEnum STEEP_HILL =
    SignRecognition_RoadSignTypeEnum_STEEP_HILL;
  static const RoadSignTypeEnum STEEP_HILL_UPWARDS =
    SignRecognition_RoadSignTypeEnum_STEEP_HILL_UPWARDS;
  static const RoadSignTypeEnum STEEP_HILL_DOWNWARDS =
    SignRecognition_RoadSignTypeEnum_STEEP_HILL_DOWNWARDS;
  static const RoadSignTypeEnum STOP_SIGN =
    SignRecognition_RoadSignTypeEnum_STOP_SIGN;
  static const RoadSignTypeEnum LATERAL_WIND =
    SignRecognition_RoadSignTypeEnum_LATERAL_WIND;
  static const RoadSignTypeEnum GENERAL_WARNING =
    SignRecognition_RoadSignTypeEnum_GENERAL_WARNING;
  static const RoadSignTypeEnum RISK_OF_GROUNDING =
    SignRecognition_RoadSignTypeEnum_RISK_OF_GROUNDING;
  static const RoadSignTypeEnum ANIMAL_CROSSING =
    SignRecognition_RoadSignTypeEnum_ANIMAL_CROSSING;
  static const RoadSignTypeEnum ICY_CONDITIONS =
    SignRecognition_RoadSignTypeEnum_ICY_CONDITIONS;
  static const RoadSignTypeEnum SLIPPERY_ROAD =
    SignRecognition_RoadSignTypeEnum_SLIPPERY_ROAD;
  static const RoadSignTypeEnum FALLING_ROCKS =
    SignRecognition_RoadSignTypeEnum_FALLING_ROCKS;
  static const RoadSignTypeEnum SCHOOL_ZONE =
    SignRecognition_RoadSignTypeEnum_SCHOOL_ZONE;
  static const RoadSignTypeEnum TRAMWAY_CROSSING =
    SignRecognition_RoadSignTypeEnum_TRAMWAY_CROSSING;
  static const RoadSignTypeEnum CONGESTION_HAZARD =
    SignRecognition_RoadSignTypeEnum_CONGESTION_HAZARD;
  static const RoadSignTypeEnum ACCIDENT_HAZARD =
    SignRecognition_RoadSignTypeEnum_ACCIDENT_HAZARD;
  static const RoadSignTypeEnum PRIORITY_OVER_ONCOMING_TRAFFIC =
    SignRecognition_RoadSignTypeEnum_PRIORITY_OVER_ONCOMING_TRAFFIC;
  static const RoadSignTypeEnum YIELD_TO_ONCOMING_TRAFFIC =
    SignRecognition_RoadSignTypeEnum_YIELD_TO_ONCOMING_TRAFFIC;
  static const RoadSignTypeEnum PREFERENCE_ROAD_START =
    SignRecognition_RoadSignTypeEnum_PREFERENCE_ROAD_START;
  static const RoadSignTypeEnum PREFERENCE_ROAD_END =
    SignRecognition_RoadSignTypeEnum_PREFERENCE_ROAD_END;
  static const RoadSignTypeEnum ENVIRONMENTAL_ZONE_START =
    SignRecognition_RoadSignTypeEnum_ENVIRONMENTAL_ZONE_START;
  static const RoadSignTypeEnum ENVIRONMENTAL_ZONE_END =
    SignRecognition_RoadSignTypeEnum_ENVIRONMENTAL_ZONE_END;
  static const RoadSignTypeEnum RESIDENTIAL_AREA_START =
    SignRecognition_RoadSignTypeEnum_RESIDENTIAL_AREA_START;
  static const RoadSignTypeEnum RESIDENTIAL_AREA_END =
    SignRecognition_RoadSignTypeEnum_RESIDENTIAL_AREA_END;
  static const RoadSignTypeEnum HIGHWAY_START =
    SignRecognition_RoadSignTypeEnum_HIGHWAY_START;
  static const RoadSignTypeEnum HIGHWAY_END =
    SignRecognition_RoadSignTypeEnum_HIGHWAY_END;
  static const RoadSignTypeEnum ZONE_START =
    SignRecognition_RoadSignTypeEnum_ZONE_START;
  static const RoadSignTypeEnum ZONE_END =
    SignRecognition_RoadSignTypeEnum_ZONE_END;
  static const RoadSignTypeEnum ROUNDABOUT =
    SignRecognition_RoadSignTypeEnum_ROUNDABOUT;
  static const RoadSignTypeEnum PASS_THIS_SIDE_RIGHT =
    SignRecognition_RoadSignTypeEnum_PASS_THIS_SIDE_RIGHT;
  static const RoadSignTypeEnum PASS_THIS_SIDE_LEFT =
    SignRecognition_RoadSignTypeEnum_PASS_THIS_SIDE_LEFT;
  static const RoadSignTypeEnum NO_ENTRY =
    SignRecognition_RoadSignTypeEnum_NO_ENTRY;
  static const RoadSignTypeEnum ENVIRONMENTAL_ZONE_GREEN_START =
    SignRecognition_RoadSignTypeEnum_ENVIRONMENTAL_ZONE_GREEN_START;
  static const RoadSignTypeEnum UNEVEN_ROAD =
    SignRecognition_RoadSignTypeEnum_UNEVEN_ROAD;
  static const RoadSignTypeEnum GENERAL_PRIORITIES_RULE =
    SignRecognition_RoadSignTypeEnum_GENERAL_PRIORITIES_RULE;
  static const RoadSignTypeEnum DANGER_NARROW_ROAD =
    SignRecognition_RoadSignTypeEnum_DANGER_NARROW_ROAD;
  static const RoadSignTypeEnum DANGER_CHILDREN =
    SignRecognition_RoadSignTypeEnum_DANGER_CHILDREN;
  static const RoadSignTypeEnum DANGER_PEDESTRIANS =
    SignRecognition_RoadSignTypeEnum_DANGER_PEDESTRIANS;
  static const RoadSignTypeEnum DANGER_CYCLIST =
    SignRecognition_RoadSignTypeEnum_DANGER_CYCLIST;
  static const RoadSignTypeEnum ROAD_NARROWS_LEFT =
    SignRecognition_RoadSignTypeEnum_ROAD_NARROWS_LEFT;
  static const RoadSignTypeEnum ROAD_NARROWS_RIGHT =
    SignRecognition_RoadSignTypeEnum_ROAD_NARROWS_RIGHT;
  static const RoadSignTypeEnum GRAVEL =
    SignRecognition_RoadSignTypeEnum_GRAVEL;
  static const RoadSignTypeEnum CONTRAFLOW_TRAFFIC =
    SignRecognition_RoadSignTypeEnum_CONTRAFLOW_TRAFFIC;
  static const RoadSignTypeEnum DRAWBRIDGE =
    SignRecognition_RoadSignTypeEnum_DRAWBRIDGE;
  static const RoadSignTypeEnum QUAYWALL =
    SignRecognition_RoadSignTypeEnum_QUAYWALL;
  static const RoadSignTypeEnum TRAFFICLIGHT =
    SignRecognition_RoadSignTypeEnum_TRAFFICLIGHT;
  static const RoadSignTypeEnum ZEBRA_CROSSING_HAZARD =
    SignRecognition_RoadSignTypeEnum_ZEBRA_CROSSING_HAZARD;
  static const RoadSignTypeEnum CATTLE_CROSSING =
    SignRecognition_RoadSignTypeEnum_CATTLE_CROSSING;
  static const RoadSignTypeEnum PLANES_CROSSING =
    SignRecognition_RoadSignTypeEnum_PLANES_CROSSING;
  static const RoadSignTypeEnum BUS_CROSSING =
    SignRecognition_RoadSignTypeEnum_BUS_CROSSING;
  static const RoadSignTypeEnum PRECEDENCE_FOR_CONTRAFLOW_TRAFFIC =
    SignRecognition_RoadSignTypeEnum_PRECEDENCE_FOR_CONTRAFLOW_TRAFFIC;
  static const RoadSignTypeEnum TURN_LEFT =
    SignRecognition_RoadSignTypeEnum_TURN_LEFT;
  static const RoadSignTypeEnum TURN_RIGHT =
    SignRecognition_RoadSignTypeEnum_TURN_RIGHT;
  static const RoadSignTypeEnum NO_TURN =
    SignRecognition_RoadSignTypeEnum_NO_TURN;
  static const RoadSignTypeEnum TURN_LEFT_OR_RIGHT =
    SignRecognition_RoadSignTypeEnum_TURN_LEFT_OR_RIGHT;
  static const RoadSignTypeEnum DRIVE_LEFT =
    SignRecognition_RoadSignTypeEnum_DRIVE_LEFT;
  static const RoadSignTypeEnum DRIVE_RIGHT =
    SignRecognition_RoadSignTypeEnum_DRIVE_RIGHT;
  static const RoadSignTypeEnum NO_TURN_RIGHT =
    SignRecognition_RoadSignTypeEnum_NO_TURN_RIGHT;
  static const RoadSignTypeEnum NO_TURN_LEFT =
    SignRecognition_RoadSignTypeEnum_NO_TURN_LEFT;
  static const RoadSignTypeEnum ONEWAY_LEFT =
    SignRecognition_RoadSignTypeEnum_ONEWAY_LEFT;
  static const RoadSignTypeEnum ONEWAY_RIGHT =
    SignRecognition_RoadSignTypeEnum_ONEWAY_RIGHT;
  static const RoadSignTypeEnum BUSSTOP =
    SignRecognition_RoadSignTypeEnum_BUSSTOP;
  static const RoadSignTypeEnum BICYCLE_LANE =
    SignRecognition_RoadSignTypeEnum_BICYCLE_LANE;
  static const RoadSignTypeEnum HORSERIDING_LANE =
    SignRecognition_RoadSignTypeEnum_HORSERIDING_LANE;
  static const RoadSignTypeEnum PEDESTRIAN_LANE =
    SignRecognition_RoadSignTypeEnum_PEDESTRIAN_LANE;
  static const RoadSignTypeEnum PEDESTRIAN_AND_BICYCLE_LANE =
    SignRecognition_RoadSignTypeEnum_PEDESTRIAN_AND_BICYCLE_LANE;
  static const RoadSignTypeEnum BICYCLE_BESIDES_PEDESTRIAN_LANE =
    SignRecognition_RoadSignTypeEnum_BICYCLE_BESIDES_PEDESTRIAN_LANE;
  static const RoadSignTypeEnum PEDESTRIAN_BESIDES_BICYCLE_LANE =
    SignRecognition_RoadSignTypeEnum_PEDESTRIAN_BESIDES_BICYCLE_LANE;
  static const RoadSignTypeEnum PEDESTRIAN_ZONE_START =
    SignRecognition_RoadSignTypeEnum_PEDESTRIAN_ZONE_START;
  static const RoadSignTypeEnum PEDESTRIAN_ZONE_END =
    SignRecognition_RoadSignTypeEnum_PEDESTRIAN_ZONE_END;
  static const RoadSignTypeEnum BICYCLE_ZONE_START =
    SignRecognition_RoadSignTypeEnum_BICYCLE_ZONE_START;
  static const RoadSignTypeEnum BICYCLE_ZONE_END =
    SignRecognition_RoadSignTypeEnum_BICYCLE_ZONE_END;
  static const RoadSignTypeEnum NO_PARKING_ZONE_START =
    SignRecognition_RoadSignTypeEnum_NO_PARKING_ZONE_START;
  static const RoadSignTypeEnum NO_PARKING_ZONE_END =
    SignRecognition_RoadSignTypeEnum_NO_PARKING_ZONE_END;
  static const RoadSignTypeEnum BUS_LANE =
    SignRecognition_RoadSignTypeEnum_BUS_LANE;
  static const RoadSignTypeEnum NO_MOTORVEHICLES =
    SignRecognition_RoadSignTypeEnum_NO_MOTORVEHICLES;
  static const RoadSignTypeEnum NO_TRUCKS =
    SignRecognition_RoadSignTypeEnum_NO_TRUCKS;
  static const RoadSignTypeEnum NO_BICYCLE =
    SignRecognition_RoadSignTypeEnum_NO_BICYCLE;
  static const RoadSignTypeEnum NO_MOTORCYCLE =
    SignRecognition_RoadSignTypeEnum_NO_MOTORCYCLE;
  static const RoadSignTypeEnum NO_SCOOTER =
    SignRecognition_RoadSignTypeEnum_NO_SCOOTER;
  static const RoadSignTypeEnum NO_HORSERIDING =
    SignRecognition_RoadSignTypeEnum_NO_HORSERIDING;
  static const RoadSignTypeEnum NO_PEDESTRIANS =
    SignRecognition_RoadSignTypeEnum_NO_PEDESTRIANS;
  static const RoadSignTypeEnum NO_MOTORVEHICLES_AND_MOTORCYCLE =
    SignRecognition_RoadSignTypeEnum_NO_MOTORVEHICLES_AND_MOTORCYCLE;
  static const RoadSignTypeEnum NO_DANGEROUSGOODS =
    SignRecognition_RoadSignTypeEnum_NO_DANGEROUSGOODS;
  static const RoadSignTypeEnum RESTRICTED_WEIGHT =
    SignRecognition_RoadSignTypeEnum_RESTRICTED_WEIGHT;
  static const RoadSignTypeEnum RESTRICTED_AXLE_WEIGHT =
    SignRecognition_RoadSignTypeEnum_RESTRICTED_AXLE_WEIGHT;
  static const RoadSignTypeEnum RESTRICTED_WIDTH =
    SignRecognition_RoadSignTypeEnum_RESTRICTED_WIDTH;
  static const RoadSignTypeEnum RESTRICTED_HEIGHT =
    SignRecognition_RoadSignTypeEnum_RESTRICTED_HEIGHT;
  static const RoadSignTypeEnum RESTRICTED_LENGTH =
    SignRecognition_RoadSignTypeEnum_RESTRICTED_LENGTH;
  static const RoadSignTypeEnum SNOW_CHAINS_MANDATORY =
    SignRecognition_RoadSignTypeEnum_SNOW_CHAINS_MANDATORY;
  static const RoadSignTypeEnum NO_WATER_HAZARDOUS_GOODS =
    SignRecognition_RoadSignTypeEnum_NO_WATER_HAZARDOUS_GOODS;
  static const RoadSignTypeEnum NO_UTURN =
    SignRecognition_RoadSignTypeEnum_NO_UTURN;
  static const RoadSignTypeEnum PROHIBITED_MINIMUM_GAP_DECEED =
    SignRecognition_RoadSignTypeEnum_PROHIBITED_MINIMUM_GAP_DECEED;
  static const RoadSignTypeEnum MANDATORY_MINIMUM_SPEED_START =
    SignRecognition_RoadSignTypeEnum_MANDATORY_MINIMUM_SPEED_START;
  static const RoadSignTypeEnum MANDATORY_MINIMUM_SPEED_END =
    SignRecognition_RoadSignTypeEnum_MANDATORY_MINIMUM_SPEED_END;
  static const RoadSignTypeEnum NO_STOPPING_TO_LEFT =
    SignRecognition_RoadSignTypeEnum_NO_STOPPING_TO_LEFT;
  static const RoadSignTypeEnum NO_STOPPING_TO_RIGHT =
    SignRecognition_RoadSignTypeEnum_NO_STOPPING_TO_RIGHT;
  static const RoadSignTypeEnum NO_STOPPING_TO_BOTH =
    SignRecognition_RoadSignTypeEnum_NO_STOPPING_TO_BOTH;
  static const RoadSignTypeEnum NO_STOPPING =
    SignRecognition_RoadSignTypeEnum_NO_STOPPING;
  static const RoadSignTypeEnum NO_PARKING_TO_LEFT =
    SignRecognition_RoadSignTypeEnum_NO_PARKING_TO_LEFT;
  static const RoadSignTypeEnum NO_PARKING_TO_RIGHT =
    SignRecognition_RoadSignTypeEnum_NO_PARKING_TO_RIGHT;
  static const RoadSignTypeEnum NO_PARKING_TO_BOTH =
    SignRecognition_RoadSignTypeEnum_NO_PARKING_TO_BOTH;
  static const RoadSignTypeEnum NO_PARKING =
    SignRecognition_RoadSignTypeEnum_NO_PARKING;
  static const RoadSignTypeEnum PRIORITY_OVER_CONTRAFLOW_TRAFFIC =
    SignRecognition_RoadSignTypeEnum_PRIORITY_OVER_CONTRAFLOW_TRAFFIC;
  static const RoadSignTypeEnum ZEBRA_CROSSING =
    SignRecognition_RoadSignTypeEnum_ZEBRA_CROSSING;
  static const RoadSignTypeEnum HAF_RIGHT =
    SignRecognition_RoadSignTypeEnum_HAF_RIGHT;
  static const RoadSignTypeEnum HAF_LEFT =
    SignRecognition_RoadSignTypeEnum_HAF_LEFT;
  static const RoadSignTypeEnum ROADMARK_ARROW_STRAIGHT =
    SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_STRAIGHT;
  static const RoadSignTypeEnum ROADMARK_ARROW_LEFT =
    SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_LEFT;
  static const RoadSignTypeEnum ROADMARK_ARROW_RIGHT =
    SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_RIGHT;
  static const RoadSignTypeEnum ROADMARK_ARROW_STRAIGHTLEFT =
    SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_STRAIGHTLEFT;
  static const RoadSignTypeEnum ROADMARK_ARROW_STRAIGHTRIGHT =
    SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_STRAIGHTRIGHT;
  static const RoadSignTypeEnum ROADMARK_ARROW_LEFTRIGHT =
    SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_LEFTRIGHT;
  static const RoadSignTypeEnum ROADMARK_ARROW_MERGELEFT =
    SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_MERGELEFT;
  static const RoadSignTypeEnum ROADMARK_ARROW_MERGERIGHT =
    SignRecognition_RoadSignTypeEnum_ROADMARK_ARROW_MERGERIGHT;
  static const RoadSignTypeEnum UNKNOWN_SIGN =
    SignRecognition_RoadSignTypeEnum_UNKNOWN_SIGN;
  static inline bool RoadSignTypeEnum_IsValid(int value) {
    return SignRecognition_RoadSignTypeEnum_IsValid(value);
  }
  static const RoadSignTypeEnum RoadSignTypeEnum_MIN =
    SignRecognition_RoadSignTypeEnum_RoadSignTypeEnum_MIN;
  static const RoadSignTypeEnum RoadSignTypeEnum_MAX =
    SignRecognition_RoadSignTypeEnum_RoadSignTypeEnum_MAX;
  static const int RoadSignTypeEnum_ARRAYSIZE =
    SignRecognition_RoadSignTypeEnum_RoadSignTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadSignTypeEnum_descriptor() {
    return SignRecognition_RoadSignTypeEnum_descriptor();
  }
  static inline const ::std::string& RoadSignTypeEnum_Name(RoadSignTypeEnum value) {
    return SignRecognition_RoadSignTypeEnum_Name(value);
  }
  static inline bool RoadSignTypeEnum_Parse(const ::std::string& name,
      RoadSignTypeEnum* value) {
    return SignRecognition_RoadSignTypeEnum_Parse(name, value);
  }

  typedef SignRecognition_RoadSignPermanencyEnum RoadSignPermanencyEnum;
  static const RoadSignPermanencyEnum STATIC =
    SignRecognition_RoadSignPermanencyEnum_STATIC;
  static const RoadSignPermanencyEnum VARIABLE =
    SignRecognition_RoadSignPermanencyEnum_VARIABLE;
  static inline bool RoadSignPermanencyEnum_IsValid(int value) {
    return SignRecognition_RoadSignPermanencyEnum_IsValid(value);
  }
  static const RoadSignPermanencyEnum RoadSignPermanencyEnum_MIN =
    SignRecognition_RoadSignPermanencyEnum_RoadSignPermanencyEnum_MIN;
  static const RoadSignPermanencyEnum RoadSignPermanencyEnum_MAX =
    SignRecognition_RoadSignPermanencyEnum_RoadSignPermanencyEnum_MAX;
  static const int RoadSignPermanencyEnum_ARRAYSIZE =
    SignRecognition_RoadSignPermanencyEnum_RoadSignPermanencyEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadSignPermanencyEnum_descriptor() {
    return SignRecognition_RoadSignPermanencyEnum_descriptor();
  }
  static inline const ::std::string& RoadSignPermanencyEnum_Name(RoadSignPermanencyEnum value) {
    return SignRecognition_RoadSignPermanencyEnum_Name(value);
  }
  static inline bool RoadSignPermanencyEnum_Parse(const ::std::string& name,
      RoadSignPermanencyEnum* value) {
    return SignRecognition_RoadSignPermanencyEnum_Parse(name, value);
  }

  typedef SignRecognition_RoadSignDependenciesEnum RoadSignDependenciesEnum;
  static const RoadSignDependenciesEnum RAIN =
    SignRecognition_RoadSignDependenciesEnum_RAIN;
  static const RoadSignDependenciesEnum SNOW =
    SignRecognition_RoadSignDependenciesEnum_SNOW;
  static const RoadSignDependenciesEnum TIME =
    SignRecognition_RoadSignDependenciesEnum_TIME;
  static const RoadSignDependenciesEnum SEASON =
    SignRecognition_RoadSignDependenciesEnum_SEASON;
  static const RoadSignDependenciesEnum FOG =
    SignRecognition_RoadSignDependenciesEnum_FOG;
  static const RoadSignDependenciesEnum SCHOOL =
    SignRecognition_RoadSignDependenciesEnum_SCHOOL;
  static const RoadSignDependenciesEnum TRUCKS =
    SignRecognition_RoadSignDependenciesEnum_TRUCKS;
  static const RoadSignDependenciesEnum TRAILER =
    SignRecognition_RoadSignDependenciesEnum_TRAILER;
  static const RoadSignDependenciesEnum ANY_PICTURE =
    SignRecognition_RoadSignDependenciesEnum_ANY_PICTURE;
  static const RoadSignDependenciesEnum ANY_TEXT =
    SignRecognition_RoadSignDependenciesEnum_ANY_TEXT;
  static const RoadSignDependenciesEnum ANY_RESTRICTION =
    SignRecognition_RoadSignDependenciesEnum_ANY_RESTRICTION;
  static const RoadSignDependenciesEnum GARBAGE =
    SignRecognition_RoadSignDependenciesEnum_GARBAGE;
  static const RoadSignDependenciesEnum NIGHT =
    SignRecognition_RoadSignDependenciesEnum_NIGHT;
  static const RoadSignDependenciesEnum WORKDAYS =
    SignRecognition_RoadSignDependenciesEnum_WORKDAYS;
  static const RoadSignDependenciesEnum WORKDAYS_AND_TIME =
    SignRecognition_RoadSignDependenciesEnum_WORKDAYS_AND_TIME;
  static const RoadSignDependenciesEnum MON2FRI_AND_TIME =
    SignRecognition_RoadSignDependenciesEnum_MON2FRI_AND_TIME;
  static const RoadSignDependenciesEnum MOTORCYCLE =
    SignRecognition_RoadSignDependenciesEnum_MOTORCYCLE;
  static const RoadSignDependenciesEnum PASSENGER_CAR_TRAILER =
    SignRecognition_RoadSignDependenciesEnum_PASSENGER_CAR_TRAILER;
  static const RoadSignDependenciesEnum TRACTORS_MAY_BE_PASSED =
    SignRecognition_RoadSignDependenciesEnum_TRACTORS_MAY_BE_PASSED;
  static const RoadSignDependenciesEnum TRUCK_BUS_CAR_TRAILER =
    SignRecognition_RoadSignDependenciesEnum_TRUCK_BUS_CAR_TRAILER;
  static const RoadSignDependenciesEnum WEIGHT =
    SignRecognition_RoadSignDependenciesEnum_WEIGHT;
  static const RoadSignDependenciesEnum WET =
    SignRecognition_RoadSignDependenciesEnum_WET;
  static const RoadSignDependenciesEnum ICY =
    SignRecognition_RoadSignDependenciesEnum_ICY;
  static const RoadSignDependenciesEnum X_WAY =
    SignRecognition_RoadSignDependenciesEnum_X_WAY;
  static const RoadSignDependenciesEnum PASSENGER_CAR =
    SignRecognition_RoadSignDependenciesEnum_PASSENGER_CAR;
  static const RoadSignDependenciesEnum UNKNOWN_DEPENDENCY =
    SignRecognition_RoadSignDependenciesEnum_UNKNOWN_DEPENDENCY;
  static inline bool RoadSignDependenciesEnum_IsValid(int value) {
    return SignRecognition_RoadSignDependenciesEnum_IsValid(value);
  }
  static const RoadSignDependenciesEnum RoadSignDependenciesEnum_MIN =
    SignRecognition_RoadSignDependenciesEnum_RoadSignDependenciesEnum_MIN;
  static const RoadSignDependenciesEnum RoadSignDependenciesEnum_MAX =
    SignRecognition_RoadSignDependenciesEnum_RoadSignDependenciesEnum_MAX;
  static const int RoadSignDependenciesEnum_ARRAYSIZE =
    SignRecognition_RoadSignDependenciesEnum_RoadSignDependenciesEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadSignDependenciesEnum_descriptor() {
    return SignRecognition_RoadSignDependenciesEnum_descriptor();
  }
  static inline const ::std::string& RoadSignDependenciesEnum_Name(RoadSignDependenciesEnum value) {
    return SignRecognition_RoadSignDependenciesEnum_Name(value);
  }
  static inline bool RoadSignDependenciesEnum_Parse(const ::std::string& name,
      RoadSignDependenciesEnum* value) {
    return SignRecognition_RoadSignDependenciesEnum_Parse(name, value);
  }

  typedef SignRecognition_RoadSignValidityEnum RoadSignValidityEnum;
  static const RoadSignValidityEnum STARTING_IN =
    SignRecognition_RoadSignValidityEnum_STARTING_IN;
  static const RoadSignValidityEnum VALID_FOR =
    SignRecognition_RoadSignValidityEnum_VALID_FOR;
  static const RoadSignValidityEnum IN_RIGHT_DIRECTION =
    SignRecognition_RoadSignValidityEnum_IN_RIGHT_DIRECTION;
  static const RoadSignValidityEnum IN_LEFT_DIRECTION =
    SignRecognition_RoadSignValidityEnum_IN_LEFT_DIRECTION;
  static const RoadSignValidityEnum ZONE =
    SignRecognition_RoadSignValidityEnum_ZONE;
  static const RoadSignValidityEnum UNKNOWN_VALIDITY =
    SignRecognition_RoadSignValidityEnum_UNKNOWN_VALIDITY;
  static inline bool RoadSignValidityEnum_IsValid(int value) {
    return SignRecognition_RoadSignValidityEnum_IsValid(value);
  }
  static const RoadSignValidityEnum RoadSignValidityEnum_MIN =
    SignRecognition_RoadSignValidityEnum_RoadSignValidityEnum_MIN;
  static const RoadSignValidityEnum RoadSignValidityEnum_MAX =
    SignRecognition_RoadSignValidityEnum_RoadSignValidityEnum_MAX;
  static const int RoadSignValidityEnum_ARRAYSIZE =
    SignRecognition_RoadSignValidityEnum_RoadSignValidityEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadSignValidityEnum_descriptor() {
    return SignRecognition_RoadSignValidityEnum_descriptor();
  }
  static inline const ::std::string& RoadSignValidityEnum_Name(RoadSignValidityEnum value) {
    return SignRecognition_RoadSignValidityEnum_Name(value);
  }
  static inline bool RoadSignValidityEnum_Parse(const ::std::string& name,
      RoadSignValidityEnum* value) {
    return SignRecognition_RoadSignValidityEnum_Parse(name, value);
  }

  typedef SignRecognition_RoadSignRecognitionTypeEnum RoadSignRecognitionTypeEnum;
  static const RoadSignRecognitionTypeEnum SIGN_DETECTED =
    SignRecognition_RoadSignRecognitionTypeEnum_SIGN_DETECTED;
  static const RoadSignRecognitionTypeEnum SIGN_NOT_DETECTED =
    SignRecognition_RoadSignRecognitionTypeEnum_SIGN_NOT_DETECTED;
  static inline bool RoadSignRecognitionTypeEnum_IsValid(int value) {
    return SignRecognition_RoadSignRecognitionTypeEnum_IsValid(value);
  }
  static const RoadSignRecognitionTypeEnum RoadSignRecognitionTypeEnum_MIN =
    SignRecognition_RoadSignRecognitionTypeEnum_RoadSignRecognitionTypeEnum_MIN;
  static const RoadSignRecognitionTypeEnum RoadSignRecognitionTypeEnum_MAX =
    SignRecognition_RoadSignRecognitionTypeEnum_RoadSignRecognitionTypeEnum_MAX;
  static const int RoadSignRecognitionTypeEnum_ARRAYSIZE =
    SignRecognition_RoadSignRecognitionTypeEnum_RoadSignRecognitionTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadSignRecognitionTypeEnum_descriptor() {
    return SignRecognition_RoadSignRecognitionTypeEnum_descriptor();
  }
  static inline const ::std::string& RoadSignRecognitionTypeEnum_Name(RoadSignRecognitionTypeEnum value) {
    return SignRecognition_RoadSignRecognitionTypeEnum_Name(value);
  }
  static inline bool RoadSignRecognitionTypeEnum_Parse(const ::std::string& name,
      RoadSignRecognitionTypeEnum* value) {
    return SignRecognition_RoadSignRecognitionTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // optional .PositionOffset positionOffset = 2;
  bool has_positionoffset() const;
  void clear_positionoffset();
  static const int kPositionOffsetFieldNumber = 2;
  const ::PositionOffset& positionoffset() const;
  ::PositionOffset* mutable_positionoffset();
  ::PositionOffset* release_positionoffset();
  void set_allocated_positionoffset(::PositionOffset* positionoffset);

  // required .SignRecognition.RoadSignTypeEnum roadSignType = 3;
  bool has_roadsigntype() const;
  void clear_roadsigntype();
  static const int kRoadSignTypeFieldNumber = 3;
  ::SignRecognition_RoadSignTypeEnum roadsigntype() const;
  void set_roadsigntype(::SignRecognition_RoadSignTypeEnum value);

  // optional .SignRecognition.RoadSignPermanencyEnum roadSignPermanency = 4;
  bool has_roadsignpermanency() const;
  void clear_roadsignpermanency();
  static const int kRoadSignPermanencyFieldNumber = 4;
  ::SignRecognition_RoadSignPermanencyEnum roadsignpermanency() const;
  void set_roadsignpermanency(::SignRecognition_RoadSignPermanencyEnum value);

  // optional string roadSignValue = 5;
  bool has_roadsignvalue() const;
  void clear_roadsignvalue();
  static const int kRoadSignValueFieldNumber = 5;
  const ::std::string& roadsignvalue() const;
  void set_roadsignvalue(const ::std::string& value);
  void set_roadsignvalue(const char* value);
  void set_roadsignvalue(const char* value, size_t size);
  ::std::string* mutable_roadsignvalue();
  ::std::string* release_roadsignvalue();
  void set_allocated_roadsignvalue(::std::string* roadsignvalue);

  // optional .SignRecognition.RoadSignDependenciesEnum roadSignDependencies = 6;
  bool has_roadsigndependencies() const;
  void clear_roadsigndependencies();
  static const int kRoadSignDependenciesFieldNumber = 6;
  ::SignRecognition_RoadSignDependenciesEnum roadsigndependencies() const;
  void set_roadsigndependencies(::SignRecognition_RoadSignDependenciesEnum value);

  // optional .SignRecognition.RoadSignValidityEnum roadSignValidity = 7;
  bool has_roadsignvalidity() const;
  void clear_roadsignvalidity();
  static const int kRoadSignValidityFieldNumber = 7;
  ::SignRecognition_RoadSignValidityEnum roadsignvalidity() const;
  void set_roadsignvalidity(::SignRecognition_RoadSignValidityEnum value);

  // optional string roadSignValidityValue = 8;
  bool has_roadsignvalidityvalue() const;
  void clear_roadsignvalidityvalue();
  static const int kRoadSignValidityValueFieldNumber = 8;
  const ::std::string& roadsignvalidityvalue() const;
  void set_roadsignvalidityvalue(const ::std::string& value);
  void set_roadsignvalidityvalue(const char* value);
  void set_roadsignvalidityvalue(const char* value, size_t size);
  ::std::string* mutable_roadsignvalidityvalue();
  ::std::string* release_roadsignvalidityvalue();
  void set_allocated_roadsignvalidityvalue(::std::string* roadsignvalidityvalue);

  // optional .SignRecognition.RoadSignRecognitionTypeEnum roadSignRecognitionType = 9;
  bool has_roadsignrecognitiontype() const;
  void clear_roadsignrecognitiontype();
  static const int kRoadSignRecognitionTypeFieldNumber = 9;
  ::SignRecognition_RoadSignRecognitionTypeEnum roadsignrecognitiontype() const;
  void set_roadsignrecognitiontype(::SignRecognition_RoadSignRecognitionTypeEnum value);

  // optional int64 detectedObjectID = 10;
  bool has_detectedobjectid() const;
  void clear_detectedobjectid();
  static const int kDetectedObjectIDFieldNumber = 10;
  ::google::protobuf::int64 detectedobjectid() const;
  void set_detectedobjectid(::google::protobuf::int64 value);

  // optional int64 mediaID = 11;
  bool has_mediaid() const;
  void clear_mediaid();
  static const int kMediaIDFieldNumber = 11;
  ::google::protobuf::int64 mediaid() const;
  void set_mediaid(::google::protobuf::int64 value);

  // optional uint32 roadSignRecognitionConfidence_percent = 12;
  bool has_roadsignrecognitionconfidence_percent() const;
  void clear_roadsignrecognitionconfidence_percent();
  static const int kRoadSignRecognitionConfidencePercentFieldNumber = 12;
  ::google::protobuf::uint32 roadsignrecognitionconfidence_percent() const;
  void set_roadsignrecognitionconfidence_percent(::google::protobuf::uint32 value);

  // repeated .RoadSignRestriction roadSignRestrictions = 1001;
  int roadsignrestrictions_size() const;
  void clear_roadsignrestrictions();
  static const int kRoadSignRestrictionsFieldNumber = 1001;
  const ::RoadSignRestriction& roadsignrestrictions(int index) const;
  ::RoadSignRestriction* mutable_roadsignrestrictions(int index);
  ::RoadSignRestriction* add_roadsignrestrictions();
  ::google::protobuf::RepeatedPtrField< ::RoadSignRestriction >*
      mutable_roadsignrestrictions();
  const ::google::protobuf::RepeatedPtrField< ::RoadSignRestriction >&
      roadsignrestrictions() const;

  // @@protoc_insertion_point(class_scope:SignRecognition)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_positionoffset();
  inline void clear_has_positionoffset();
  inline void set_has_roadsigntype();
  inline void clear_has_roadsigntype();
  inline void set_has_roadsignpermanency();
  inline void clear_has_roadsignpermanency();
  inline void set_has_roadsignvalue();
  inline void clear_has_roadsignvalue();
  inline void set_has_roadsigndependencies();
  inline void clear_has_roadsigndependencies();
  inline void set_has_roadsignvalidity();
  inline void clear_has_roadsignvalidity();
  inline void set_has_roadsignvalidityvalue();
  inline void clear_has_roadsignvalidityvalue();
  inline void set_has_roadsignrecognitiontype();
  inline void clear_has_roadsignrecognitiontype();
  inline void set_has_detectedobjectid();
  inline void clear_has_detectedobjectid();
  inline void set_has_mediaid();
  inline void clear_has_mediaid();
  inline void set_has_roadsignrecognitionconfidence_percent();
  inline void clear_has_roadsignrecognitionconfidence_percent();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  ::PositionOffset* positionoffset_;
  int roadsigntype_;
  int roadsignpermanency_;
  ::google::protobuf::internal::ArenaStringPtr roadsignvalue_;
  int roadsigndependencies_;
  int roadsignvalidity_;
  ::google::protobuf::internal::ArenaStringPtr roadsignvalidityvalue_;
  ::google::protobuf::int64 detectedobjectid_;
  int roadsignrecognitiontype_;
  ::google::protobuf::uint32 roadsignrecognitionconfidence_percent_;
  ::google::protobuf::int64 mediaid_;
  ::google::protobuf::RepeatedPtrField< ::RoadSignRestriction > roadsignrestrictions_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static SignRecognition* default_instance_;
};
// -------------------------------------------------------------------

class LinePoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LinePoint) */ {
 public:
  LinePoint();
  virtual ~LinePoint();

  LinePoint(const LinePoint& from);

  inline LinePoint& operator=(const LinePoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinePoint& default_instance();

  void Swap(LinePoint* other);

  // implements Message ----------------------------------------------

  inline LinePoint* New() const { return New(NULL); }

  LinePoint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinePoint& from);
  void MergeFrom(const LinePoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinePoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LinePoint_LinePointTypeEnum LinePointTypeEnum;
  static const LinePointTypeEnum START =
    LinePoint_LinePointTypeEnum_START;
  static const LinePointTypeEnum END =
    LinePoint_LinePointTypeEnum_END;
  static const LinePointTypeEnum MIDDLE =
    LinePoint_LinePointTypeEnum_MIDDLE;
  static inline bool LinePointTypeEnum_IsValid(int value) {
    return LinePoint_LinePointTypeEnum_IsValid(value);
  }
  static const LinePointTypeEnum LinePointTypeEnum_MIN =
    LinePoint_LinePointTypeEnum_LinePointTypeEnum_MIN;
  static const LinePointTypeEnum LinePointTypeEnum_MAX =
    LinePoint_LinePointTypeEnum_LinePointTypeEnum_MAX;
  static const int LinePointTypeEnum_ARRAYSIZE =
    LinePoint_LinePointTypeEnum_LinePointTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LinePointTypeEnum_descriptor() {
    return LinePoint_LinePointTypeEnum_descriptor();
  }
  static inline const ::std::string& LinePointTypeEnum_Name(LinePointTypeEnum value) {
    return LinePoint_LinePointTypeEnum_Name(value);
  }
  static inline bool LinePointTypeEnum_Parse(const ::std::string& name,
      LinePointTypeEnum* value) {
    return LinePoint_LinePointTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .PositionOffset positionOffset = 1;
  bool has_positionoffset() const;
  void clear_positionoffset();
  static const int kPositionOffsetFieldNumber = 1;
  const ::PositionOffset& positionoffset() const;
  ::PositionOffset* mutable_positionoffset();
  ::PositionOffset* release_positionoffset();
  void set_allocated_positionoffset(::PositionOffset* positionoffset);

  // optional .LinePoint.LinePointTypeEnum linePointType = 2;
  bool has_linepointtype() const;
  void clear_linepointtype();
  static const int kLinePointTypeFieldNumber = 2;
  ::LinePoint_LinePointTypeEnum linepointtype() const;
  void set_linepointtype(::LinePoint_LinePointTypeEnum value);

  // @@protoc_insertion_point(class_scope:LinePoint)
 private:
  inline void set_has_positionoffset();
  inline void clear_has_positionoffset();
  inline void set_has_linepointtype();
  inline void clear_has_linepointtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::PositionOffset* positionoffset_;
  int linepointtype_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static LinePoint* default_instance_;
};
// -------------------------------------------------------------------

class LaneBoundaryRecognition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LaneBoundaryRecognition) */ {
 public:
  LaneBoundaryRecognition();
  virtual ~LaneBoundaryRecognition();

  LaneBoundaryRecognition(const LaneBoundaryRecognition& from);

  inline LaneBoundaryRecognition& operator=(const LaneBoundaryRecognition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundaryRecognition& default_instance();

  void Swap(LaneBoundaryRecognition* other);

  // implements Message ----------------------------------------------

  inline LaneBoundaryRecognition* New() const { return New(NULL); }

  LaneBoundaryRecognition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaneBoundaryRecognition& from);
  void MergeFrom(const LaneBoundaryRecognition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaneBoundaryRecognition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LaneBoundaryRecognition_LaneBoundaryTypeEnum LaneBoundaryTypeEnum;
  static const LaneBoundaryTypeEnum SINGLE_SOLID_PAINT =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_SINGLE_SOLID_PAINT;
  static const LaneBoundaryTypeEnum DOUBLE_SOLID_PAINT =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_DOUBLE_SOLID_PAINT;
  static const LaneBoundaryTypeEnum LONG_DASHED_PAINT =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_LONG_DASHED_PAINT;
  static const LaneBoundaryTypeEnum SHORT_DASHED_PAINT =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_SHORT_DASHED_PAINT;
  static const LaneBoundaryTypeEnum SHADED_AREA_PAINT =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_SHADED_AREA_PAINT;
  static const LaneBoundaryTypeEnum DASHED_BLOCKS =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_DASHED_BLOCKS;
  static const LaneBoundaryTypeEnum DOUBLE_LINE_DASHED_SOLID_PAINT =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_DOUBLE_LINE_DASHED_SOLID_PAINT;
  static const LaneBoundaryTypeEnum DOUBLE_LINE_SOLID_DASHED_PAINT =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_DOUBLE_LINE_SOLID_DASHED_PAINT;
  static const LaneBoundaryTypeEnum PHYSICAL_DIVIDER =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_PHYSICAL_DIVIDER;
  static const LaneBoundaryTypeEnum DOUBLE_DASHED_LINES =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_DOUBLE_DASHED_LINES;
  static inline bool LaneBoundaryTypeEnum_IsValid(int value) {
    return LaneBoundaryRecognition_LaneBoundaryTypeEnum_IsValid(value);
  }
  static const LaneBoundaryTypeEnum LaneBoundaryTypeEnum_MIN =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_LaneBoundaryTypeEnum_MIN;
  static const LaneBoundaryTypeEnum LaneBoundaryTypeEnum_MAX =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_LaneBoundaryTypeEnum_MAX;
  static const int LaneBoundaryTypeEnum_ARRAYSIZE =
    LaneBoundaryRecognition_LaneBoundaryTypeEnum_LaneBoundaryTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneBoundaryTypeEnum_descriptor() {
    return LaneBoundaryRecognition_LaneBoundaryTypeEnum_descriptor();
  }
  static inline const ::std::string& LaneBoundaryTypeEnum_Name(LaneBoundaryTypeEnum value) {
    return LaneBoundaryRecognition_LaneBoundaryTypeEnum_Name(value);
  }
  static inline bool LaneBoundaryTypeEnum_Parse(const ::std::string& name,
      LaneBoundaryTypeEnum* value) {
    return LaneBoundaryRecognition_LaneBoundaryTypeEnum_Parse(name, value);
  }

  typedef LaneBoundaryRecognition_LaneBoundaryColorEnum LaneBoundaryColorEnum;
  static const LaneBoundaryColorEnum WHITE =
    LaneBoundaryRecognition_LaneBoundaryColorEnum_WHITE;
  static const LaneBoundaryColorEnum YELLOW =
    LaneBoundaryRecognition_LaneBoundaryColorEnum_YELLOW;
  static const LaneBoundaryColorEnum BLUE =
    LaneBoundaryRecognition_LaneBoundaryColorEnum_BLUE;
  static inline bool LaneBoundaryColorEnum_IsValid(int value) {
    return LaneBoundaryRecognition_LaneBoundaryColorEnum_IsValid(value);
  }
  static const LaneBoundaryColorEnum LaneBoundaryColorEnum_MIN =
    LaneBoundaryRecognition_LaneBoundaryColorEnum_LaneBoundaryColorEnum_MIN;
  static const LaneBoundaryColorEnum LaneBoundaryColorEnum_MAX =
    LaneBoundaryRecognition_LaneBoundaryColorEnum_LaneBoundaryColorEnum_MAX;
  static const int LaneBoundaryColorEnum_ARRAYSIZE =
    LaneBoundaryRecognition_LaneBoundaryColorEnum_LaneBoundaryColorEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneBoundaryColorEnum_descriptor() {
    return LaneBoundaryRecognition_LaneBoundaryColorEnum_descriptor();
  }
  static inline const ::std::string& LaneBoundaryColorEnum_Name(LaneBoundaryColorEnum value) {
    return LaneBoundaryRecognition_LaneBoundaryColorEnum_Name(value);
  }
  static inline bool LaneBoundaryColorEnum_Parse(const ::std::string& name,
      LaneBoundaryColorEnum* value) {
    return LaneBoundaryRecognition_LaneBoundaryColorEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // required .PositionOffset positionOffset = 2;
  bool has_positionoffset() const;
  void clear_positionoffset();
  static const int kPositionOffsetFieldNumber = 2;
  const ::PositionOffset& positionoffset() const;
  ::PositionOffset* mutable_positionoffset();
  ::PositionOffset* release_positionoffset();
  void set_allocated_positionoffset(::PositionOffset* positionoffset);

  // optional .LaneBoundaryRecognition.LaneBoundaryTypeEnum laneBoundaryType = 3;
  bool has_laneboundarytype() const;
  void clear_laneboundarytype();
  static const int kLaneBoundaryTypeFieldNumber = 3;
  ::LaneBoundaryRecognition_LaneBoundaryTypeEnum laneboundarytype() const;
  void set_laneboundarytype(::LaneBoundaryRecognition_LaneBoundaryTypeEnum value);

  // optional .LaneBoundaryRecognition.LaneBoundaryColorEnum laneBoundaryColor = 4;
  bool has_laneboundarycolor() const;
  void clear_laneboundarycolor();
  static const int kLaneBoundaryColorFieldNumber = 4;
  ::LaneBoundaryRecognition_LaneBoundaryColorEnum laneboundarycolor() const;
  void set_laneboundarycolor(::LaneBoundaryRecognition_LaneBoundaryColorEnum value);

  // optional double curvature_1pm = 5;
  bool has_curvature_1pm() const;
  void clear_curvature_1pm();
  static const int kCurvature1PmFieldNumber = 5;
  double curvature_1pm() const;
  void set_curvature_1pm(double value);

  // optional int32 laneMarkerWidth_mm = 6;
  bool has_lanemarkerwidth_mm() const;
  void clear_lanemarkerwidth_mm();
  static const int kLaneMarkerWidthMmFieldNumber = 6;
  ::google::protobuf::int32 lanemarkerwidth_mm() const;
  void set_lanemarkerwidth_mm(::google::protobuf::int32 value);

  // optional int32 laneMarkerWidthAccuracy_mm = 7;
  bool has_lanemarkerwidthaccuracy_mm() const;
  void clear_lanemarkerwidthaccuracy_mm();
  static const int kLaneMarkerWidthAccuracyMmFieldNumber = 7;
  ::google::protobuf::int32 lanemarkerwidthaccuracy_mm() const;
  void set_lanemarkerwidthaccuracy_mm(::google::protobuf::int32 value);

  // optional double laneDeclination_deg = 8;
  bool has_lanedeclination_deg() const;
  void clear_lanedeclination_deg();
  static const int kLaneDeclinationDegFieldNumber = 8;
  double lanedeclination_deg() const;
  void set_lanedeclination_deg(double value);

  // optional double laneDeclinationAccuracy_deg = 9;
  bool has_lanedeclinationaccuracy_deg() const;
  void clear_lanedeclinationaccuracy_deg();
  static const int kLaneDeclinationAccuracyDegFieldNumber = 9;
  double lanedeclinationaccuracy_deg() const;
  void set_lanedeclinationaccuracy_deg(double value);

  // optional int32 laneBoundaryTypeConfidence_percent = 10;
  bool has_laneboundarytypeconfidence_percent() const;
  void clear_laneboundarytypeconfidence_percent();
  static const int kLaneBoundaryTypeConfidencePercentFieldNumber = 10;
  ::google::protobuf::int32 laneboundarytypeconfidence_percent() const;
  void set_laneboundarytypeconfidence_percent(::google::protobuf::int32 value);

  // repeated .LinePoint linePoint = 1000;
  int linepoint_size() const;
  void clear_linepoint();
  static const int kLinePointFieldNumber = 1000;
  const ::LinePoint& linepoint(int index) const;
  ::LinePoint* mutable_linepoint(int index);
  ::LinePoint* add_linepoint();
  ::google::protobuf::RepeatedPtrField< ::LinePoint >*
      mutable_linepoint();
  const ::google::protobuf::RepeatedPtrField< ::LinePoint >&
      linepoint() const;

  // optional .Vector3D LM_Orientation = 1001;
  bool has_lm_orientation() const;
  void clear_lm_orientation();
  static const int kLMOrientationFieldNumber = 1001;
  const ::Vector3D& lm_orientation() const;
  ::Vector3D* mutable_lm_orientation();
  ::Vector3D* release_lm_orientation();
  void set_allocated_lm_orientation(::Vector3D* lm_orientation);

  // @@protoc_insertion_point(class_scope:LaneBoundaryRecognition)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_positionoffset();
  inline void clear_has_positionoffset();
  inline void set_has_laneboundarytype();
  inline void clear_has_laneboundarytype();
  inline void set_has_laneboundarycolor();
  inline void clear_has_laneboundarycolor();
  inline void set_has_curvature_1pm();
  inline void clear_has_curvature_1pm();
  inline void set_has_lanemarkerwidth_mm();
  inline void clear_has_lanemarkerwidth_mm();
  inline void set_has_lanemarkerwidthaccuracy_mm();
  inline void clear_has_lanemarkerwidthaccuracy_mm();
  inline void set_has_lanedeclination_deg();
  inline void clear_has_lanedeclination_deg();
  inline void set_has_lanedeclinationaccuracy_deg();
  inline void clear_has_lanedeclinationaccuracy_deg();
  inline void set_has_laneboundarytypeconfidence_percent();
  inline void clear_has_laneboundarytypeconfidence_percent();
  inline void set_has_lm_orientation();
  inline void clear_has_lm_orientation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  ::PositionOffset* positionoffset_;
  int laneboundarytype_;
  int laneboundarycolor_;
  double curvature_1pm_;
  ::google::protobuf::int32 lanemarkerwidth_mm_;
  ::google::protobuf::int32 lanemarkerwidthaccuracy_mm_;
  double lanedeclination_deg_;
  double lanedeclinationaccuracy_deg_;
  ::google::protobuf::RepeatedPtrField< ::LinePoint > linepoint_;
  ::Vector3D* lm_orientation_;
  ::google::protobuf::int32 laneboundarytypeconfidence_percent_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static LaneBoundaryRecognition* default_instance_;
};
// -------------------------------------------------------------------

class TireSlippageEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TireSlippageEvent) */ {
 public:
  TireSlippageEvent();
  virtual ~TireSlippageEvent();

  TireSlippageEvent(const TireSlippageEvent& from);

  inline TireSlippageEvent& operator=(const TireSlippageEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TireSlippageEvent& default_instance();

  void Swap(TireSlippageEvent* other);

  // implements Message ----------------------------------------------

  inline TireSlippageEvent* New() const { return New(NULL); }

  TireSlippageEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TireSlippageEvent& from);
  void MergeFrom(const TireSlippageEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TireSlippageEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TireSlippageEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static TireSlippageEvent* default_instance_;
};
// -------------------------------------------------------------------

class CrashDetectedEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CrashDetectedEvent) */ {
 public:
  CrashDetectedEvent();
  virtual ~CrashDetectedEvent();

  CrashDetectedEvent(const CrashDetectedEvent& from);

  inline CrashDetectedEvent& operator=(const CrashDetectedEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrashDetectedEvent& default_instance();

  void Swap(CrashDetectedEvent* other);

  // implements Message ----------------------------------------------

  inline CrashDetectedEvent* New() const { return New(NULL); }

  CrashDetectedEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CrashDetectedEvent& from);
  void MergeFrom(const CrashDetectedEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CrashDetectedEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool vehicleIsDrivable = 1;
  bool has_vehicleisdrivable() const;
  void clear_vehicleisdrivable();
  static const int kVehicleIsDrivableFieldNumber = 1;
  bool vehicleisdrivable() const;
  void set_vehicleisdrivable(bool value);

  // optional bool airbagsDeployed = 2;
  bool has_airbagsdeployed() const;
  void clear_airbagsdeployed();
  static const int kAirbagsDeployedFieldNumber = 2;
  bool airbagsdeployed() const;
  void set_airbagsdeployed(bool value);

  // optional bool eCallActivated = 3;
  bool has_ecallactivated() const;
  void clear_ecallactivated();
  static const int kECallActivatedFieldNumber = 3;
  bool ecallactivated() const;
  void set_ecallactivated(bool value);

  // optional bool vehicleIsObstacleOnRoad = 4;
  bool has_vehicleisobstacleonroad() const;
  void clear_vehicleisobstacleonroad();
  static const int kVehicleIsObstacleOnRoadFieldNumber = 4;
  bool vehicleisobstacleonroad() const;
  void set_vehicleisobstacleonroad(bool value);

  // optional .Vector3D maxAccelerationVector_mps2 = 5;
  bool has_maxaccelerationvector_mps2() const;
  void clear_maxaccelerationvector_mps2();
  static const int kMaxAccelerationVectorMps2FieldNumber = 5;
  const ::Vector3D& maxaccelerationvector_mps2() const;
  ::Vector3D* mutable_maxaccelerationvector_mps2();
  ::Vector3D* release_maxaccelerationvector_mps2();
  void set_allocated_maxaccelerationvector_mps2(::Vector3D* maxaccelerationvector_mps2);

  // @@protoc_insertion_point(class_scope:CrashDetectedEvent)
 private:
  inline void set_has_vehicleisdrivable();
  inline void clear_has_vehicleisdrivable();
  inline void set_has_airbagsdeployed();
  inline void clear_has_airbagsdeployed();
  inline void set_has_ecallactivated();
  inline void clear_has_ecallactivated();
  inline void set_has_vehicleisobstacleonroad();
  inline void clear_has_vehicleisobstacleonroad();
  inline void set_has_maxaccelerationvector_mps2();
  inline void clear_has_maxaccelerationvector_mps2();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Vector3D* maxaccelerationvector_mps2_;
  bool vehicleisdrivable_;
  bool airbagsdeployed_;
  bool ecallactivated_;
  bool vehicleisobstacleonroad_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static CrashDetectedEvent* default_instance_;
};
// -------------------------------------------------------------------

class EmergencyBrakingEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EmergencyBrakingEvent) */ {
 public:
  EmergencyBrakingEvent();
  virtual ~EmergencyBrakingEvent();

  EmergencyBrakingEvent(const EmergencyBrakingEvent& from);

  inline EmergencyBrakingEvent& operator=(const EmergencyBrakingEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmergencyBrakingEvent& default_instance();

  void Swap(EmergencyBrakingEvent* other);

  // implements Message ----------------------------------------------

  inline EmergencyBrakingEvent* New() const { return New(NULL); }

  EmergencyBrakingEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmergencyBrakingEvent& from);
  void MergeFrom(const EmergencyBrakingEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EmergencyBrakingEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Vector3D maxAccelerationVector_mps2 = 1;
  bool has_maxaccelerationvector_mps2() const;
  void clear_maxaccelerationvector_mps2();
  static const int kMaxAccelerationVectorMps2FieldNumber = 1;
  const ::Vector3D& maxaccelerationvector_mps2() const;
  ::Vector3D* mutable_maxaccelerationvector_mps2();
  ::Vector3D* release_maxaccelerationvector_mps2();
  void set_allocated_maxaccelerationvector_mps2(::Vector3D* maxaccelerationvector_mps2);

  // @@protoc_insertion_point(class_scope:EmergencyBrakingEvent)
 private:
  inline void set_has_maxaccelerationvector_mps2();
  inline void clear_has_maxaccelerationvector_mps2();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Vector3D* maxaccelerationvector_mps2_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static EmergencyBrakingEvent* default_instance_;
};
// -------------------------------------------------------------------

class DynamicStabilityControlEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DynamicStabilityControlEvent) */ {
 public:
  DynamicStabilityControlEvent();
  virtual ~DynamicStabilityControlEvent();

  DynamicStabilityControlEvent(const DynamicStabilityControlEvent& from);

  inline DynamicStabilityControlEvent& operator=(const DynamicStabilityControlEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicStabilityControlEvent& default_instance();

  void Swap(DynamicStabilityControlEvent* other);

  // implements Message ----------------------------------------------

  inline DynamicStabilityControlEvent* New() const { return New(NULL); }

  DynamicStabilityControlEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DynamicStabilityControlEvent& from);
  void MergeFrom(const DynamicStabilityControlEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DynamicStabilityControlEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DynamicStabilityControlEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static DynamicStabilityControlEvent* default_instance_;
};
// -------------------------------------------------------------------

class AntiLockBrakingSystemEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AntiLockBrakingSystemEvent) */ {
 public:
  AntiLockBrakingSystemEvent();
  virtual ~AntiLockBrakingSystemEvent();

  AntiLockBrakingSystemEvent(const AntiLockBrakingSystemEvent& from);

  inline AntiLockBrakingSystemEvent& operator=(const AntiLockBrakingSystemEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntiLockBrakingSystemEvent& default_instance();

  void Swap(AntiLockBrakingSystemEvent* other);

  // implements Message ----------------------------------------------

  inline AntiLockBrakingSystemEvent* New() const { return New(NULL); }

  AntiLockBrakingSystemEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntiLockBrakingSystemEvent& from);
  void MergeFrom(const AntiLockBrakingSystemEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AntiLockBrakingSystemEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AntiLockBrakingSystemEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static AntiLockBrakingSystemEvent* default_instance_;
};
// -------------------------------------------------------------------

class ElectronicStabilityControlEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ElectronicStabilityControlEvent) */ {
 public:
  ElectronicStabilityControlEvent();
  virtual ~ElectronicStabilityControlEvent();

  ElectronicStabilityControlEvent(const ElectronicStabilityControlEvent& from);

  inline ElectronicStabilityControlEvent& operator=(const ElectronicStabilityControlEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ElectronicStabilityControlEvent& default_instance();

  void Swap(ElectronicStabilityControlEvent* other);

  // implements Message ----------------------------------------------

  inline ElectronicStabilityControlEvent* New() const { return New(NULL); }

  ElectronicStabilityControlEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ElectronicStabilityControlEvent& from);
  void MergeFrom(const ElectronicStabilityControlEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElectronicStabilityControlEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool antiSlipActionEvent = 1;
  bool has_antislipactionevent() const;
  void clear_antislipactionevent();
  static const int kAntiSlipActionEventFieldNumber = 1;
  bool antislipactionevent() const;
  void set_antislipactionevent(bool value);

  // optional bool antiLockActionEvent = 2;
  bool has_antilockactionevent() const;
  void clear_antilockactionevent();
  static const int kAntiLockActionEventFieldNumber = 2;
  bool antilockactionevent() const;
  void set_antilockactionevent(bool value);

  // optional bool electronicStabilityControlEvent = 3;
  bool has_electronicstabilitycontrolevent() const;
  void clear_electronicstabilitycontrolevent();
  static const int kElectronicStabilityControlEventFieldNumber = 3;
  bool electronicstabilitycontrolevent() const;
  void set_electronicstabilitycontrolevent(bool value);

  // optional .Vector3D requestedAccelerationVector_mps2 = 4;
  bool has_requestedaccelerationvector_mps2() const;
  void clear_requestedaccelerationvector_mps2();
  static const int kRequestedAccelerationVectorMps2FieldNumber = 4;
  const ::Vector3D& requestedaccelerationvector_mps2() const;
  ::Vector3D* mutable_requestedaccelerationvector_mps2();
  ::Vector3D* release_requestedaccelerationvector_mps2();
  void set_allocated_requestedaccelerationvector_mps2(::Vector3D* requestedaccelerationvector_mps2);

  // optional .Vector3D requestedRotationRateVector_omega = 5;
  bool has_requestedrotationratevector_omega() const;
  void clear_requestedrotationratevector_omega();
  static const int kRequestedRotationRateVectorOmegaFieldNumber = 5;
  const ::Vector3D& requestedrotationratevector_omega() const;
  ::Vector3D* mutable_requestedrotationratevector_omega();
  ::Vector3D* release_requestedrotationratevector_omega();
  void set_allocated_requestedrotationratevector_omega(::Vector3D* requestedrotationratevector_omega);

  // @@protoc_insertion_point(class_scope:ElectronicStabilityControlEvent)
 private:
  inline void set_has_antislipactionevent();
  inline void clear_has_antislipactionevent();
  inline void set_has_antilockactionevent();
  inline void clear_has_antilockactionevent();
  inline void set_has_electronicstabilitycontrolevent();
  inline void clear_has_electronicstabilitycontrolevent();
  inline void set_has_requestedaccelerationvector_mps2();
  inline void clear_has_requestedaccelerationvector_mps2();
  inline void set_has_requestedrotationratevector_omega();
  inline void clear_has_requestedrotationratevector_omega();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Vector3D* requestedaccelerationvector_mps2_;
  ::Vector3D* requestedrotationratevector_omega_;
  bool antislipactionevent_;
  bool antilockactionevent_;
  bool electronicstabilitycontrolevent_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static ElectronicStabilityControlEvent* default_instance_;
};
// -------------------------------------------------------------------

class ExceptionalVehicleState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExceptionalVehicleState) */ {
 public:
  ExceptionalVehicleState();
  virtual ~ExceptionalVehicleState();

  ExceptionalVehicleState(const ExceptionalVehicleState& from);

  inline ExceptionalVehicleState& operator=(const ExceptionalVehicleState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExceptionalVehicleState& default_instance();

  void Swap(ExceptionalVehicleState* other);

  // implements Message ----------------------------------------------

  inline ExceptionalVehicleState* New() const { return New(NULL); }

  ExceptionalVehicleState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExceptionalVehicleState& from);
  void MergeFrom(const ExceptionalVehicleState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExceptionalVehicleState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // optional .TireSlippageEvent tireSlippage = 2 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_tireslippage() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_tireslippage();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kTireSlippageFieldNumber = 2;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::TireSlippageEvent& tireslippage() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::TireSlippageEvent* mutable_tireslippage();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::TireSlippageEvent* release_tireslippage();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_tireslippage(::TireSlippageEvent* tireslippage);

  // optional .CrashDetectedEvent crashDetected = 3;
  bool has_crashdetected() const;
  void clear_crashdetected();
  static const int kCrashDetectedFieldNumber = 3;
  const ::CrashDetectedEvent& crashdetected() const;
  ::CrashDetectedEvent* mutable_crashdetected();
  ::CrashDetectedEvent* release_crashdetected();
  void set_allocated_crashdetected(::CrashDetectedEvent* crashdetected);

  // optional .EmergencyBrakingEvent emergencyBraking = 4;
  bool has_emergencybraking() const;
  void clear_emergencybraking();
  static const int kEmergencyBrakingFieldNumber = 4;
  const ::EmergencyBrakingEvent& emergencybraking() const;
  ::EmergencyBrakingEvent* mutable_emergencybraking();
  ::EmergencyBrakingEvent* release_emergencybraking();
  void set_allocated_emergencybraking(::EmergencyBrakingEvent* emergencybraking);

  // optional .DynamicStabilityControlEvent dynamicStabilityControl = 5 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_dynamicstabilitycontrol() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_dynamicstabilitycontrol();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kDynamicStabilityControlFieldNumber = 5;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::DynamicStabilityControlEvent& dynamicstabilitycontrol() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::DynamicStabilityControlEvent* mutable_dynamicstabilitycontrol();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::DynamicStabilityControlEvent* release_dynamicstabilitycontrol();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_dynamicstabilitycontrol(::DynamicStabilityControlEvent* dynamicstabilitycontrol);

  // optional .AntiLockBrakingSystemEvent antiLockBrakingSystem = 6 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_antilockbrakingsystem() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_antilockbrakingsystem();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kAntiLockBrakingSystemFieldNumber = 6;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::AntiLockBrakingSystemEvent& antilockbrakingsystem() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::AntiLockBrakingSystemEvent* mutable_antilockbrakingsystem();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::AntiLockBrakingSystemEvent* release_antilockbrakingsystem();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_antilockbrakingsystem(::AntiLockBrakingSystemEvent* antilockbrakingsystem);

  // optional .ElectronicStabilityControlEvent electronicStabilityControl = 7;
  bool has_electronicstabilitycontrol() const;
  void clear_electronicstabilitycontrol();
  static const int kElectronicStabilityControlFieldNumber = 7;
  const ::ElectronicStabilityControlEvent& electronicstabilitycontrol() const;
  ::ElectronicStabilityControlEvent* mutable_electronicstabilitycontrol();
  ::ElectronicStabilityControlEvent* release_electronicstabilitycontrol();
  void set_allocated_electronicstabilitycontrol(::ElectronicStabilityControlEvent* electronicstabilitycontrol);

  // @@protoc_insertion_point(class_scope:ExceptionalVehicleState)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_tireslippage();
  inline void clear_has_tireslippage();
  inline void set_has_crashdetected();
  inline void clear_has_crashdetected();
  inline void set_has_emergencybraking();
  inline void clear_has_emergencybraking();
  inline void set_has_dynamicstabilitycontrol();
  inline void clear_has_dynamicstabilitycontrol();
  inline void set_has_antilockbrakingsystem();
  inline void clear_has_antilockbrakingsystem();
  inline void set_has_electronicstabilitycontrol();
  inline void clear_has_electronicstabilitycontrol();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  ::TireSlippageEvent* tireslippage_;
  ::CrashDetectedEvent* crashdetected_;
  ::EmergencyBrakingEvent* emergencybraking_;
  ::DynamicStabilityControlEvent* dynamicstabilitycontrol_;
  ::AntiLockBrakingSystemEvent* antilockbrakingsystem_;
  ::ElectronicStabilityControlEvent* electronicstabilitycontrol_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static ExceptionalVehicleState* default_instance_;
};
// -------------------------------------------------------------------

class ProprietaryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProprietaryInfo) */ {
 public:
  ProprietaryInfo();
  virtual ~ProprietaryInfo();

  ProprietaryInfo(const ProprietaryInfo& from);

  inline ProprietaryInfo& operator=(const ProprietaryInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProprietaryInfo& default_instance();

  void Swap(ProprietaryInfo* other);

  // implements Message ----------------------------------------------

  inline ProprietaryInfo* New() const { return New(NULL); }

  ProprietaryInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProprietaryInfo& from);
  void MergeFrom(const ProprietaryInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProprietaryInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // repeated .KeyValuePairString keyValuePairs = 2;
  int keyvaluepairs_size() const;
  void clear_keyvaluepairs();
  static const int kKeyValuePairsFieldNumber = 2;
  const ::KeyValuePairString& keyvaluepairs(int index) const;
  ::KeyValuePairString* mutable_keyvaluepairs(int index);
  ::KeyValuePairString* add_keyvaluepairs();
  ::google::protobuf::RepeatedPtrField< ::KeyValuePairString >*
      mutable_keyvaluepairs();
  const ::google::protobuf::RepeatedPtrField< ::KeyValuePairString >&
      keyvaluepairs() const;

  // @@protoc_insertion_point(class_scope:ProprietaryInfo)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  ::google::protobuf::RepeatedPtrField< ::KeyValuePairString > keyvaluepairs_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static ProprietaryInfo* default_instance_;
};
// -------------------------------------------------------------------

class EnvironmentStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EnvironmentStatus) */ {
 public:
  EnvironmentStatus();
  virtual ~EnvironmentStatus();

  EnvironmentStatus(const EnvironmentStatus& from);

  inline EnvironmentStatus& operator=(const EnvironmentStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnvironmentStatus& default_instance();

  void Swap(EnvironmentStatus* other);

  // implements Message ----------------------------------------------

  inline EnvironmentStatus* New() const { return New(NULL); }

  EnvironmentStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnvironmentStatus& from);
  void MergeFrom(const EnvironmentStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnvironmentStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EnvironmentStatus_LightConditionsEnum LightConditionsEnum;
  static const LightConditionsEnum GENERAL_DAYLIGHT =
    EnvironmentStatus_LightConditionsEnum_GENERAL_DAYLIGHT;
  static const LightConditionsEnum GENERAL_DARK =
    EnvironmentStatus_LightConditionsEnum_GENERAL_DARK;
  static const LightConditionsEnum DAYLIGHT_SUN =
    EnvironmentStatus_LightConditionsEnum_DAYLIGHT_SUN;
  static const LightConditionsEnum DAYLIGHT_CLOUD =
    EnvironmentStatus_LightConditionsEnum_DAYLIGHT_CLOUD;
  static const LightConditionsEnum DUSK_OR_DAWN =
    EnvironmentStatus_LightConditionsEnum_DUSK_OR_DAWN;
  static const LightConditionsEnum NIGHT_LUMINATED =
    EnvironmentStatus_LightConditionsEnum_NIGHT_LUMINATED;
  static const LightConditionsEnum NIGHT_DARK =
    EnvironmentStatus_LightConditionsEnum_NIGHT_DARK;
  static inline bool LightConditionsEnum_IsValid(int value) {
    return EnvironmentStatus_LightConditionsEnum_IsValid(value);
  }
  static const LightConditionsEnum LightConditionsEnum_MIN =
    EnvironmentStatus_LightConditionsEnum_LightConditionsEnum_MIN;
  static const LightConditionsEnum LightConditionsEnum_MAX =
    EnvironmentStatus_LightConditionsEnum_LightConditionsEnum_MAX;
  static const int LightConditionsEnum_ARRAYSIZE =
    EnvironmentStatus_LightConditionsEnum_LightConditionsEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LightConditionsEnum_descriptor() {
    return EnvironmentStatus_LightConditionsEnum_descriptor();
  }
  static inline const ::std::string& LightConditionsEnum_Name(LightConditionsEnum value) {
    return EnvironmentStatus_LightConditionsEnum_Name(value);
  }
  static inline bool LightConditionsEnum_Parse(const ::std::string& name,
      LightConditionsEnum* value) {
    return EnvironmentStatus_LightConditionsEnum_Parse(name, value);
  }

  typedef EnvironmentStatus_PrecipitationEnum PrecipitationEnum;
  static const PrecipitationEnum NONE =
    EnvironmentStatus_PrecipitationEnum_NONE;
  static const PrecipitationEnum RAIN =
    EnvironmentStatus_PrecipitationEnum_RAIN;
  static const PrecipitationEnum HAIL =
    EnvironmentStatus_PrecipitationEnum_HAIL;
  static const PrecipitationEnum SNOW =
    EnvironmentStatus_PrecipitationEnum_SNOW;
  static inline bool PrecipitationEnum_IsValid(int value) {
    return EnvironmentStatus_PrecipitationEnum_IsValid(value);
  }
  static const PrecipitationEnum PrecipitationEnum_MIN =
    EnvironmentStatus_PrecipitationEnum_PrecipitationEnum_MIN;
  static const PrecipitationEnum PrecipitationEnum_MAX =
    EnvironmentStatus_PrecipitationEnum_PrecipitationEnum_MAX;
  static const int PrecipitationEnum_ARRAYSIZE =
    EnvironmentStatus_PrecipitationEnum_PrecipitationEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PrecipitationEnum_descriptor() {
    return EnvironmentStatus_PrecipitationEnum_descriptor();
  }
  static inline const ::std::string& PrecipitationEnum_Name(PrecipitationEnum value) {
    return EnvironmentStatus_PrecipitationEnum_Name(value);
  }
  static inline bool PrecipitationEnum_Parse(const ::std::string& name,
      PrecipitationEnum* value) {
    return EnvironmentStatus_PrecipitationEnum_Parse(name, value);
  }

  typedef EnvironmentStatus_RoadSurfaceTypeEnum RoadSurfaceTypeEnum;
  static const RoadSurfaceTypeEnum ASPHALT =
    EnvironmentStatus_RoadSurfaceTypeEnum_ASPHALT;
  static const RoadSurfaceTypeEnum CONCRETE =
    EnvironmentStatus_RoadSurfaceTypeEnum_CONCRETE;
  static const RoadSurfaceTypeEnum PAVED =
    EnvironmentStatus_RoadSurfaceTypeEnum_PAVED;
  static const RoadSurfaceTypeEnum GRAVEL =
    EnvironmentStatus_RoadSurfaceTypeEnum_GRAVEL;
  static const RoadSurfaceTypeEnum ICEORSNOW =
    EnvironmentStatus_RoadSurfaceTypeEnum_ICEORSNOW;
  static const RoadSurfaceTypeEnum UNKNOWN =
    EnvironmentStatus_RoadSurfaceTypeEnum_UNKNOWN;
  static inline bool RoadSurfaceTypeEnum_IsValid(int value) {
    return EnvironmentStatus_RoadSurfaceTypeEnum_IsValid(value);
  }
  static const RoadSurfaceTypeEnum RoadSurfaceTypeEnum_MIN =
    EnvironmentStatus_RoadSurfaceTypeEnum_RoadSurfaceTypeEnum_MIN;
  static const RoadSurfaceTypeEnum RoadSurfaceTypeEnum_MAX =
    EnvironmentStatus_RoadSurfaceTypeEnum_RoadSurfaceTypeEnum_MAX;
  static const int RoadSurfaceTypeEnum_ARRAYSIZE =
    EnvironmentStatus_RoadSurfaceTypeEnum_RoadSurfaceTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadSurfaceTypeEnum_descriptor() {
    return EnvironmentStatus_RoadSurfaceTypeEnum_descriptor();
  }
  static inline const ::std::string& RoadSurfaceTypeEnum_Name(RoadSurfaceTypeEnum value) {
    return EnvironmentStatus_RoadSurfaceTypeEnum_Name(value);
  }
  static inline bool RoadSurfaceTypeEnum_Parse(const ::std::string& name,
      RoadSurfaceTypeEnum* value) {
    return EnvironmentStatus_RoadSurfaceTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // optional .EnvironmentStatus.LightConditionsEnum lightConditions = 2;
  bool has_lightconditions() const;
  void clear_lightconditions();
  static const int kLightConditionsFieldNumber = 2;
  ::EnvironmentStatus_LightConditionsEnum lightconditions() const;
  void set_lightconditions(::EnvironmentStatus_LightConditionsEnum value);

  // optional double externalAirTemperature_DegC = 3;
  bool has_externalairtemperature_degc() const;
  void clear_externalairtemperature_degc();
  static const int kExternalAirTemperatureDegCFieldNumber = 3;
  double externalairtemperature_degc() const;
  void set_externalairtemperature_degc(double value);

  // optional double externalAirTemperatureAccuracy_DegC = 4;
  bool has_externalairtemperatureaccuracy_degc() const;
  void clear_externalairtemperatureaccuracy_degc();
  static const int kExternalAirTemperatureAccuracyDegCFieldNumber = 4;
  double externalairtemperatureaccuracy_degc() const;
  void set_externalairtemperatureaccuracy_degc(double value);

  // optional .EnvironmentStatus.PrecipitationEnum precipitation = 5;
  bool has_precipitation() const;
  void clear_precipitation();
  static const int kPrecipitationFieldNumber = 5;
  ::EnvironmentStatus_PrecipitationEnum precipitation() const;
  void set_precipitation(::EnvironmentStatus_PrecipitationEnum value);

  // optional double visibleDistance_m = 6;
  bool has_visibledistance_m() const;
  void clear_visibledistance_m();
  static const int kVisibleDistanceMFieldNumber = 6;
  double visibledistance_m() const;
  void set_visibledistance_m(double value);

  // optional double roadSurfaceTemperature_DegC = 7;
  bool has_roadsurfacetemperature_degc() const;
  void clear_roadsurfacetemperature_degc();
  static const int kRoadSurfaceTemperatureDegCFieldNumber = 7;
  double roadsurfacetemperature_degc() const;
  void set_roadsurfacetemperature_degc(double value);

  // optional double roadSurfaceTemperatureAccuracy_DegC = 8;
  bool has_roadsurfacetemperatureaccuracy_degc() const;
  void clear_roadsurfacetemperatureaccuracy_degc();
  static const int kRoadSurfaceTemperatureAccuracyDegCFieldNumber = 8;
  double roadsurfacetemperatureaccuracy_degc() const;
  void set_roadsurfacetemperatureaccuracy_degc(double value);

  // optional .EnvironmentStatus.RoadSurfaceTypeEnum roadSurfaceType = 9;
  bool has_roadsurfacetype() const;
  void clear_roadsurfacetype();
  static const int kRoadSurfaceTypeFieldNumber = 9;
  ::EnvironmentStatus_RoadSurfaceTypeEnum roadsurfacetype() const;
  void set_roadsurfacetype(::EnvironmentStatus_RoadSurfaceTypeEnum value);

  // @@protoc_insertion_point(class_scope:EnvironmentStatus)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_lightconditions();
  inline void clear_has_lightconditions();
  inline void set_has_externalairtemperature_degc();
  inline void clear_has_externalairtemperature_degc();
  inline void set_has_externalairtemperatureaccuracy_degc();
  inline void clear_has_externalairtemperatureaccuracy_degc();
  inline void set_has_precipitation();
  inline void clear_has_precipitation();
  inline void set_has_visibledistance_m();
  inline void clear_has_visibledistance_m();
  inline void set_has_roadsurfacetemperature_degc();
  inline void clear_has_roadsurfacetemperature_degc();
  inline void set_has_roadsurfacetemperatureaccuracy_degc();
  inline void clear_has_roadsurfacetemperatureaccuracy_degc();
  inline void set_has_roadsurfacetype();
  inline void clear_has_roadsurfacetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  double externalairtemperature_degc_;
  int lightconditions_;
  int precipitation_;
  double externalairtemperatureaccuracy_degc_;
  double visibledistance_m_;
  double roadsurfacetemperature_degc_;
  double roadsurfacetemperatureaccuracy_degc_;
  int roadsurfacetype_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static EnvironmentStatus* default_instance_;
};
// -------------------------------------------------------------------

class TrafficLightStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrafficLightStatus) */ {
 public:
  TrafficLightStatus();
  virtual ~TrafficLightStatus();

  TrafficLightStatus(const TrafficLightStatus& from);

  inline TrafficLightStatus& operator=(const TrafficLightStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightStatus& default_instance();

  void Swap(TrafficLightStatus* other);

  // implements Message ----------------------------------------------

  inline TrafficLightStatus* New() const { return New(NULL); }

  TrafficLightStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrafficLightStatus& from);
  void MergeFrom(const TrafficLightStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrafficLightStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TrafficLightStatus_LightStatus LightStatus;
  static const LightStatus OFF =
    TrafficLightStatus_LightStatus_OFF;
  static const LightStatus ON =
    TrafficLightStatus_LightStatus_ON;
  static const LightStatus BLINKING =
    TrafficLightStatus_LightStatus_BLINKING;
  static inline bool LightStatus_IsValid(int value) {
    return TrafficLightStatus_LightStatus_IsValid(value);
  }
  static const LightStatus LightStatus_MIN =
    TrafficLightStatus_LightStatus_LightStatus_MIN;
  static const LightStatus LightStatus_MAX =
    TrafficLightStatus_LightStatus_LightStatus_MAX;
  static const int LightStatus_ARRAYSIZE =
    TrafficLightStatus_LightStatus_LightStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LightStatus_descriptor() {
    return TrafficLightStatus_LightStatus_descriptor();
  }
  static inline const ::std::string& LightStatus_Name(LightStatus value) {
    return TrafficLightStatus_LightStatus_Name(value);
  }
  static inline bool LightStatus_Parse(const ::std::string& name,
      LightStatus* value) {
    return TrafficLightStatus_LightStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TrafficLightStatus.LightStatus green = 1;
  bool has_green() const;
  void clear_green();
  static const int kGreenFieldNumber = 1;
  ::TrafficLightStatus_LightStatus green() const;
  void set_green(::TrafficLightStatus_LightStatus value);

  // optional .TrafficLightStatus.LightStatus yellow = 2;
  bool has_yellow() const;
  void clear_yellow();
  static const int kYellowFieldNumber = 2;
  ::TrafficLightStatus_LightStatus yellow() const;
  void set_yellow(::TrafficLightStatus_LightStatus value);

  // optional .TrafficLightStatus.LightStatus red = 3;
  bool has_red() const;
  void clear_red();
  static const int kRedFieldNumber = 3;
  ::TrafficLightStatus_LightStatus red() const;
  void set_red(::TrafficLightStatus_LightStatus value);

  // optional .TrafficLightStatus.LightStatus other = 4;
  bool has_other() const;
  void clear_other();
  static const int kOtherFieldNumber = 4;
  ::TrafficLightStatus_LightStatus other() const;
  void set_other(::TrafficLightStatus_LightStatus value);

  // @@protoc_insertion_point(class_scope:TrafficLightStatus)
 private:
  inline void set_has_green();
  inline void clear_has_green();
  inline void set_has_yellow();
  inline void clear_has_yellow();
  inline void set_has_red();
  inline void clear_has_red();
  inline void set_has_other();
  inline void clear_has_other();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int green_;
  int yellow_;
  int red_;
  int other_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static TrafficLightStatus* default_instance_;
};
// -------------------------------------------------------------------

class ObjectDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ObjectDetection) */ {
 public:
  ObjectDetection();
  virtual ~ObjectDetection();

  ObjectDetection(const ObjectDetection& from);

  inline ObjectDetection& operator=(const ObjectDetection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectDetection& default_instance();

  void Swap(ObjectDetection* other);

  // implements Message ----------------------------------------------

  inline ObjectDetection* New() const { return New(NULL); }

  ObjectDetection* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectDetection& from);
  void MergeFrom(const ObjectDetection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObjectDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ObjectDetection_ObjectTypeEnum ObjectTypeEnum;
  static const ObjectTypeEnum MOVING_GENERAL =
    ObjectDetection_ObjectTypeEnum_MOVING_GENERAL;
  static const ObjectTypeEnum STATIC_GENERAL =
    ObjectDetection_ObjectTypeEnum_STATIC_GENERAL;
  static const ObjectTypeEnum STATIC_GENERAL_VERTICAL =
    ObjectDetection_ObjectTypeEnum_STATIC_GENERAL_VERTICAL;
  static const ObjectTypeEnum STATIC_GENERAL_TRANSVERSAL =
    ObjectDetection_ObjectTypeEnum_STATIC_GENERAL_TRANSVERSAL;
  static const ObjectTypeEnum STATIC_GENERAL_LATERAL =
    ObjectDetection_ObjectTypeEnum_STATIC_GENERAL_LATERAL;
  static const ObjectTypeEnum MOVING_VEHICLE =
    ObjectDetection_ObjectTypeEnum_MOVING_VEHICLE;
  static const ObjectTypeEnum MOVING_TRUCK =
    ObjectDetection_ObjectTypeEnum_MOVING_TRUCK;
  static const ObjectTypeEnum MOVING_BIKE =
    ObjectDetection_ObjectTypeEnum_MOVING_BIKE;
  static const ObjectTypeEnum MOVING_PERSON =
    ObjectDetection_ObjectTypeEnum_MOVING_PERSON;
  static const ObjectTypeEnum STATIC_BRIDGE =
    ObjectDetection_ObjectTypeEnum_STATIC_BRIDGE;
  static const ObjectTypeEnum STATIC_TUNNEL =
    ObjectDetection_ObjectTypeEnum_STATIC_TUNNEL;
  static const ObjectTypeEnum STATIC_POLE =
    ObjectDetection_ObjectTypeEnum_STATIC_POLE;
  static const ObjectTypeEnum STATIC_BAR =
    ObjectDetection_ObjectTypeEnum_STATIC_BAR;
  static const ObjectTypeEnum STATIC_TREE =
    ObjectDetection_ObjectTypeEnum_STATIC_TREE;
  static const ObjectTypeEnum STATIC_WALL =
    ObjectDetection_ObjectTypeEnum_STATIC_WALL;
  static const ObjectTypeEnum STATIC_BOLLARD =
    ObjectDetection_ObjectTypeEnum_STATIC_BOLLARD;
  static const ObjectTypeEnum STATIC_GUIDERAIL =
    ObjectDetection_ObjectTypeEnum_STATIC_GUIDERAIL;
  static const ObjectTypeEnum STATIC_TRAFFICISLAND =
    ObjectDetection_ObjectTypeEnum_STATIC_TRAFFICISLAND;
  static const ObjectTypeEnum STATIC_SIGN =
    ObjectDetection_ObjectTypeEnum_STATIC_SIGN;
  static const ObjectTypeEnum STATIC_TRAFFIC_LIGHT =
    ObjectDetection_ObjectTypeEnum_STATIC_TRAFFIC_LIGHT;
  static inline bool ObjectTypeEnum_IsValid(int value) {
    return ObjectDetection_ObjectTypeEnum_IsValid(value);
  }
  static const ObjectTypeEnum ObjectTypeEnum_MIN =
    ObjectDetection_ObjectTypeEnum_ObjectTypeEnum_MIN;
  static const ObjectTypeEnum ObjectTypeEnum_MAX =
    ObjectDetection_ObjectTypeEnum_ObjectTypeEnum_MAX;
  static const int ObjectTypeEnum_ARRAYSIZE =
    ObjectDetection_ObjectTypeEnum_ObjectTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectTypeEnum_descriptor() {
    return ObjectDetection_ObjectTypeEnum_descriptor();
  }
  static inline const ::std::string& ObjectTypeEnum_Name(ObjectTypeEnum value) {
    return ObjectDetection_ObjectTypeEnum_Name(value);
  }
  static inline bool ObjectTypeEnum_Parse(const ::std::string& name,
      ObjectTypeEnum* value) {
    return ObjectDetection_ObjectTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // optional int64 detectedObjectID = 2;
  bool has_detectedobjectid() const;
  void clear_detectedobjectid();
  static const int kDetectedObjectIDFieldNumber = 2;
  ::google::protobuf::int64 detectedobjectid() const;
  void set_detectedobjectid(::google::protobuf::int64 value);

  // optional .PositionOffset positionOffset = 3;
  bool has_positionoffset() const;
  void clear_positionoffset();
  static const int kPositionOffsetFieldNumber = 3;
  const ::PositionOffset& positionoffset() const;
  ::PositionOffset* mutable_positionoffset();
  ::PositionOffset* release_positionoffset();
  void set_allocated_positionoffset(::PositionOffset* positionoffset);

  // optional .Vector3D movingVector_mps = 4;
  bool has_movingvector_mps() const;
  void clear_movingvector_mps();
  static const int kMovingVectorMpsFieldNumber = 4;
  const ::Vector3D& movingvector_mps() const;
  ::Vector3D* mutable_movingvector_mps();
  ::Vector3D* release_movingvector_mps();
  void set_allocated_movingvector_mps(::Vector3D* movingvector_mps);

  // optional .ObjectDetection.ObjectTypeEnum objectType = 5;
  bool has_objecttype() const;
  void clear_objecttype();
  static const int kObjectTypeFieldNumber = 5;
  ::ObjectDetection_ObjectTypeEnum objecttype() const;
  void set_objecttype(::ObjectDetection_ObjectTypeEnum value);

  // optional .Vector3D objectSizeVector_m = 6;
  bool has_objectsizevector_m() const;
  void clear_objectsizevector_m();
  static const int kObjectSizeVectorMFieldNumber = 6;
  const ::Vector3D& objectsizevector_m() const;
  ::Vector3D* mutable_objectsizevector_m();
  ::Vector3D* release_objectsizevector_m();
  void set_allocated_objectsizevector_m(::Vector3D* objectsizevector_m);

  // optional .Vector3D objectSizeAccuracyVector_m = 7;
  bool has_objectsizeaccuracyvector_m() const;
  void clear_objectsizeaccuracyvector_m();
  static const int kObjectSizeAccuracyVectorMFieldNumber = 7;
  const ::Vector3D& objectsizeaccuracyvector_m() const;
  ::Vector3D* mutable_objectsizeaccuracyvector_m();
  ::Vector3D* release_objectsizeaccuracyvector_m();
  void set_allocated_objectsizeaccuracyvector_m(::Vector3D* objectsizeaccuracyvector_m);

  // optional int64 mediaID = 8;
  bool has_mediaid() const;
  void clear_mediaid();
  static const int kMediaIDFieldNumber = 8;
  ::google::protobuf::int64 mediaid() const;
  void set_mediaid(::google::protobuf::int64 value);

  // optional .TrafficLightStatus trafficLightStatus = 1000;
  bool has_trafficlightstatus() const;
  void clear_trafficlightstatus();
  static const int kTrafficLightStatusFieldNumber = 1000;
  const ::TrafficLightStatus& trafficlightstatus() const;
  ::TrafficLightStatus* mutable_trafficlightstatus();
  ::TrafficLightStatus* release_trafficlightstatus();
  void set_allocated_trafficlightstatus(::TrafficLightStatus* trafficlightstatus);

  // optional uint32 objectDetectionConfidence_percent = 1001;
  bool has_objectdetectionconfidence_percent() const;
  void clear_objectdetectionconfidence_percent();
  static const int kObjectDetectionConfidencePercentFieldNumber = 1001;
  ::google::protobuf::uint32 objectdetectionconfidence_percent() const;
  void set_objectdetectionconfidence_percent(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ObjectDetection)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_detectedobjectid();
  inline void clear_has_detectedobjectid();
  inline void set_has_positionoffset();
  inline void clear_has_positionoffset();
  inline void set_has_movingvector_mps();
  inline void clear_has_movingvector_mps();
  inline void set_has_objecttype();
  inline void clear_has_objecttype();
  inline void set_has_objectsizevector_m();
  inline void clear_has_objectsizevector_m();
  inline void set_has_objectsizeaccuracyvector_m();
  inline void clear_has_objectsizeaccuracyvector_m();
  inline void set_has_mediaid();
  inline void clear_has_mediaid();
  inline void set_has_trafficlightstatus();
  inline void clear_has_trafficlightstatus();
  inline void set_has_objectdetectionconfidence_percent();
  inline void clear_has_objectdetectionconfidence_percent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  ::google::protobuf::int64 detectedobjectid_;
  ::PositionOffset* positionoffset_;
  ::Vector3D* movingvector_mps_;
  ::Vector3D* objectsizevector_m_;
  ::Vector3D* objectsizeaccuracyvector_m_;
  int objecttype_;
  ::google::protobuf::uint32 objectdetectionconfidence_percent_;
  ::google::protobuf::int64 mediaid_;
  ::TrafficLightStatus* trafficlightstatus_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static ObjectDetection* default_instance_;
};
// -------------------------------------------------------------------

class ADServiceAndSensorState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ADServiceAndSensorState) */ {
 public:
  ADServiceAndSensorState();
  virtual ~ADServiceAndSensorState();

  ADServiceAndSensorState(const ADServiceAndSensorState& from);

  inline ADServiceAndSensorState& operator=(const ADServiceAndSensorState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ADServiceAndSensorState& default_instance();

  void Swap(ADServiceAndSensorState* other);

  // implements Message ----------------------------------------------

  inline ADServiceAndSensorState* New() const { return New(NULL); }

  ADServiceAndSensorState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ADServiceAndSensorState& from);
  void MergeFrom(const ADServiceAndSensorState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ADServiceAndSensorState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // optional bool adSpeedControl = 2;
  bool has_adspeedcontrol() const;
  void clear_adspeedcontrol();
  static const int kAdSpeedControlFieldNumber = 2;
  bool adspeedcontrol() const;
  void set_adspeedcontrol(bool value);

  // optional bool adBrakeControl = 3;
  bool has_adbrakecontrol() const;
  void clear_adbrakecontrol();
  static const int kAdBrakeControlFieldNumber = 3;
  bool adbrakecontrol() const;
  void set_adbrakecontrol(bool value);

  // optional bool adSteeringControl = 4;
  bool has_adsteeringcontrol() const;
  void clear_adsteeringcontrol();
  static const int kAdSteeringControlFieldNumber = 4;
  bool adsteeringcontrol() const;
  void set_adsteeringcontrol(bool value);

  // optional bool adConnectionAvailable = 5;
  bool has_adconnectionavailable() const;
  void clear_adconnectionavailable();
  static const int kAdConnectionAvailableFieldNumber = 5;
  bool adconnectionavailable() const;
  void set_adconnectionavailable(bool value);

  // optional bool sensorObjectRecognition = 6;
  bool has_sensorobjectrecognition() const;
  void clear_sensorobjectrecognition();
  static const int kSensorObjectRecognitionFieldNumber = 6;
  bool sensorobjectrecognition() const;
  void set_sensorobjectrecognition(bool value);

  // optional bool sensorSignRecognition = 7;
  bool has_sensorsignrecognition() const;
  void clear_sensorsignrecognition();
  static const int kSensorSignRecognitionFieldNumber = 7;
  bool sensorsignrecognition() const;
  void set_sensorsignrecognition(bool value);

  // optional bool sensorLaneRecognition = 8;
  bool has_sensorlanerecognition() const;
  void clear_sensorlanerecognition();
  static const int kSensorLaneRecognitionFieldNumber = 8;
  bool sensorlanerecognition() const;
  void set_sensorlanerecognition(bool value);

  // optional bool sensorRoadSurface = 9;
  bool has_sensorroadsurface() const;
  void clear_sensorroadsurface();
  static const int kSensorRoadSurfaceFieldNumber = 9;
  bool sensorroadsurface() const;
  void set_sensorroadsurface(bool value);

  // optional bool sensorEnvironment = 10;
  bool has_sensorenvironment() const;
  void clear_sensorenvironment();
  static const int kSensorEnvironmentFieldNumber = 10;
  bool sensorenvironment() const;
  void set_sensorenvironment(bool value);

  // @@protoc_insertion_point(class_scope:ADServiceAndSensorState)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_adspeedcontrol();
  inline void clear_has_adspeedcontrol();
  inline void set_has_adbrakecontrol();
  inline void clear_has_adbrakecontrol();
  inline void set_has_adsteeringcontrol();
  inline void clear_has_adsteeringcontrol();
  inline void set_has_adconnectionavailable();
  inline void clear_has_adconnectionavailable();
  inline void set_has_sensorobjectrecognition();
  inline void clear_has_sensorobjectrecognition();
  inline void set_has_sensorsignrecognition();
  inline void clear_has_sensorsignrecognition();
  inline void set_has_sensorlanerecognition();
  inline void clear_has_sensorlanerecognition();
  inline void set_has_sensorroadsurface();
  inline void clear_has_sensorroadsurface();
  inline void set_has_sensorenvironment();
  inline void clear_has_sensorenvironment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  bool adspeedcontrol_;
  bool adbrakecontrol_;
  bool adsteeringcontrol_;
  bool adconnectionavailable_;
  bool sensorobjectrecognition_;
  bool sensorsignrecognition_;
  bool sensorlanerecognition_;
  bool sensorroadsurface_;
  bool sensorenvironment_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static ADServiceAndSensorState* default_instance_;
};
// -------------------------------------------------------------------

class EgoMotion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EgoMotion) */ {
 public:
  EgoMotion();
  virtual ~EgoMotion();

  EgoMotion(const EgoMotion& from);

  inline EgoMotion& operator=(const EgoMotion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgoMotion& default_instance();

  void Swap(EgoMotion* other);

  // implements Message ----------------------------------------------

  inline EgoMotion* New() const { return New(NULL); }

  EgoMotion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EgoMotion& from);
  void MergeFrom(const EgoMotion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EgoMotion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // optional int64 egoMotionVariant = 2;
  bool has_egomotionvariant() const;
  void clear_egomotionvariant();
  static const int kEgoMotionVariantFieldNumber = 2;
  ::google::protobuf::int64 egomotionvariant() const;
  void set_egomotionvariant(::google::protobuf::int64 value);

  // optional .PositionOffset egoPosition = 3;
  bool has_egoposition() const;
  void clear_egoposition();
  static const int kEgoPositionFieldNumber = 3;
  const ::PositionOffset& egoposition() const;
  ::PositionOffset* mutable_egoposition();
  ::PositionOffset* release_egoposition();
  void set_allocated_egoposition(::PositionOffset* egoposition);

  // optional .Vector3D egoOrientation = 4;
  bool has_egoorientation() const;
  void clear_egoorientation();
  static const int kEgoOrientationFieldNumber = 4;
  const ::Vector3D& egoorientation() const;
  ::Vector3D* mutable_egoorientation();
  ::Vector3D* release_egoorientation();
  void set_allocated_egoorientation(::Vector3D* egoorientation);

  // optional int64 mediaID = 8;
  bool has_mediaid() const;
  void clear_mediaid();
  static const int kMediaIDFieldNumber = 8;
  ::google::protobuf::int64 mediaid() const;
  void set_mediaid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:EgoMotion)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_egomotionvariant();
  inline void clear_has_egomotionvariant();
  inline void set_has_egoposition();
  inline void clear_has_egoposition();
  inline void set_has_egoorientation();
  inline void clear_has_egoorientation();
  inline void set_has_mediaid();
  inline void clear_has_mediaid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  ::google::protobuf::int64 egomotionvariant_;
  ::PositionOffset* egoposition_;
  ::Vector3D* egoorientation_;
  ::google::protobuf::int64 mediaid_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static EgoMotion* default_instance_;
};
// -------------------------------------------------------------------

class RawGNSSSatData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RawGNSSSatData) */ {
 public:
  RawGNSSSatData();
  virtual ~RawGNSSSatData();

  RawGNSSSatData(const RawGNSSSatData& from);

  inline RawGNSSSatData& operator=(const RawGNSSSatData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RawGNSSSatData& default_instance();

  void Swap(RawGNSSSatData* other);

  // implements Message ----------------------------------------------

  inline RawGNSSSatData* New() const { return New(NULL); }

  RawGNSSSatData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawGNSSSatData& from);
  void MergeFrom(const RawGNSSSatData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RawGNSSSatData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RawGNSSSatData_RawGNSSSatDataType RawGNSSSatDataType;
  static const RawGNSSSatDataType RINEX =
    RawGNSSSatData_RawGNSSSatDataType_RINEX;
  static inline bool RawGNSSSatDataType_IsValid(int value) {
    return RawGNSSSatData_RawGNSSSatDataType_IsValid(value);
  }
  static const RawGNSSSatDataType RawGNSSSatDataType_MIN =
    RawGNSSSatData_RawGNSSSatDataType_RawGNSSSatDataType_MIN;
  static const RawGNSSSatDataType RawGNSSSatDataType_MAX =
    RawGNSSSatData_RawGNSSSatDataType_RawGNSSSatDataType_MAX;
  static const int RawGNSSSatDataType_ARRAYSIZE =
    RawGNSSSatData_RawGNSSSatDataType_RawGNSSSatDataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RawGNSSSatDataType_descriptor() {
    return RawGNSSSatData_RawGNSSSatDataType_descriptor();
  }
  static inline const ::std::string& RawGNSSSatDataType_Name(RawGNSSSatDataType value) {
    return RawGNSSSatData_RawGNSSSatDataType_Name(value);
  }
  static inline bool RawGNSSSatDataType_Parse(const ::std::string& name,
      RawGNSSSatDataType* value) {
    return RawGNSSSatData_RawGNSSSatDataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // required .RawGNSSSatData.RawGNSSSatDataType rawGNSSSatDataType = 2;
  bool has_rawgnsssatdatatype() const;
  void clear_rawgnsssatdatatype();
  static const int kRawGNSSSatDataTypeFieldNumber = 2;
  ::RawGNSSSatData_RawGNSSSatDataType rawgnsssatdatatype() const;
  void set_rawgnsssatdatatype(::RawGNSSSatData_RawGNSSSatDataType value);

  // optional bytes rawData = 3;
  bool has_rawdata() const;
  void clear_rawdata();
  static const int kRawDataFieldNumber = 3;
  const ::std::string& rawdata() const;
  void set_rawdata(const ::std::string& value);
  void set_rawdata(const char* value);
  void set_rawdata(const void* value, size_t size);
  ::std::string* mutable_rawdata();
  ::std::string* release_rawdata();
  void set_allocated_rawdata(::std::string* rawdata);

  // @@protoc_insertion_point(class_scope:RawGNSSSatData)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_rawgnsssatdatatype();
  inline void clear_has_rawgnsssatdatatype();
  inline void set_has_rawdata();
  inline void clear_has_rawdata();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  ::google::protobuf::internal::ArenaStringPtr rawdata_;
  int rawgnsssatdatatype_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static RawGNSSSatData* default_instance_;
};
// -------------------------------------------------------------------

class PathEvents : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PathEvents) */ {
 public:
  PathEvents();
  virtual ~PathEvents();

  PathEvents(const PathEvents& from);

  inline PathEvents& operator=(const PathEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathEvents& default_instance();

  void Swap(PathEvents* other);

  // implements Message ----------------------------------------------

  inline PathEvents* New() const { return New(NULL); }

  PathEvents* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PathEvents& from);
  void MergeFrom(const PathEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PathEvents* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .VehicleStatus vehicleStatus = 1;
  int vehiclestatus_size() const;
  void clear_vehiclestatus();
  static const int kVehicleStatusFieldNumber = 1;
  const ::VehicleStatus& vehiclestatus(int index) const;
  ::VehicleStatus* mutable_vehiclestatus(int index);
  ::VehicleStatus* add_vehiclestatus();
  ::google::protobuf::RepeatedPtrField< ::VehicleStatus >*
      mutable_vehiclestatus();
  const ::google::protobuf::RepeatedPtrField< ::VehicleStatus >&
      vehiclestatus() const;

  // repeated .VehicleDynamics vehicleDynamics = 2;
  int vehicledynamics_size() const;
  void clear_vehicledynamics();
  static const int kVehicleDynamicsFieldNumber = 2;
  const ::VehicleDynamics& vehicledynamics(int index) const;
  ::VehicleDynamics* mutable_vehicledynamics(int index);
  ::VehicleDynamics* add_vehicledynamics();
  ::google::protobuf::RepeatedPtrField< ::VehicleDynamics >*
      mutable_vehicledynamics();
  const ::google::protobuf::RepeatedPtrField< ::VehicleDynamics >&
      vehicledynamics() const;

  // repeated .SignRecognition signRecognition = 3;
  int signrecognition_size() const;
  void clear_signrecognition();
  static const int kSignRecognitionFieldNumber = 3;
  const ::SignRecognition& signrecognition(int index) const;
  ::SignRecognition* mutable_signrecognition(int index);
  ::SignRecognition* add_signrecognition();
  ::google::protobuf::RepeatedPtrField< ::SignRecognition >*
      mutable_signrecognition();
  const ::google::protobuf::RepeatedPtrField< ::SignRecognition >&
      signrecognition() const;

  // repeated .LaneBoundaryRecognition laneBoundaryRecognition = 4;
  int laneboundaryrecognition_size() const;
  void clear_laneboundaryrecognition();
  static const int kLaneBoundaryRecognitionFieldNumber = 4;
  const ::LaneBoundaryRecognition& laneboundaryrecognition(int index) const;
  ::LaneBoundaryRecognition* mutable_laneboundaryrecognition(int index);
  ::LaneBoundaryRecognition* add_laneboundaryrecognition();
  ::google::protobuf::RepeatedPtrField< ::LaneBoundaryRecognition >*
      mutable_laneboundaryrecognition();
  const ::google::protobuf::RepeatedPtrField< ::LaneBoundaryRecognition >&
      laneboundaryrecognition() const;

  // repeated .ExceptionalVehicleState exceptionalVehicleState = 5;
  int exceptionalvehiclestate_size() const;
  void clear_exceptionalvehiclestate();
  static const int kExceptionalVehicleStateFieldNumber = 5;
  const ::ExceptionalVehicleState& exceptionalvehiclestate(int index) const;
  ::ExceptionalVehicleState* mutable_exceptionalvehiclestate(int index);
  ::ExceptionalVehicleState* add_exceptionalvehiclestate();
  ::google::protobuf::RepeatedPtrField< ::ExceptionalVehicleState >*
      mutable_exceptionalvehiclestate();
  const ::google::protobuf::RepeatedPtrField< ::ExceptionalVehicleState >&
      exceptionalvehiclestate() const;

  // repeated .ProprietaryInfo proprietaryInfo = 6;
  int proprietaryinfo_size() const;
  void clear_proprietaryinfo();
  static const int kProprietaryInfoFieldNumber = 6;
  const ::ProprietaryInfo& proprietaryinfo(int index) const;
  ::ProprietaryInfo* mutable_proprietaryinfo(int index);
  ::ProprietaryInfo* add_proprietaryinfo();
  ::google::protobuf::RepeatedPtrField< ::ProprietaryInfo >*
      mutable_proprietaryinfo();
  const ::google::protobuf::RepeatedPtrField< ::ProprietaryInfo >&
      proprietaryinfo() const;

  // repeated .EnvironmentStatus environmentStatus = 7;
  int environmentstatus_size() const;
  void clear_environmentstatus();
  static const int kEnvironmentStatusFieldNumber = 7;
  const ::EnvironmentStatus& environmentstatus(int index) const;
  ::EnvironmentStatus* mutable_environmentstatus(int index);
  ::EnvironmentStatus* add_environmentstatus();
  ::google::protobuf::RepeatedPtrField< ::EnvironmentStatus >*
      mutable_environmentstatus();
  const ::google::protobuf::RepeatedPtrField< ::EnvironmentStatus >&
      environmentstatus() const;

  // repeated .ObjectDetection objectDetection = 8;
  int objectdetection_size() const;
  void clear_objectdetection();
  static const int kObjectDetectionFieldNumber = 8;
  const ::ObjectDetection& objectdetection(int index) const;
  ::ObjectDetection* mutable_objectdetection(int index);
  ::ObjectDetection* add_objectdetection();
  ::google::protobuf::RepeatedPtrField< ::ObjectDetection >*
      mutable_objectdetection();
  const ::google::protobuf::RepeatedPtrField< ::ObjectDetection >&
      objectdetection() const;

  // repeated .ADServiceAndSensorState adServiceAndSensorState = 9;
  int adserviceandsensorstate_size() const;
  void clear_adserviceandsensorstate();
  static const int kAdServiceAndSensorStateFieldNumber = 9;
  const ::ADServiceAndSensorState& adserviceandsensorstate(int index) const;
  ::ADServiceAndSensorState* mutable_adserviceandsensorstate(int index);
  ::ADServiceAndSensorState* add_adserviceandsensorstate();
  ::google::protobuf::RepeatedPtrField< ::ADServiceAndSensorState >*
      mutable_adserviceandsensorstate();
  const ::google::protobuf::RepeatedPtrField< ::ADServiceAndSensorState >&
      adserviceandsensorstate() const;

  // repeated .EgoMotion egoMotion = 1000;
  int egomotion_size() const;
  void clear_egomotion();
  static const int kEgoMotionFieldNumber = 1000;
  const ::EgoMotion& egomotion(int index) const;
  ::EgoMotion* mutable_egomotion(int index);
  ::EgoMotion* add_egomotion();
  ::google::protobuf::RepeatedPtrField< ::EgoMotion >*
      mutable_egomotion();
  const ::google::protobuf::RepeatedPtrField< ::EgoMotion >&
      egomotion() const;

  // repeated .RawGNSSSatData rawGNSSSatData = 1001;
  int rawgnsssatdata_size() const;
  void clear_rawgnsssatdata();
  static const int kRawGNSSSatDataFieldNumber = 1001;
  const ::RawGNSSSatData& rawgnsssatdata(int index) const;
  ::RawGNSSSatData* mutable_rawgnsssatdata(int index);
  ::RawGNSSSatData* add_rawgnsssatdata();
  ::google::protobuf::RepeatedPtrField< ::RawGNSSSatData >*
      mutable_rawgnsssatdata();
  const ::google::protobuf::RepeatedPtrField< ::RawGNSSSatData >&
      rawgnsssatdata() const;

  // @@protoc_insertion_point(class_scope:PathEvents)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::VehicleStatus > vehiclestatus_;
  ::google::protobuf::RepeatedPtrField< ::VehicleDynamics > vehicledynamics_;
  ::google::protobuf::RepeatedPtrField< ::SignRecognition > signrecognition_;
  ::google::protobuf::RepeatedPtrField< ::LaneBoundaryRecognition > laneboundaryrecognition_;
  ::google::protobuf::RepeatedPtrField< ::ExceptionalVehicleState > exceptionalvehiclestate_;
  ::google::protobuf::RepeatedPtrField< ::ProprietaryInfo > proprietaryinfo_;
  ::google::protobuf::RepeatedPtrField< ::EnvironmentStatus > environmentstatus_;
  ::google::protobuf::RepeatedPtrField< ::ObjectDetection > objectdetection_;
  ::google::protobuf::RepeatedPtrField< ::ADServiceAndSensorState > adserviceandsensorstate_;
  ::google::protobuf::RepeatedPtrField< ::EgoMotion > egomotion_;
  ::google::protobuf::RepeatedPtrField< ::RawGNSSSatData > rawgnsssatdata_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static PathEvents* default_instance_;
};
// -------------------------------------------------------------------

class MediaContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MediaContainer) */ {
 public:
  MediaContainer();
  virtual ~MediaContainer();

  MediaContainer(const MediaContainer& from);

  inline MediaContainer& operator=(const MediaContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaContainer& default_instance();

  void Swap(MediaContainer* other);

  // implements Message ----------------------------------------------

  inline MediaContainer* New() const { return New(NULL); }

  MediaContainer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaContainer& from);
  void MergeFrom(const MediaContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MediaContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MediaContainer_MediaTypeEnum MediaTypeEnum;
  static const MediaTypeEnum OTHER =
    MediaContainer_MediaTypeEnum_OTHER;
  static const MediaTypeEnum IMAGE =
    MediaContainer_MediaTypeEnum_IMAGE;
  static const MediaTypeEnum VIDEO =
    MediaContainer_MediaTypeEnum_VIDEO;
  static const MediaTypeEnum AUDIO =
    MediaContainer_MediaTypeEnum_AUDIO;
  static inline bool MediaTypeEnum_IsValid(int value) {
    return MediaContainer_MediaTypeEnum_IsValid(value);
  }
  static const MediaTypeEnum MediaTypeEnum_MIN =
    MediaContainer_MediaTypeEnum_MediaTypeEnum_MIN;
  static const MediaTypeEnum MediaTypeEnum_MAX =
    MediaContainer_MediaTypeEnum_MediaTypeEnum_MAX;
  static const int MediaTypeEnum_ARRAYSIZE =
    MediaContainer_MediaTypeEnum_MediaTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MediaTypeEnum_descriptor() {
    return MediaContainer_MediaTypeEnum_descriptor();
  }
  static inline const ::std::string& MediaTypeEnum_Name(MediaTypeEnum value) {
    return MediaContainer_MediaTypeEnum_Name(value);
  }
  static inline bool MediaTypeEnum_Parse(const ::std::string& name,
      MediaTypeEnum* value) {
    return MediaContainer_MediaTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int64 timeStampUTC_ms = 1;
  bool has_timestamputc_ms() const;
  void clear_timestamputc_ms();
  static const int kTimeStampUTCMsFieldNumber = 1;
  ::google::protobuf::int64 timestamputc_ms() const;
  void set_timestamputc_ms(::google::protobuf::int64 value);

  // required .MediaContainer.MediaTypeEnum mediaType = 2;
  bool has_mediatype() const;
  void clear_mediatype();
  static const int kMediaTypeFieldNumber = 2;
  ::MediaContainer_MediaTypeEnum mediatype() const;
  void set_mediatype(::MediaContainer_MediaTypeEnum value);

  // required string mediaFormat = 3;
  bool has_mediaformat() const;
  void clear_mediaformat();
  static const int kMediaFormatFieldNumber = 3;
  const ::std::string& mediaformat() const;
  void set_mediaformat(const ::std::string& value);
  void set_mediaformat(const char* value);
  void set_mediaformat(const char* value, size_t size);
  ::std::string* mutable_mediaformat();
  ::std::string* release_mediaformat();
  void set_allocated_mediaformat(::std::string* mediaformat);

  // required bytes mediaContent = 4;
  bool has_mediacontent() const;
  void clear_mediacontent();
  static const int kMediaContentFieldNumber = 4;
  const ::std::string& mediacontent() const;
  void set_mediacontent(const ::std::string& value);
  void set_mediacontent(const char* value);
  void set_mediacontent(const void* value, size_t size);
  ::std::string* mutable_mediacontent();
  ::std::string* release_mediacontent();
  void set_allocated_mediacontent(::std::string* mediacontent);

  // optional int64 mediaID = 5;
  bool has_mediaid() const;
  void clear_mediaid();
  static const int kMediaIDFieldNumber = 5;
  ::google::protobuf::int64 mediaid() const;
  void set_mediaid(::google::protobuf::int64 value);

  // optional .PositionOffset sensorOffset = 6;
  bool has_sensoroffset() const;
  void clear_sensoroffset();
  static const int kSensorOffsetFieldNumber = 6;
  const ::PositionOffset& sensoroffset() const;
  ::PositionOffset* mutable_sensoroffset();
  ::PositionOffset* release_sensoroffset();
  void set_allocated_sensoroffset(::PositionOffset* sensoroffset);

  // optional .Vector3D sensorDirection = 7;
  bool has_sensordirection() const;
  void clear_sensordirection();
  static const int kSensorDirectionFieldNumber = 7;
  const ::Vector3D& sensordirection() const;
  ::Vector3D* mutable_sensordirection();
  ::Vector3D* release_sensordirection();
  void set_allocated_sensordirection(::Vector3D* sensordirection);

  // optional int32 duration_s = 8;
  bool has_duration_s() const;
  void clear_duration_s();
  static const int kDurationSFieldNumber = 8;
  ::google::protobuf::int32 duration_s() const;
  void set_duration_s(::google::protobuf::int32 value);

  // optional double verticalViewingAngle_deg = 9;
  bool has_verticalviewingangle_deg() const;
  void clear_verticalviewingangle_deg();
  static const int kVerticalViewingAngleDegFieldNumber = 9;
  double verticalviewingangle_deg() const;
  void set_verticalviewingangle_deg(double value);

  // optional double horizontalViewingAngle_deg = 10;
  bool has_horizontalviewingangle_deg() const;
  void clear_horizontalviewingangle_deg();
  static const int kHorizontalViewingAngleDegFieldNumber = 10;
  double horizontalviewingangle_deg() const;
  void set_horizontalviewingangle_deg(double value);

  // @@protoc_insertion_point(class_scope:MediaContainer)
 private:
  inline void set_has_timestamputc_ms();
  inline void clear_has_timestamputc_ms();
  inline void set_has_mediatype();
  inline void clear_has_mediatype();
  inline void set_has_mediaformat();
  inline void clear_has_mediaformat();
  inline void set_has_mediacontent();
  inline void clear_has_mediacontent();
  inline void set_has_mediaid();
  inline void clear_has_mediaid();
  inline void set_has_sensoroffset();
  inline void clear_has_sensoroffset();
  inline void set_has_sensordirection();
  inline void clear_has_sensordirection();
  inline void set_has_duration_s();
  inline void clear_has_duration_s();
  inline void set_has_verticalviewingangle_deg();
  inline void clear_has_verticalviewingangle_deg();
  inline void set_has_horizontalviewingangle_deg();
  inline void clear_has_horizontalviewingangle_deg();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamputc_ms_;
  ::google::protobuf::internal::ArenaStringPtr mediaformat_;
  ::google::protobuf::internal::ArenaStringPtr mediacontent_;
  ::google::protobuf::int64 mediaid_;
  int mediatype_;
  ::google::protobuf::int32 duration_s_;
  ::PositionOffset* sensoroffset_;
  ::Vector3D* sensordirection_;
  double verticalviewingangle_deg_;
  double horizontalviewingangle_deg_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static MediaContainer* default_instance_;
};
// -------------------------------------------------------------------

class PathMedia : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PathMedia) */ {
 public:
  PathMedia();
  virtual ~PathMedia();

  PathMedia(const PathMedia& from);

  inline PathMedia& operator=(const PathMedia& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathMedia& default_instance();

  void Swap(PathMedia* other);

  // implements Message ----------------------------------------------

  inline PathMedia* New() const { return New(NULL); }

  PathMedia* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PathMedia& from);
  void MergeFrom(const PathMedia& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PathMedia* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MediaContainer mediaContainer = 1;
  int mediacontainer_size() const;
  void clear_mediacontainer();
  static const int kMediaContainerFieldNumber = 1;
  const ::MediaContainer& mediacontainer(int index) const;
  ::MediaContainer* mutable_mediacontainer(int index);
  ::MediaContainer* add_mediacontainer();
  ::google::protobuf::RepeatedPtrField< ::MediaContainer >*
      mutable_mediacontainer();
  const ::google::protobuf::RepeatedPtrField< ::MediaContainer >&
      mediacontainer() const;

  // @@protoc_insertion_point(class_scope:PathMedia)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MediaContainer > mediacontainer_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static PathMedia* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Envelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  const ::Envelope& envelope() const;
  ::Envelope* mutable_envelope();
  ::Envelope* release_envelope();
  void set_allocated_envelope(::Envelope* envelope);

  // required .Path path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::Path& path() const;
  ::Path* mutable_path();
  ::Path* release_path();
  void set_allocated_path(::Path* path);

  // optional .PathEvents pathEvents = 3;
  bool has_pathevents() const;
  void clear_pathevents();
  static const int kPathEventsFieldNumber = 3;
  const ::PathEvents& pathevents() const;
  ::PathEvents* mutable_pathevents();
  ::PathEvents* release_pathevents();
  void set_allocated_pathevents(::PathEvents* pathevents);

  // optional .PathMedia pathMedia = 4;
  bool has_pathmedia() const;
  void clear_pathmedia();
  static const int kPathMediaFieldNumber = 4;
  const ::PathMedia& pathmedia() const;
  ::PathMedia* mutable_pathmedia();
  ::PathMedia* release_pathmedia();
  void set_allocated_pathmedia(::PathMedia* pathmedia);

  // @@protoc_insertion_point(class_scope:Message)
 private:
  inline void set_has_envelope();
  inline void clear_has_envelope();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_pathevents();
  inline void clear_has_pathevents();
  inline void set_has_pathmedia();
  inline void clear_has_pathmedia();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Envelope* envelope_;
  ::Path* path_;
  ::PathEvents* pathevents_;
  ::PathMedia* pathmedia_;
  friend void  protobuf_AddDesc_sensoris_2eproto();
  friend void protobuf_AssignDesc_sensoris_2eproto();
  friend void protobuf_ShutdownFile_sensoris_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// KeyValuePairString

// required string key = 1;
inline bool KeyValuePairString::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValuePairString::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValuePairString::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValuePairString::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& KeyValuePairString::key() const {
  // @@protoc_insertion_point(field_get:KeyValuePairString.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePairString::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyValuePairString.key)
}
inline void KeyValuePairString::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyValuePairString.key)
}
inline void KeyValuePairString::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyValuePairString.key)
}
inline ::std::string* KeyValuePairString::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:KeyValuePairString.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePairString::release_key() {
  // @@protoc_insertion_point(field_release:KeyValuePairString.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePairString::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:KeyValuePairString.key)
}

// required string value = 2;
inline bool KeyValuePairString::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValuePairString::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValuePairString::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyValuePairString::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& KeyValuePairString::value() const {
  // @@protoc_insertion_point(field_get:KeyValuePairString.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePairString::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyValuePairString.value)
}
inline void KeyValuePairString::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyValuePairString.value)
}
inline void KeyValuePairString::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyValuePairString.value)
}
inline ::std::string* KeyValuePairString::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:KeyValuePairString.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePairString::release_value() {
  // @@protoc_insertion_point(field_release:KeyValuePairString.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePairString::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:KeyValuePairString.value)
}

// -------------------------------------------------------------------

// Vector3D

// required double longitudinalValue = 1;
inline bool Vector3D::has_longitudinalvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3D::set_has_longitudinalvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3D::clear_has_longitudinalvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3D::clear_longitudinalvalue() {
  longitudinalvalue_ = 0;
  clear_has_longitudinalvalue();
}
inline double Vector3D::longitudinalvalue() const {
  // @@protoc_insertion_point(field_get:Vector3D.longitudinalValue)
  return longitudinalvalue_;
}
inline void Vector3D::set_longitudinalvalue(double value) {
  set_has_longitudinalvalue();
  longitudinalvalue_ = value;
  // @@protoc_insertion_point(field_set:Vector3D.longitudinalValue)
}

// required double lateralValue = 2;
inline bool Vector3D::has_lateralvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3D::set_has_lateralvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3D::clear_has_lateralvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3D::clear_lateralvalue() {
  lateralvalue_ = 0;
  clear_has_lateralvalue();
}
inline double Vector3D::lateralvalue() const {
  // @@protoc_insertion_point(field_get:Vector3D.lateralValue)
  return lateralvalue_;
}
inline void Vector3D::set_lateralvalue(double value) {
  set_has_lateralvalue();
  lateralvalue_ = value;
  // @@protoc_insertion_point(field_set:Vector3D.lateralValue)
}

// required double verticalValue = 3;
inline bool Vector3D::has_verticalvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3D::set_has_verticalvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3D::clear_has_verticalvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3D::clear_verticalvalue() {
  verticalvalue_ = 0;
  clear_has_verticalvalue();
}
inline double Vector3D::verticalvalue() const {
  // @@protoc_insertion_point(field_get:Vector3D.verticalValue)
  return verticalvalue_;
}
inline void Vector3D::set_verticalvalue(double value) {
  set_has_verticalvalue();
  verticalvalue_ = value;
  // @@protoc_insertion_point(field_set:Vector3D.verticalValue)
}

// optional double longitudinalAccuracy = 4;
inline bool Vector3D::has_longitudinalaccuracy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vector3D::set_has_longitudinalaccuracy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vector3D::clear_has_longitudinalaccuracy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vector3D::clear_longitudinalaccuracy() {
  longitudinalaccuracy_ = 0;
  clear_has_longitudinalaccuracy();
}
inline double Vector3D::longitudinalaccuracy() const {
  // @@protoc_insertion_point(field_get:Vector3D.longitudinalAccuracy)
  return longitudinalaccuracy_;
}
inline void Vector3D::set_longitudinalaccuracy(double value) {
  set_has_longitudinalaccuracy();
  longitudinalaccuracy_ = value;
  // @@protoc_insertion_point(field_set:Vector3D.longitudinalAccuracy)
}

// optional double lateralAccuary = 5;
inline bool Vector3D::has_lateralaccuary() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Vector3D::set_has_lateralaccuary() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Vector3D::clear_has_lateralaccuary() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Vector3D::clear_lateralaccuary() {
  lateralaccuary_ = 0;
  clear_has_lateralaccuary();
}
inline double Vector3D::lateralaccuary() const {
  // @@protoc_insertion_point(field_get:Vector3D.lateralAccuary)
  return lateralaccuary_;
}
inline void Vector3D::set_lateralaccuary(double value) {
  set_has_lateralaccuary();
  lateralaccuary_ = value;
  // @@protoc_insertion_point(field_set:Vector3D.lateralAccuary)
}

// optional double verticalAccuracy = 6;
inline bool Vector3D::has_verticalaccuracy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Vector3D::set_has_verticalaccuracy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Vector3D::clear_has_verticalaccuracy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Vector3D::clear_verticalaccuracy() {
  verticalaccuracy_ = 0;
  clear_has_verticalaccuracy();
}
inline double Vector3D::verticalaccuracy() const {
  // @@protoc_insertion_point(field_get:Vector3D.verticalAccuracy)
  return verticalaccuracy_;
}
inline void Vector3D::set_verticalaccuracy(double value) {
  set_has_verticalaccuracy();
  verticalaccuracy_ = value;
  // @@protoc_insertion_point(field_set:Vector3D.verticalAccuracy)
}

// -------------------------------------------------------------------

// VehicleMetaData

// optional .VehicleMetaData.VehicleTypeGenericEnum vehicleTypeGeneric = 1;
inline bool VehicleMetaData::has_vehicletypegeneric() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleMetaData::set_has_vehicletypegeneric() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleMetaData::clear_has_vehicletypegeneric() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleMetaData::clear_vehicletypegeneric() {
  vehicletypegeneric_ = 1;
  clear_has_vehicletypegeneric();
}
inline ::VehicleMetaData_VehicleTypeGenericEnum VehicleMetaData::vehicletypegeneric() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.vehicleTypeGeneric)
  return static_cast< ::VehicleMetaData_VehicleTypeGenericEnum >(vehicletypegeneric_);
}
inline void VehicleMetaData::set_vehicletypegeneric(::VehicleMetaData_VehicleTypeGenericEnum value) {
  assert(::VehicleMetaData_VehicleTypeGenericEnum_IsValid(value));
  set_has_vehicletypegeneric();
  vehicletypegeneric_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.vehicleTypeGeneric)
}

// repeated .KeyValuePairString vehicleSpecificMetaData = 2;
inline int VehicleMetaData::vehiclespecificmetadata_size() const {
  return vehiclespecificmetadata_.size();
}
inline void VehicleMetaData::clear_vehiclespecificmetadata() {
  vehiclespecificmetadata_.Clear();
}
inline const ::KeyValuePairString& VehicleMetaData::vehiclespecificmetadata(int index) const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.vehicleSpecificMetaData)
  return vehiclespecificmetadata_.Get(index);
}
inline ::KeyValuePairString* VehicleMetaData::mutable_vehiclespecificmetadata(int index) {
  // @@protoc_insertion_point(field_mutable:VehicleMetaData.vehicleSpecificMetaData)
  return vehiclespecificmetadata_.Mutable(index);
}
inline ::KeyValuePairString* VehicleMetaData::add_vehiclespecificmetadata() {
  // @@protoc_insertion_point(field_add:VehicleMetaData.vehicleSpecificMetaData)
  return vehiclespecificmetadata_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValuePairString >*
VehicleMetaData::mutable_vehiclespecificmetadata() {
  // @@protoc_insertion_point(field_mutable_list:VehicleMetaData.vehicleSpecificMetaData)
  return &vehiclespecificmetadata_;
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValuePairString >&
VehicleMetaData::vehiclespecificmetadata() const {
  // @@protoc_insertion_point(field_list:VehicleMetaData.vehicleSpecificMetaData)
  return vehiclespecificmetadata_;
}

// required double vehicleReferencePointDeltaAboveGround_m = 3;
inline bool VehicleMetaData::has_vehiclereferencepointdeltaaboveground_m() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleMetaData::set_has_vehiclereferencepointdeltaaboveground_m() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleMetaData::clear_has_vehiclereferencepointdeltaaboveground_m() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleMetaData::clear_vehiclereferencepointdeltaaboveground_m() {
  vehiclereferencepointdeltaaboveground_m_ = 0;
  clear_has_vehiclereferencepointdeltaaboveground_m();
}
inline double VehicleMetaData::vehiclereferencepointdeltaaboveground_m() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.vehicleReferencePointDeltaAboveGround_m)
  return vehiclereferencepointdeltaaboveground_m_;
}
inline void VehicleMetaData::set_vehiclereferencepointdeltaaboveground_m(double value) {
  set_has_vehiclereferencepointdeltaaboveground_m();
  vehiclereferencepointdeltaaboveground_m_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.vehicleReferencePointDeltaAboveGround_m)
}

// optional double curvatureAccuracy_1pm = 4 [deprecated = true];
inline bool VehicleMetaData::has_curvatureaccuracy_1pm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleMetaData::set_has_curvatureaccuracy_1pm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleMetaData::clear_has_curvatureaccuracy_1pm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleMetaData::clear_curvatureaccuracy_1pm() {
  curvatureaccuracy_1pm_ = 0;
  clear_has_curvatureaccuracy_1pm();
}
inline double VehicleMetaData::curvatureaccuracy_1pm() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.curvatureAccuracy_1pm)
  return curvatureaccuracy_1pm_;
}
inline void VehicleMetaData::set_curvatureaccuracy_1pm(double value) {
  set_has_curvatureaccuracy_1pm();
  curvatureaccuracy_1pm_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.curvatureAccuracy_1pm)
}

// optional double slopeAccuracy_percent = 5 [deprecated = true];
inline bool VehicleMetaData::has_slopeaccuracy_percent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleMetaData::set_has_slopeaccuracy_percent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleMetaData::clear_has_slopeaccuracy_percent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleMetaData::clear_slopeaccuracy_percent() {
  slopeaccuracy_percent_ = 0;
  clear_has_slopeaccuracy_percent();
}
inline double VehicleMetaData::slopeaccuracy_percent() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.slopeAccuracy_percent)
  return slopeaccuracy_percent_;
}
inline void VehicleMetaData::set_slopeaccuracy_percent(double value) {
  set_has_slopeaccuracy_percent();
  slopeaccuracy_percent_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.slopeAccuracy_percent)
}

// optional double vehicleLength_m = 6;
inline bool VehicleMetaData::has_vehiclelength_m() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleMetaData::set_has_vehiclelength_m() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleMetaData::clear_has_vehiclelength_m() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleMetaData::clear_vehiclelength_m() {
  vehiclelength_m_ = 0;
  clear_has_vehiclelength_m();
}
inline double VehicleMetaData::vehiclelength_m() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.vehicleLength_m)
  return vehiclelength_m_;
}
inline void VehicleMetaData::set_vehiclelength_m(double value) {
  set_has_vehiclelength_m();
  vehiclelength_m_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.vehicleLength_m)
}

// optional double vehicleWidth_m = 7;
inline bool VehicleMetaData::has_vehiclewidth_m() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleMetaData::set_has_vehiclewidth_m() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleMetaData::clear_has_vehiclewidth_m() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleMetaData::clear_vehiclewidth_m() {
  vehiclewidth_m_ = 0;
  clear_has_vehiclewidth_m();
}
inline double VehicleMetaData::vehiclewidth_m() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.vehicleWidth_m)
  return vehiclewidth_m_;
}
inline void VehicleMetaData::set_vehiclewidth_m(double value) {
  set_has_vehiclewidth_m();
  vehiclewidth_m_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.vehicleWidth_m)
}

// optional double vehicleHeight_m = 8;
inline bool VehicleMetaData::has_vehicleheight_m() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleMetaData::set_has_vehicleheight_m() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleMetaData::clear_has_vehicleheight_m() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleMetaData::clear_vehicleheight_m() {
  vehicleheight_m_ = 0;
  clear_has_vehicleheight_m();
}
inline double VehicleMetaData::vehicleheight_m() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.vehicleHeight_m)
  return vehicleheight_m_;
}
inline void VehicleMetaData::set_vehicleheight_m(double value) {
  set_has_vehicleheight_m();
  vehicleheight_m_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.vehicleHeight_m)
}

// optional double primaryFuelTankVolume = 9;
inline bool VehicleMetaData::has_primaryfueltankvolume() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleMetaData::set_has_primaryfueltankvolume() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleMetaData::clear_has_primaryfueltankvolume() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleMetaData::clear_primaryfueltankvolume() {
  primaryfueltankvolume_ = 0;
  clear_has_primaryfueltankvolume();
}
inline double VehicleMetaData::primaryfueltankvolume() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.primaryFuelTankVolume)
  return primaryfueltankvolume_;
}
inline void VehicleMetaData::set_primaryfueltankvolume(double value) {
  set_has_primaryfueltankvolume();
  primaryfueltankvolume_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.primaryFuelTankVolume)
}

// optional .VehicleMetaData.FuelTypeEnum primaryFuelType = 10;
inline bool VehicleMetaData::has_primaryfueltype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VehicleMetaData::set_has_primaryfueltype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VehicleMetaData::clear_has_primaryfueltype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VehicleMetaData::clear_primaryfueltype() {
  primaryfueltype_ = 1;
  clear_has_primaryfueltype();
}
inline ::VehicleMetaData_FuelTypeEnum VehicleMetaData::primaryfueltype() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.primaryFuelType)
  return static_cast< ::VehicleMetaData_FuelTypeEnum >(primaryfueltype_);
}
inline void VehicleMetaData::set_primaryfueltype(::VehicleMetaData_FuelTypeEnum value) {
  assert(::VehicleMetaData_FuelTypeEnum_IsValid(value));
  set_has_primaryfueltype();
  primaryfueltype_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.primaryFuelType)
}

// optional double secondaryFuelTankVolume = 11;
inline bool VehicleMetaData::has_secondaryfueltankvolume() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VehicleMetaData::set_has_secondaryfueltankvolume() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VehicleMetaData::clear_has_secondaryfueltankvolume() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VehicleMetaData::clear_secondaryfueltankvolume() {
  secondaryfueltankvolume_ = 0;
  clear_has_secondaryfueltankvolume();
}
inline double VehicleMetaData::secondaryfueltankvolume() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.secondaryFuelTankVolume)
  return secondaryfueltankvolume_;
}
inline void VehicleMetaData::set_secondaryfueltankvolume(double value) {
  set_has_secondaryfueltankvolume();
  secondaryfueltankvolume_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.secondaryFuelTankVolume)
}

// optional .VehicleMetaData.FuelTypeEnum secondaryFuelType = 12;
inline bool VehicleMetaData::has_secondaryfueltype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VehicleMetaData::set_has_secondaryfueltype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VehicleMetaData::clear_has_secondaryfueltype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VehicleMetaData::clear_secondaryfueltype() {
  secondaryfueltype_ = 1;
  clear_has_secondaryfueltype();
}
inline ::VehicleMetaData_FuelTypeEnum VehicleMetaData::secondaryfueltype() const {
  // @@protoc_insertion_point(field_get:VehicleMetaData.secondaryFuelType)
  return static_cast< ::VehicleMetaData_FuelTypeEnum >(secondaryfueltype_);
}
inline void VehicleMetaData::set_secondaryfueltype(::VehicleMetaData_FuelTypeEnum value) {
  assert(::VehicleMetaData_FuelTypeEnum_IsValid(value));
  set_has_secondaryfueltype();
  secondaryfueltype_ = value;
  // @@protoc_insertion_point(field_set:VehicleMetaData.secondaryFuelType)
}

// -------------------------------------------------------------------

// Envelope

// required string version = 1;
inline bool Envelope::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Envelope::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Envelope::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Envelope::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Envelope::version() const {
  // @@protoc_insertion_point(field_get:Envelope.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Envelope::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Envelope.version)
}
inline void Envelope::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Envelope.version)
}
inline void Envelope::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Envelope.version)
}
inline ::std::string* Envelope::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:Envelope.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Envelope::release_version() {
  // @@protoc_insertion_point(field_release:Envelope.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Envelope::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:Envelope.version)
}

// required string submitter = 2;
inline bool Envelope::has_submitter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Envelope::set_has_submitter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Envelope::clear_has_submitter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Envelope::clear_submitter() {
  submitter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_submitter();
}
inline const ::std::string& Envelope::submitter() const {
  // @@protoc_insertion_point(field_get:Envelope.submitter)
  return submitter_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Envelope::set_submitter(const ::std::string& value) {
  set_has_submitter();
  submitter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Envelope.submitter)
}
inline void Envelope::set_submitter(const char* value) {
  set_has_submitter();
  submitter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Envelope.submitter)
}
inline void Envelope::set_submitter(const char* value, size_t size) {
  set_has_submitter();
  submitter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Envelope.submitter)
}
inline ::std::string* Envelope::mutable_submitter() {
  set_has_submitter();
  // @@protoc_insertion_point(field_mutable:Envelope.submitter)
  return submitter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Envelope::release_submitter() {
  // @@protoc_insertion_point(field_release:Envelope.submitter)
  clear_has_submitter();
  return submitter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Envelope::set_allocated_submitter(::std::string* submitter) {
  if (submitter != NULL) {
    set_has_submitter();
  } else {
    clear_has_submitter();
  }
  submitter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), submitter);
  // @@protoc_insertion_point(field_set_allocated:Envelope.submitter)
}

// required .VehicleMetaData vehicleMetaData = 3;
inline bool Envelope::has_vehiclemetadata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Envelope::set_has_vehiclemetadata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Envelope::clear_has_vehiclemetadata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Envelope::clear_vehiclemetadata() {
  if (vehiclemetadata_ != NULL) vehiclemetadata_->::VehicleMetaData::Clear();
  clear_has_vehiclemetadata();
}
inline const ::VehicleMetaData& Envelope::vehiclemetadata() const {
  // @@protoc_insertion_point(field_get:Envelope.vehicleMetaData)
  return vehiclemetadata_ != NULL ? *vehiclemetadata_ : *default_instance_->vehiclemetadata_;
}
inline ::VehicleMetaData* Envelope::mutable_vehiclemetadata() {
  set_has_vehiclemetadata();
  if (vehiclemetadata_ == NULL) {
    vehiclemetadata_ = new ::VehicleMetaData;
  }
  // @@protoc_insertion_point(field_mutable:Envelope.vehicleMetaData)
  return vehiclemetadata_;
}
inline ::VehicleMetaData* Envelope::release_vehiclemetadata() {
  // @@protoc_insertion_point(field_release:Envelope.vehicleMetaData)
  clear_has_vehiclemetadata();
  ::VehicleMetaData* temp = vehiclemetadata_;
  vehiclemetadata_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_vehiclemetadata(::VehicleMetaData* vehiclemetadata) {
  delete vehiclemetadata_;
  vehiclemetadata_ = vehiclemetadata;
  if (vehiclemetadata) {
    set_has_vehiclemetadata();
  } else {
    clear_has_vehiclemetadata();
  }
  // @@protoc_insertion_point(field_set_allocated:Envelope.vehicleMetaData)
}

// optional int64 transientVehicleID = 4;
inline bool Envelope::has_transientvehicleid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Envelope::set_has_transientvehicleid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Envelope::clear_has_transientvehicleid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Envelope::clear_transientvehicleid() {
  transientvehicleid_ = GOOGLE_LONGLONG(0);
  clear_has_transientvehicleid();
}
inline ::google::protobuf::int64 Envelope::transientvehicleid() const {
  // @@protoc_insertion_point(field_get:Envelope.transientVehicleID)
  return transientvehicleid_;
}
inline void Envelope::set_transientvehicleid(::google::protobuf::int64 value) {
  set_has_transientvehicleid();
  transientvehicleid_ = value;
  // @@protoc_insertion_point(field_set:Envelope.transientVehicleID)
}

// optional int64 vehicleProfileID = 5;
inline bool Envelope::has_vehicleprofileid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Envelope::set_has_vehicleprofileid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Envelope::clear_has_vehicleprofileid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Envelope::clear_vehicleprofileid() {
  vehicleprofileid_ = GOOGLE_LONGLONG(0);
  clear_has_vehicleprofileid();
}
inline ::google::protobuf::int64 Envelope::vehicleprofileid() const {
  // @@protoc_insertion_point(field_get:Envelope.vehicleProfileID)
  return vehicleprofileid_;
}
inline void Envelope::set_vehicleprofileid(::google::protobuf::int64 value) {
  set_has_vehicleprofileid();
  vehicleprofileid_ = value;
  // @@protoc_insertion_point(field_set:Envelope.vehicleProfileID)
}

// -------------------------------------------------------------------

// PositionEstimate

// required int64 timeStampUTC_ms = 1;
inline bool PositionEstimate::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionEstimate::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionEstimate::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionEstimate::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 PositionEstimate::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void PositionEstimate::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.timeStampUTC_ms)
}

// required .PositionEstimate.PositionTypeEnum positionType = 2;
inline bool PositionEstimate::has_positiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionEstimate::set_has_positiontype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionEstimate::clear_has_positiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionEstimate::clear_positiontype() {
  positiontype_ = 1;
  clear_has_positiontype();
}
inline ::PositionEstimate_PositionTypeEnum PositionEstimate::positiontype() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.positionType)
  return static_cast< ::PositionEstimate_PositionTypeEnum >(positiontype_);
}
inline void PositionEstimate::set_positiontype(::PositionEstimate_PositionTypeEnum value) {
  assert(::PositionEstimate_PositionTypeEnum_IsValid(value));
  set_has_positiontype();
  positiontype_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.positionType)
}

// optional bool interpolatedPoint = 3;
inline bool PositionEstimate::has_interpolatedpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PositionEstimate::set_has_interpolatedpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PositionEstimate::clear_has_interpolatedpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PositionEstimate::clear_interpolatedpoint() {
  interpolatedpoint_ = false;
  clear_has_interpolatedpoint();
}
inline bool PositionEstimate::interpolatedpoint() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.interpolatedPoint)
  return interpolatedpoint_;
}
inline void PositionEstimate::set_interpolatedpoint(bool value) {
  set_has_interpolatedpoint();
  interpolatedpoint_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.interpolatedPoint)
}

// required double longitude_deg = 4;
inline bool PositionEstimate::has_longitude_deg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PositionEstimate::set_has_longitude_deg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PositionEstimate::clear_has_longitude_deg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PositionEstimate::clear_longitude_deg() {
  longitude_deg_ = 0;
  clear_has_longitude_deg();
}
inline double PositionEstimate::longitude_deg() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.longitude_deg)
  return longitude_deg_;
}
inline void PositionEstimate::set_longitude_deg(double value) {
  set_has_longitude_deg();
  longitude_deg_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.longitude_deg)
}

// required double latitude_deg = 5;
inline bool PositionEstimate::has_latitude_deg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PositionEstimate::set_has_latitude_deg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PositionEstimate::clear_has_latitude_deg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PositionEstimate::clear_latitude_deg() {
  latitude_deg_ = 0;
  clear_has_latitude_deg();
}
inline double PositionEstimate::latitude_deg() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.latitude_deg)
  return latitude_deg_;
}
inline void PositionEstimate::set_latitude_deg(double value) {
  set_has_latitude_deg();
  latitude_deg_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.latitude_deg)
}

// required double horizontalAccuracy_m = 6;
inline bool PositionEstimate::has_horizontalaccuracy_m() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PositionEstimate::set_has_horizontalaccuracy_m() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PositionEstimate::clear_has_horizontalaccuracy_m() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PositionEstimate::clear_horizontalaccuracy_m() {
  horizontalaccuracy_m_ = 0;
  clear_has_horizontalaccuracy_m();
}
inline double PositionEstimate::horizontalaccuracy_m() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.horizontalAccuracy_m)
  return horizontalaccuracy_m_;
}
inline void PositionEstimate::set_horizontalaccuracy_m(double value) {
  set_has_horizontalaccuracy_m();
  horizontalaccuracy_m_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.horizontalAccuracy_m)
}

// optional double altitude_m = 7;
inline bool PositionEstimate::has_altitude_m() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PositionEstimate::set_has_altitude_m() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PositionEstimate::clear_has_altitude_m() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PositionEstimate::clear_altitude_m() {
  altitude_m_ = 0;
  clear_has_altitude_m();
}
inline double PositionEstimate::altitude_m() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.altitude_m)
  return altitude_m_;
}
inline void PositionEstimate::set_altitude_m(double value) {
  set_has_altitude_m();
  altitude_m_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.altitude_m)
}

// optional double heading_deg = 8;
inline bool PositionEstimate::has_heading_deg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PositionEstimate::set_has_heading_deg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PositionEstimate::clear_has_heading_deg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PositionEstimate::clear_heading_deg() {
  heading_deg_ = 0;
  clear_has_heading_deg();
}
inline double PositionEstimate::heading_deg() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.heading_deg)
  return heading_deg_;
}
inline void PositionEstimate::set_heading_deg(double value) {
  set_has_heading_deg();
  heading_deg_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.heading_deg)
}

// optional double speed_mps = 9;
inline bool PositionEstimate::has_speed_mps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PositionEstimate::set_has_speed_mps() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PositionEstimate::clear_has_speed_mps() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PositionEstimate::clear_speed_mps() {
  speed_mps_ = 0;
  clear_has_speed_mps();
}
inline double PositionEstimate::speed_mps() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.speed_mps)
  return speed_mps_;
}
inline void PositionEstimate::set_speed_mps(double value) {
  set_has_speed_mps();
  speed_mps_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.speed_mps)
}

// optional double altitudeAccuracy_m = 10;
inline bool PositionEstimate::has_altitudeaccuracy_m() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PositionEstimate::set_has_altitudeaccuracy_m() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PositionEstimate::clear_has_altitudeaccuracy_m() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PositionEstimate::clear_altitudeaccuracy_m() {
  altitudeaccuracy_m_ = 0;
  clear_has_altitudeaccuracy_m();
}
inline double PositionEstimate::altitudeaccuracy_m() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.altitudeAccuracy_m)
  return altitudeaccuracy_m_;
}
inline void PositionEstimate::set_altitudeaccuracy_m(double value) {
  set_has_altitudeaccuracy_m();
  altitudeaccuracy_m_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.altitudeAccuracy_m)
}

// optional double headingAccuracy_deg = 11;
inline bool PositionEstimate::has_headingaccuracy_deg() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PositionEstimate::set_has_headingaccuracy_deg() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PositionEstimate::clear_has_headingaccuracy_deg() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PositionEstimate::clear_headingaccuracy_deg() {
  headingaccuracy_deg_ = 0;
  clear_has_headingaccuracy_deg();
}
inline double PositionEstimate::headingaccuracy_deg() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.headingAccuracy_deg)
  return headingaccuracy_deg_;
}
inline void PositionEstimate::set_headingaccuracy_deg(double value) {
  set_has_headingaccuracy_deg();
  headingaccuracy_deg_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.headingAccuracy_deg)
}

// optional double speedAccuracy_mps = 12;
inline bool PositionEstimate::has_speedaccuracy_mps() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PositionEstimate::set_has_speedaccuracy_mps() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PositionEstimate::clear_has_speedaccuracy_mps() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PositionEstimate::clear_speedaccuracy_mps() {
  speedaccuracy_mps_ = 0;
  clear_has_speedaccuracy_mps();
}
inline double PositionEstimate::speedaccuracy_mps() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.speedAccuracy_mps)
  return speedaccuracy_mps_;
}
inline void PositionEstimate::set_speedaccuracy_mps(double value) {
  set_has_speedaccuracy_mps();
  speedaccuracy_mps_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.speedAccuracy_mps)
}

// optional .PositionEstimate.SpeedDetectionEnum speedDetectionType = 13;
inline bool PositionEstimate::has_speeddetectiontype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PositionEstimate::set_has_speeddetectiontype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PositionEstimate::clear_has_speeddetectiontype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PositionEstimate::clear_speeddetectiontype() {
  speeddetectiontype_ = 1;
  clear_has_speeddetectiontype();
}
inline ::PositionEstimate_SpeedDetectionEnum PositionEstimate::speeddetectiontype() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.speedDetectionType)
  return static_cast< ::PositionEstimate_SpeedDetectionEnum >(speeddetectiontype_);
}
inline void PositionEstimate::set_speeddetectiontype(::PositionEstimate_SpeedDetectionEnum value) {
  assert(::PositionEstimate_SpeedDetectionEnum_IsValid(value));
  set_has_speeddetectiontype();
  speeddetectiontype_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.speedDetectionType)
}

// optional .PositionEstimate.HeadingDetectionEnum headingDetectionType = 14;
inline bool PositionEstimate::has_headingdetectiontype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PositionEstimate::set_has_headingdetectiontype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PositionEstimate::clear_has_headingdetectiontype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PositionEstimate::clear_headingdetectiontype() {
  headingdetectiontype_ = 1;
  clear_has_headingdetectiontype();
}
inline ::PositionEstimate_HeadingDetectionEnum PositionEstimate::headingdetectiontype() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.headingDetectionType)
  return static_cast< ::PositionEstimate_HeadingDetectionEnum >(headingdetectiontype_);
}
inline void PositionEstimate::set_headingdetectiontype(::PositionEstimate_HeadingDetectionEnum value) {
  assert(::PositionEstimate_HeadingDetectionEnum_IsValid(value));
  set_has_headingdetectiontype();
  headingdetectiontype_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.headingDetectionType)
}

// optional .Vector3D vehicleReferencedOrientationVector_deg = 15;
inline bool PositionEstimate::has_vehiclereferencedorientationvector_deg() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PositionEstimate::set_has_vehiclereferencedorientationvector_deg() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PositionEstimate::clear_has_vehiclereferencedorientationvector_deg() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PositionEstimate::clear_vehiclereferencedorientationvector_deg() {
  if (vehiclereferencedorientationvector_deg_ != NULL) vehiclereferencedorientationvector_deg_->::Vector3D::Clear();
  clear_has_vehiclereferencedorientationvector_deg();
}
inline const ::Vector3D& PositionEstimate::vehiclereferencedorientationvector_deg() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.vehicleReferencedOrientationVector_deg)
  return vehiclereferencedorientationvector_deg_ != NULL ? *vehiclereferencedorientationvector_deg_ : *default_instance_->vehiclereferencedorientationvector_deg_;
}
inline ::Vector3D* PositionEstimate::mutable_vehiclereferencedorientationvector_deg() {
  set_has_vehiclereferencedorientationvector_deg();
  if (vehiclereferencedorientationvector_deg_ == NULL) {
    vehiclereferencedorientationvector_deg_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:PositionEstimate.vehicleReferencedOrientationVector_deg)
  return vehiclereferencedorientationvector_deg_;
}
inline ::Vector3D* PositionEstimate::release_vehiclereferencedorientationvector_deg() {
  // @@protoc_insertion_point(field_release:PositionEstimate.vehicleReferencedOrientationVector_deg)
  clear_has_vehiclereferencedorientationvector_deg();
  ::Vector3D* temp = vehiclereferencedorientationvector_deg_;
  vehiclereferencedorientationvector_deg_ = NULL;
  return temp;
}
inline void PositionEstimate::set_allocated_vehiclereferencedorientationvector_deg(::Vector3D* vehiclereferencedorientationvector_deg) {
  delete vehiclereferencedorientationvector_deg_;
  vehiclereferencedorientationvector_deg_ = vehiclereferencedorientationvector_deg;
  if (vehiclereferencedorientationvector_deg) {
    set_has_vehiclereferencedorientationvector_deg();
  } else {
    clear_has_vehiclereferencedorientationvector_deg();
  }
  // @@protoc_insertion_point(field_set_allocated:PositionEstimate.vehicleReferencedOrientationVector_deg)
}

// optional int32 currentLaneEstimate = 16;
inline bool PositionEstimate::has_currentlaneestimate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PositionEstimate::set_has_currentlaneestimate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PositionEstimate::clear_has_currentlaneestimate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PositionEstimate::clear_currentlaneestimate() {
  currentlaneestimate_ = 0;
  clear_has_currentlaneestimate();
}
inline ::google::protobuf::int32 PositionEstimate::currentlaneestimate() const {
  // @@protoc_insertion_point(field_get:PositionEstimate.currentLaneEstimate)
  return currentlaneestimate_;
}
inline void PositionEstimate::set_currentlaneestimate(::google::protobuf::int32 value) {
  set_has_currentlaneestimate();
  currentlaneestimate_ = value;
  // @@protoc_insertion_point(field_set:PositionEstimate.currentLaneEstimate)
}

// -------------------------------------------------------------------

// PathSegment

// repeated .PositionEstimate positionEstimate = 1;
inline int PathSegment::positionestimate_size() const {
  return positionestimate_.size();
}
inline void PathSegment::clear_positionestimate() {
  positionestimate_.Clear();
}
inline const ::PositionEstimate& PathSegment::positionestimate(int index) const {
  // @@protoc_insertion_point(field_get:PathSegment.positionEstimate)
  return positionestimate_.Get(index);
}
inline ::PositionEstimate* PathSegment::mutable_positionestimate(int index) {
  // @@protoc_insertion_point(field_mutable:PathSegment.positionEstimate)
  return positionestimate_.Mutable(index);
}
inline ::PositionEstimate* PathSegment::add_positionestimate() {
  // @@protoc_insertion_point(field_add:PathSegment.positionEstimate)
  return positionestimate_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::PositionEstimate >*
PathSegment::mutable_positionestimate() {
  // @@protoc_insertion_point(field_mutable_list:PathSegment.positionEstimate)
  return &positionestimate_;
}
inline const ::google::protobuf::RepeatedPtrField< ::PositionEstimate >&
PathSegment::positionestimate() const {
  // @@protoc_insertion_point(field_list:PathSegment.positionEstimate)
  return positionestimate_;
}

// -------------------------------------------------------------------

// Path

// repeated .PositionEstimate positionEstimate = 1;
inline int Path::positionestimate_size() const {
  return positionestimate_.size();
}
inline void Path::clear_positionestimate() {
  positionestimate_.Clear();
}
inline const ::PositionEstimate& Path::positionestimate(int index) const {
  // @@protoc_insertion_point(field_get:Path.positionEstimate)
  return positionestimate_.Get(index);
}
inline ::PositionEstimate* Path::mutable_positionestimate(int index) {
  // @@protoc_insertion_point(field_mutable:Path.positionEstimate)
  return positionestimate_.Mutable(index);
}
inline ::PositionEstimate* Path::add_positionestimate() {
  // @@protoc_insertion_point(field_add:Path.positionEstimate)
  return positionestimate_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::PositionEstimate >*
Path::mutable_positionestimate() {
  // @@protoc_insertion_point(field_mutable_list:Path.positionEstimate)
  return &positionestimate_;
}
inline const ::google::protobuf::RepeatedPtrField< ::PositionEstimate >&
Path::positionestimate() const {
  // @@protoc_insertion_point(field_list:Path.positionEstimate)
  return positionestimate_;
}

// repeated .PathSegment positionSegments = 2 [deprecated = true];
inline int Path::positionsegments_size() const {
  return positionsegments_.size();
}
inline void Path::clear_positionsegments() {
  positionsegments_.Clear();
}
inline const ::PathSegment& Path::positionsegments(int index) const {
  // @@protoc_insertion_point(field_get:Path.positionSegments)
  return positionsegments_.Get(index);
}
inline ::PathSegment* Path::mutable_positionsegments(int index) {
  // @@protoc_insertion_point(field_mutable:Path.positionSegments)
  return positionsegments_.Mutable(index);
}
inline ::PathSegment* Path::add_positionsegments() {
  // @@protoc_insertion_point(field_add:Path.positionSegments)
  return positionsegments_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::PathSegment >*
Path::mutable_positionsegments() {
  // @@protoc_insertion_point(field_mutable_list:Path.positionSegments)
  return &positionsegments_;
}
inline const ::google::protobuf::RepeatedPtrField< ::PathSegment >&
Path::positionsegments() const {
  // @@protoc_insertion_point(field_list:Path.positionSegments)
  return positionsegments_;
}

// -------------------------------------------------------------------

// VehicleStatus

// required int64 timeStampUTC_ms = 1;
inline bool VehicleStatus::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleStatus::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleStatus::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleStatus::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 VehicleStatus::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void VehicleStatus::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.timeStampUTC_ms)
}

// optional .VehicleStatus.TransmissionModeEnum transmissionMode = 2;
inline bool VehicleStatus::has_transmissionmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleStatus::set_has_transmissionmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleStatus::clear_has_transmissionmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleStatus::clear_transmissionmode() {
  transmissionmode_ = 1;
  clear_has_transmissionmode();
}
inline ::VehicleStatus_TransmissionModeEnum VehicleStatus::transmissionmode() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.transmissionMode)
  return static_cast< ::VehicleStatus_TransmissionModeEnum >(transmissionmode_);
}
inline void VehicleStatus::set_transmissionmode(::VehicleStatus_TransmissionModeEnum value) {
  assert(::VehicleStatus_TransmissionModeEnum_IsValid(value));
  set_has_transmissionmode();
  transmissionmode_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.transmissionMode)
}

// optional int64 lightStateBitfield = 3;
inline bool VehicleStatus::has_lightstatebitfield() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleStatus::set_has_lightstatebitfield() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleStatus::clear_has_lightstatebitfield() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleStatus::clear_lightstatebitfield() {
  lightstatebitfield_ = GOOGLE_LONGLONG(0);
  clear_has_lightstatebitfield();
}
inline ::google::protobuf::int64 VehicleStatus::lightstatebitfield() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.lightStateBitfield)
  return lightstatebitfield_;
}
inline void VehicleStatus::set_lightstatebitfield(::google::protobuf::int64 value) {
  set_has_lightstatebitfield();
  lightstatebitfield_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.lightStateBitfield)
}

// optional .VehicleStatus.WiperStateEnum wiperState = 4;
inline bool VehicleStatus::has_wiperstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleStatus::set_has_wiperstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleStatus::clear_has_wiperstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleStatus::clear_wiperstate() {
  wiperstate_ = 1;
  clear_has_wiperstate();
}
inline ::VehicleStatus_WiperStateEnum VehicleStatus::wiperstate() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.wiperState)
  return static_cast< ::VehicleStatus_WiperStateEnum >(wiperstate_);
}
inline void VehicleStatus::set_wiperstate(::VehicleStatus_WiperStateEnum value) {
  assert(::VehicleStatus_WiperStateEnum_IsValid(value));
  set_has_wiperstate();
  wiperstate_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.wiperState)
}

// optional double temperatureExternal_cel = 5 [deprecated = true];
inline bool VehicleStatus::has_temperatureexternal_cel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleStatus::set_has_temperatureexternal_cel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleStatus::clear_has_temperatureexternal_cel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleStatus::clear_temperatureexternal_cel() {
  temperatureexternal_cel_ = 0;
  clear_has_temperatureexternal_cel();
}
inline double VehicleStatus::temperatureexternal_cel() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.temperatureExternal_cel)
  return temperatureexternal_cel_;
}
inline void VehicleStatus::set_temperatureexternal_cel(double value) {
  set_has_temperatureexternal_cel();
  temperatureexternal_cel_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.temperatureExternal_cel)
}

// optional int32 wiperSpeed_wpm = 6;
inline bool VehicleStatus::has_wiperspeed_wpm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleStatus::set_has_wiperspeed_wpm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleStatus::clear_has_wiperspeed_wpm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleStatus::clear_wiperspeed_wpm() {
  wiperspeed_wpm_ = 0;
  clear_has_wiperspeed_wpm();
}
inline ::google::protobuf::int32 VehicleStatus::wiperspeed_wpm() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.wiperSpeed_wpm)
  return wiperspeed_wpm_;
}
inline void VehicleStatus::set_wiperspeed_wpm(::google::protobuf::int32 value) {
  set_has_wiperspeed_wpm();
  wiperspeed_wpm_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.wiperSpeed_wpm)
}

// optional int64 driveWheelReference = 7;
inline bool VehicleStatus::has_drivewheelreference() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleStatus::set_has_drivewheelreference() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleStatus::clear_has_drivewheelreference() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleStatus::clear_drivewheelreference() {
  drivewheelreference_ = GOOGLE_LONGLONG(0);
  clear_has_drivewheelreference();
}
inline ::google::protobuf::int64 VehicleStatus::drivewheelreference() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.driveWheelReference)
  return drivewheelreference_;
}
inline void VehicleStatus::set_drivewheelreference(::google::protobuf::int64 value) {
  set_has_drivewheelreference();
  drivewheelreference_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.driveWheelReference)
}

// optional double chassisClearance_m = 8;
inline bool VehicleStatus::has_chassisclearance_m() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleStatus::set_has_chassisclearance_m() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleStatus::clear_has_chassisclearance_m() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleStatus::clear_chassisclearance_m() {
  chassisclearance_m_ = 0;
  clear_has_chassisclearance_m();
}
inline double VehicleStatus::chassisclearance_m() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.chassisClearance_m)
  return chassisclearance_m_;
}
inline void VehicleStatus::set_chassisclearance_m(double value) {
  set_has_chassisclearance_m();
  chassisclearance_m_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.chassisClearance_m)
}

// optional double mileage_km = 9;
inline bool VehicleStatus::has_mileage_km() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleStatus::set_has_mileage_km() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleStatus::clear_has_mileage_km() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleStatus::clear_mileage_km() {
  mileage_km_ = 0;
  clear_has_mileage_km();
}
inline double VehicleStatus::mileage_km() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.mileage_km)
  return mileage_km_;
}
inline void VehicleStatus::set_mileage_km(double value) {
  set_has_mileage_km();
  mileage_km_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.mileage_km)
}

// optional double primaryFuelState = 10;
inline bool VehicleStatus::has_primaryfuelstate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VehicleStatus::set_has_primaryfuelstate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VehicleStatus::clear_has_primaryfuelstate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VehicleStatus::clear_primaryfuelstate() {
  primaryfuelstate_ = 0;
  clear_has_primaryfuelstate();
}
inline double VehicleStatus::primaryfuelstate() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.primaryFuelState)
  return primaryfuelstate_;
}
inline void VehicleStatus::set_primaryfuelstate(double value) {
  set_has_primaryfuelstate();
  primaryfuelstate_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.primaryFuelState)
}

// optional double primaryFuelStateAccuracy = 11;
inline bool VehicleStatus::has_primaryfuelstateaccuracy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VehicleStatus::set_has_primaryfuelstateaccuracy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VehicleStatus::clear_has_primaryfuelstateaccuracy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VehicleStatus::clear_primaryfuelstateaccuracy() {
  primaryfuelstateaccuracy_ = 0;
  clear_has_primaryfuelstateaccuracy();
}
inline double VehicleStatus::primaryfuelstateaccuracy() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.primaryFuelStateAccuracy)
  return primaryfuelstateaccuracy_;
}
inline void VehicleStatus::set_primaryfuelstateaccuracy(double value) {
  set_has_primaryfuelstateaccuracy();
  primaryfuelstateaccuracy_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.primaryFuelStateAccuracy)
}

// optional double estimatedPrimaryRange_km = 12;
inline bool VehicleStatus::has_estimatedprimaryrange_km() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VehicleStatus::set_has_estimatedprimaryrange_km() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VehicleStatus::clear_has_estimatedprimaryrange_km() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VehicleStatus::clear_estimatedprimaryrange_km() {
  estimatedprimaryrange_km_ = 0;
  clear_has_estimatedprimaryrange_km();
}
inline double VehicleStatus::estimatedprimaryrange_km() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.estimatedPrimaryRange_km)
  return estimatedprimaryrange_km_;
}
inline void VehicleStatus::set_estimatedprimaryrange_km(double value) {
  set_has_estimatedprimaryrange_km();
  estimatedprimaryrange_km_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.estimatedPrimaryRange_km)
}

// optional double secondaryFuelState = 13;
inline bool VehicleStatus::has_secondaryfuelstate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VehicleStatus::set_has_secondaryfuelstate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VehicleStatus::clear_has_secondaryfuelstate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VehicleStatus::clear_secondaryfuelstate() {
  secondaryfuelstate_ = 0;
  clear_has_secondaryfuelstate();
}
inline double VehicleStatus::secondaryfuelstate() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.secondaryFuelState)
  return secondaryfuelstate_;
}
inline void VehicleStatus::set_secondaryfuelstate(double value) {
  set_has_secondaryfuelstate();
  secondaryfuelstate_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.secondaryFuelState)
}

// optional double secondaryFuelStateAccuracy = 14;
inline bool VehicleStatus::has_secondaryfuelstateaccuracy() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VehicleStatus::set_has_secondaryfuelstateaccuracy() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VehicleStatus::clear_has_secondaryfuelstateaccuracy() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VehicleStatus::clear_secondaryfuelstateaccuracy() {
  secondaryfuelstateaccuracy_ = 0;
  clear_has_secondaryfuelstateaccuracy();
}
inline double VehicleStatus::secondaryfuelstateaccuracy() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.secondaryFuelStateAccuracy)
  return secondaryfuelstateaccuracy_;
}
inline void VehicleStatus::set_secondaryfuelstateaccuracy(double value) {
  set_has_secondaryfuelstateaccuracy();
  secondaryfuelstateaccuracy_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.secondaryFuelStateAccuracy)
}

// optional double estimatedSecondaryRange_km = 15;
inline bool VehicleStatus::has_estimatedsecondaryrange_km() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VehicleStatus::set_has_estimatedsecondaryrange_km() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VehicleStatus::clear_has_estimatedsecondaryrange_km() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VehicleStatus::clear_estimatedsecondaryrange_km() {
  estimatedsecondaryrange_km_ = 0;
  clear_has_estimatedsecondaryrange_km();
}
inline double VehicleStatus::estimatedsecondaryrange_km() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.estimatedSecondaryRange_km)
  return estimatedsecondaryrange_km_;
}
inline void VehicleStatus::set_estimatedsecondaryrange_km(double value) {
  set_has_estimatedsecondaryrange_km();
  estimatedsecondaryrange_km_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.estimatedSecondaryRange_km)
}

// optional .VehicleStatus.MaintenanceLightStateBitfield maintenanceLightState = 16;
inline bool VehicleStatus::has_maintenancelightstate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VehicleStatus::set_has_maintenancelightstate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VehicleStatus::clear_has_maintenancelightstate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VehicleStatus::clear_maintenancelightstate() {
  maintenancelightstate_ = 1;
  clear_has_maintenancelightstate();
}
inline ::VehicleStatus_MaintenanceLightStateBitfield VehicleStatus::maintenancelightstate() const {
  // @@protoc_insertion_point(field_get:VehicleStatus.maintenanceLightState)
  return static_cast< ::VehicleStatus_MaintenanceLightStateBitfield >(maintenancelightstate_);
}
inline void VehicleStatus::set_maintenancelightstate(::VehicleStatus_MaintenanceLightStateBitfield value) {
  assert(::VehicleStatus_MaintenanceLightStateBitfield_IsValid(value));
  set_has_maintenancelightstate();
  maintenancelightstate_ = value;
  // @@protoc_insertion_point(field_set:VehicleStatus.maintenanceLightState)
}

// -------------------------------------------------------------------

// VehicleDynamics

// required int64 timeStampUTC_ms = 1;
inline bool VehicleDynamics::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleDynamics::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleDynamics::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleDynamics::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 VehicleDynamics::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void VehicleDynamics::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:VehicleDynamics.timeStampUTC_ms)
}

// optional double curvature_1pm = 2;
inline bool VehicleDynamics::has_curvature_1pm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleDynamics::set_has_curvature_1pm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleDynamics::clear_has_curvature_1pm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleDynamics::clear_curvature_1pm() {
  curvature_1pm_ = 0;
  clear_has_curvature_1pm();
}
inline double VehicleDynamics::curvature_1pm() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.curvature_1pm)
  return curvature_1pm_;
}
inline void VehicleDynamics::set_curvature_1pm(double value) {
  set_has_curvature_1pm();
  curvature_1pm_ = value;
  // @@protoc_insertion_point(field_set:VehicleDynamics.curvature_1pm)
}

// optional double slope_percent = 3;
inline bool VehicleDynamics::has_slope_percent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleDynamics::set_has_slope_percent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleDynamics::clear_has_slope_percent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleDynamics::clear_slope_percent() {
  slope_percent_ = 0;
  clear_has_slope_percent();
}
inline double VehicleDynamics::slope_percent() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.slope_percent)
  return slope_percent_;
}
inline void VehicleDynamics::set_slope_percent(double value) {
  set_has_slope_percent();
  slope_percent_ = value;
  // @@protoc_insertion_point(field_set:VehicleDynamics.slope_percent)
}

// optional double curvatureAccuracy_1pm = 4;
inline bool VehicleDynamics::has_curvatureaccuracy_1pm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleDynamics::set_has_curvatureaccuracy_1pm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleDynamics::clear_has_curvatureaccuracy_1pm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleDynamics::clear_curvatureaccuracy_1pm() {
  curvatureaccuracy_1pm_ = 0;
  clear_has_curvatureaccuracy_1pm();
}
inline double VehicleDynamics::curvatureaccuracy_1pm() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.curvatureAccuracy_1pm)
  return curvatureaccuracy_1pm_;
}
inline void VehicleDynamics::set_curvatureaccuracy_1pm(double value) {
  set_has_curvatureaccuracy_1pm();
  curvatureaccuracy_1pm_ = value;
  // @@protoc_insertion_point(field_set:VehicleDynamics.curvatureAccuracy_1pm)
}

// optional double slopeAccuracy_percent = 5;
inline bool VehicleDynamics::has_slopeaccuracy_percent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleDynamics::set_has_slopeaccuracy_percent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleDynamics::clear_has_slopeaccuracy_percent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleDynamics::clear_slopeaccuracy_percent() {
  slopeaccuracy_percent_ = 0;
  clear_has_slopeaccuracy_percent();
}
inline double VehicleDynamics::slopeaccuracy_percent() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.slopeAccuracy_percent)
  return slopeaccuracy_percent_;
}
inline void VehicleDynamics::set_slopeaccuracy_percent(double value) {
  set_has_slopeaccuracy_percent();
  slopeaccuracy_percent_ = value;
  // @@protoc_insertion_point(field_set:VehicleDynamics.slopeAccuracy_percent)
}

// optional int32 averageSuspensionTravel_mm = 6;
inline bool VehicleDynamics::has_averagesuspensiontravel_mm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleDynamics::set_has_averagesuspensiontravel_mm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleDynamics::clear_has_averagesuspensiontravel_mm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleDynamics::clear_averagesuspensiontravel_mm() {
  averagesuspensiontravel_mm_ = 0;
  clear_has_averagesuspensiontravel_mm();
}
inline ::google::protobuf::int32 VehicleDynamics::averagesuspensiontravel_mm() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.averageSuspensionTravel_mm)
  return averagesuspensiontravel_mm_;
}
inline void VehicleDynamics::set_averagesuspensiontravel_mm(::google::protobuf::int32 value) {
  set_has_averagesuspensiontravel_mm();
  averagesuspensiontravel_mm_ = value;
  // @@protoc_insertion_point(field_set:VehicleDynamics.averageSuspensionTravel_mm)
}

// optional .Vector3D averageAccelerationVector_mps2 = 7;
inline bool VehicleDynamics::has_averageaccelerationvector_mps2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleDynamics::set_has_averageaccelerationvector_mps2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleDynamics::clear_has_averageaccelerationvector_mps2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleDynamics::clear_averageaccelerationvector_mps2() {
  if (averageaccelerationvector_mps2_ != NULL) averageaccelerationvector_mps2_->::Vector3D::Clear();
  clear_has_averageaccelerationvector_mps2();
}
inline const ::Vector3D& VehicleDynamics::averageaccelerationvector_mps2() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.averageAccelerationVector_mps2)
  return averageaccelerationvector_mps2_ != NULL ? *averageaccelerationvector_mps2_ : *default_instance_->averageaccelerationvector_mps2_;
}
inline ::Vector3D* VehicleDynamics::mutable_averageaccelerationvector_mps2() {
  set_has_averageaccelerationvector_mps2();
  if (averageaccelerationvector_mps2_ == NULL) {
    averageaccelerationvector_mps2_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:VehicleDynamics.averageAccelerationVector_mps2)
  return averageaccelerationvector_mps2_;
}
inline ::Vector3D* VehicleDynamics::release_averageaccelerationvector_mps2() {
  // @@protoc_insertion_point(field_release:VehicleDynamics.averageAccelerationVector_mps2)
  clear_has_averageaccelerationvector_mps2();
  ::Vector3D* temp = averageaccelerationvector_mps2_;
  averageaccelerationvector_mps2_ = NULL;
  return temp;
}
inline void VehicleDynamics::set_allocated_averageaccelerationvector_mps2(::Vector3D* averageaccelerationvector_mps2) {
  delete averageaccelerationvector_mps2_;
  averageaccelerationvector_mps2_ = averageaccelerationvector_mps2;
  if (averageaccelerationvector_mps2) {
    set_has_averageaccelerationvector_mps2();
  } else {
    clear_has_averageaccelerationvector_mps2();
  }
  // @@protoc_insertion_point(field_set_allocated:VehicleDynamics.averageAccelerationVector_mps2)
}

// optional .Vector3D averageRotationRateVector_omega = 8;
inline bool VehicleDynamics::has_averagerotationratevector_omega() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleDynamics::set_has_averagerotationratevector_omega() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleDynamics::clear_has_averagerotationratevector_omega() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleDynamics::clear_averagerotationratevector_omega() {
  if (averagerotationratevector_omega_ != NULL) averagerotationratevector_omega_->::Vector3D::Clear();
  clear_has_averagerotationratevector_omega();
}
inline const ::Vector3D& VehicleDynamics::averagerotationratevector_omega() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.averageRotationRateVector_omega)
  return averagerotationratevector_omega_ != NULL ? *averagerotationratevector_omega_ : *default_instance_->averagerotationratevector_omega_;
}
inline ::Vector3D* VehicleDynamics::mutable_averagerotationratevector_omega() {
  set_has_averagerotationratevector_omega();
  if (averagerotationratevector_omega_ == NULL) {
    averagerotationratevector_omega_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:VehicleDynamics.averageRotationRateVector_omega)
  return averagerotationratevector_omega_;
}
inline ::Vector3D* VehicleDynamics::release_averagerotationratevector_omega() {
  // @@protoc_insertion_point(field_release:VehicleDynamics.averageRotationRateVector_omega)
  clear_has_averagerotationratevector_omega();
  ::Vector3D* temp = averagerotationratevector_omega_;
  averagerotationratevector_omega_ = NULL;
  return temp;
}
inline void VehicleDynamics::set_allocated_averagerotationratevector_omega(::Vector3D* averagerotationratevector_omega) {
  delete averagerotationratevector_omega_;
  averagerotationratevector_omega_ = averagerotationratevector_omega;
  if (averagerotationratevector_omega) {
    set_has_averagerotationratevector_omega();
  } else {
    clear_has_averagerotationratevector_omega();
  }
  // @@protoc_insertion_point(field_set_allocated:VehicleDynamics.averageRotationRateVector_omega)
}

// optional .Vector3D averageSpeedVector_mps = 1000;
inline bool VehicleDynamics::has_averagespeedvector_mps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleDynamics::set_has_averagespeedvector_mps() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleDynamics::clear_has_averagespeedvector_mps() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleDynamics::clear_averagespeedvector_mps() {
  if (averagespeedvector_mps_ != NULL) averagespeedvector_mps_->::Vector3D::Clear();
  clear_has_averagespeedvector_mps();
}
inline const ::Vector3D& VehicleDynamics::averagespeedvector_mps() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.averageSpeedVector_mps)
  return averagespeedvector_mps_ != NULL ? *averagespeedvector_mps_ : *default_instance_->averagespeedvector_mps_;
}
inline ::Vector3D* VehicleDynamics::mutable_averagespeedvector_mps() {
  set_has_averagespeedvector_mps();
  if (averagespeedvector_mps_ == NULL) {
    averagespeedvector_mps_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:VehicleDynamics.averageSpeedVector_mps)
  return averagespeedvector_mps_;
}
inline ::Vector3D* VehicleDynamics::release_averagespeedvector_mps() {
  // @@protoc_insertion_point(field_release:VehicleDynamics.averageSpeedVector_mps)
  clear_has_averagespeedvector_mps();
  ::Vector3D* temp = averagespeedvector_mps_;
  averagespeedvector_mps_ = NULL;
  return temp;
}
inline void VehicleDynamics::set_allocated_averagespeedvector_mps(::Vector3D* averagespeedvector_mps) {
  delete averagespeedvector_mps_;
  averagespeedvector_mps_ = averagespeedvector_mps;
  if (averagespeedvector_mps) {
    set_has_averagespeedvector_mps();
  } else {
    clear_has_averagespeedvector_mps();
  }
  // @@protoc_insertion_point(field_set_allocated:VehicleDynamics.averageSpeedVector_mps)
}

// optional .Vector3D relativePositionVector_m = 1001;
inline bool VehicleDynamics::has_relativepositionvector_m() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VehicleDynamics::set_has_relativepositionvector_m() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VehicleDynamics::clear_has_relativepositionvector_m() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VehicleDynamics::clear_relativepositionvector_m() {
  if (relativepositionvector_m_ != NULL) relativepositionvector_m_->::Vector3D::Clear();
  clear_has_relativepositionvector_m();
}
inline const ::Vector3D& VehicleDynamics::relativepositionvector_m() const {
  // @@protoc_insertion_point(field_get:VehicleDynamics.relativePositionVector_m)
  return relativepositionvector_m_ != NULL ? *relativepositionvector_m_ : *default_instance_->relativepositionvector_m_;
}
inline ::Vector3D* VehicleDynamics::mutable_relativepositionvector_m() {
  set_has_relativepositionvector_m();
  if (relativepositionvector_m_ == NULL) {
    relativepositionvector_m_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:VehicleDynamics.relativePositionVector_m)
  return relativepositionvector_m_;
}
inline ::Vector3D* VehicleDynamics::release_relativepositionvector_m() {
  // @@protoc_insertion_point(field_release:VehicleDynamics.relativePositionVector_m)
  clear_has_relativepositionvector_m();
  ::Vector3D* temp = relativepositionvector_m_;
  relativepositionvector_m_ = NULL;
  return temp;
}
inline void VehicleDynamics::set_allocated_relativepositionvector_m(::Vector3D* relativepositionvector_m) {
  delete relativepositionvector_m_;
  relativepositionvector_m_ = relativepositionvector_m;
  if (relativepositionvector_m) {
    set_has_relativepositionvector_m();
  } else {
    clear_has_relativepositionvector_m();
  }
  // @@protoc_insertion_point(field_set_allocated:VehicleDynamics.relativePositionVector_m)
}

// -------------------------------------------------------------------

// PositionOffset

// optional double lateralOffset_m = 1;
inline bool PositionOffset::has_lateraloffset_m() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionOffset::set_has_lateraloffset_m() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionOffset::clear_has_lateraloffset_m() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionOffset::clear_lateraloffset_m() {
  lateraloffset_m_ = 0;
  clear_has_lateraloffset_m();
}
inline double PositionOffset::lateraloffset_m() const {
  // @@protoc_insertion_point(field_get:PositionOffset.lateralOffset_m)
  return lateraloffset_m_;
}
inline void PositionOffset::set_lateraloffset_m(double value) {
  set_has_lateraloffset_m();
  lateraloffset_m_ = value;
  // @@protoc_insertion_point(field_set:PositionOffset.lateralOffset_m)
}

// optional .PositionOffset.LateralOffsetSimpleEnum lateralOffsetSimple = 2;
inline bool PositionOffset::has_lateraloffsetsimple() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionOffset::set_has_lateraloffsetsimple() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionOffset::clear_has_lateraloffsetsimple() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionOffset::clear_lateraloffsetsimple() {
  lateraloffsetsimple_ = 1;
  clear_has_lateraloffsetsimple();
}
inline ::PositionOffset_LateralOffsetSimpleEnum PositionOffset::lateraloffsetsimple() const {
  // @@protoc_insertion_point(field_get:PositionOffset.lateralOffsetSimple)
  return static_cast< ::PositionOffset_LateralOffsetSimpleEnum >(lateraloffsetsimple_);
}
inline void PositionOffset::set_lateraloffsetsimple(::PositionOffset_LateralOffsetSimpleEnum value) {
  assert(::PositionOffset_LateralOffsetSimpleEnum_IsValid(value));
  set_has_lateraloffsetsimple();
  lateraloffsetsimple_ = value;
  // @@protoc_insertion_point(field_set:PositionOffset.lateralOffsetSimple)
}

// optional double longitudinalOffset_m = 3;
inline bool PositionOffset::has_longitudinaloffset_m() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PositionOffset::set_has_longitudinaloffset_m() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PositionOffset::clear_has_longitudinaloffset_m() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PositionOffset::clear_longitudinaloffset_m() {
  longitudinaloffset_m_ = 0;
  clear_has_longitudinaloffset_m();
}
inline double PositionOffset::longitudinaloffset_m() const {
  // @@protoc_insertion_point(field_get:PositionOffset.longitudinalOffset_m)
  return longitudinaloffset_m_;
}
inline void PositionOffset::set_longitudinaloffset_m(double value) {
  set_has_longitudinaloffset_m();
  longitudinaloffset_m_ = value;
  // @@protoc_insertion_point(field_set:PositionOffset.longitudinalOffset_m)
}

// optional .PositionOffset.LongitudinalOffsetSimpleEnum longitudinalOffsetSimple = 4;
inline bool PositionOffset::has_longitudinaloffsetsimple() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PositionOffset::set_has_longitudinaloffsetsimple() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PositionOffset::clear_has_longitudinaloffsetsimple() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PositionOffset::clear_longitudinaloffsetsimple() {
  longitudinaloffsetsimple_ = 1;
  clear_has_longitudinaloffsetsimple();
}
inline ::PositionOffset_LongitudinalOffsetSimpleEnum PositionOffset::longitudinaloffsetsimple() const {
  // @@protoc_insertion_point(field_get:PositionOffset.longitudinalOffsetSimple)
  return static_cast< ::PositionOffset_LongitudinalOffsetSimpleEnum >(longitudinaloffsetsimple_);
}
inline void PositionOffset::set_longitudinaloffsetsimple(::PositionOffset_LongitudinalOffsetSimpleEnum value) {
  assert(::PositionOffset_LongitudinalOffsetSimpleEnum_IsValid(value));
  set_has_longitudinaloffsetsimple();
  longitudinaloffsetsimple_ = value;
  // @@protoc_insertion_point(field_set:PositionOffset.longitudinalOffsetSimple)
}

// optional double verticalOffset_m = 5;
inline bool PositionOffset::has_verticaloffset_m() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PositionOffset::set_has_verticaloffset_m() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PositionOffset::clear_has_verticaloffset_m() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PositionOffset::clear_verticaloffset_m() {
  verticaloffset_m_ = 0;
  clear_has_verticaloffset_m();
}
inline double PositionOffset::verticaloffset_m() const {
  // @@protoc_insertion_point(field_get:PositionOffset.verticalOffset_m)
  return verticaloffset_m_;
}
inline void PositionOffset::set_verticaloffset_m(double value) {
  set_has_verticaloffset_m();
  verticaloffset_m_ = value;
  // @@protoc_insertion_point(field_set:PositionOffset.verticalOffset_m)
}

// optional .PositionOffset.VerticalOffsetSimpleEnum verticalOffsetSimple = 6;
inline bool PositionOffset::has_verticaloffsetsimple() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PositionOffset::set_has_verticaloffsetsimple() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PositionOffset::clear_has_verticaloffsetsimple() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PositionOffset::clear_verticaloffsetsimple() {
  verticaloffsetsimple_ = 1;
  clear_has_verticaloffsetsimple();
}
inline ::PositionOffset_VerticalOffsetSimpleEnum PositionOffset::verticaloffsetsimple() const {
  // @@protoc_insertion_point(field_get:PositionOffset.verticalOffsetSimple)
  return static_cast< ::PositionOffset_VerticalOffsetSimpleEnum >(verticaloffsetsimple_);
}
inline void PositionOffset::set_verticaloffsetsimple(::PositionOffset_VerticalOffsetSimpleEnum value) {
  assert(::PositionOffset_VerticalOffsetSimpleEnum_IsValid(value));
  set_has_verticaloffsetsimple();
  verticaloffsetsimple_ = value;
  // @@protoc_insertion_point(field_set:PositionOffset.verticalOffsetSimple)
}

// optional double lateralOffsetAccuracy_m = 7;
inline bool PositionOffset::has_lateraloffsetaccuracy_m() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PositionOffset::set_has_lateraloffsetaccuracy_m() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PositionOffset::clear_has_lateraloffsetaccuracy_m() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PositionOffset::clear_lateraloffsetaccuracy_m() {
  lateraloffsetaccuracy_m_ = 0;
  clear_has_lateraloffsetaccuracy_m();
}
inline double PositionOffset::lateraloffsetaccuracy_m() const {
  // @@protoc_insertion_point(field_get:PositionOffset.lateralOffsetAccuracy_m)
  return lateraloffsetaccuracy_m_;
}
inline void PositionOffset::set_lateraloffsetaccuracy_m(double value) {
  set_has_lateraloffsetaccuracy_m();
  lateraloffsetaccuracy_m_ = value;
  // @@protoc_insertion_point(field_set:PositionOffset.lateralOffsetAccuracy_m)
}

// optional double longitudinalOffsetAccuracy_m = 8;
inline bool PositionOffset::has_longitudinaloffsetaccuracy_m() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PositionOffset::set_has_longitudinaloffsetaccuracy_m() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PositionOffset::clear_has_longitudinaloffsetaccuracy_m() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PositionOffset::clear_longitudinaloffsetaccuracy_m() {
  longitudinaloffsetaccuracy_m_ = 0;
  clear_has_longitudinaloffsetaccuracy_m();
}
inline double PositionOffset::longitudinaloffsetaccuracy_m() const {
  // @@protoc_insertion_point(field_get:PositionOffset.longitudinalOffsetAccuracy_m)
  return longitudinaloffsetaccuracy_m_;
}
inline void PositionOffset::set_longitudinaloffsetaccuracy_m(double value) {
  set_has_longitudinaloffsetaccuracy_m();
  longitudinaloffsetaccuracy_m_ = value;
  // @@protoc_insertion_point(field_set:PositionOffset.longitudinalOffsetAccuracy_m)
}

// optional double verticalOffsetAccuracy_m = 9;
inline bool PositionOffset::has_verticaloffsetaccuracy_m() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PositionOffset::set_has_verticaloffsetaccuracy_m() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PositionOffset::clear_has_verticaloffsetaccuracy_m() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PositionOffset::clear_verticaloffsetaccuracy_m() {
  verticaloffsetaccuracy_m_ = 0;
  clear_has_verticaloffsetaccuracy_m();
}
inline double PositionOffset::verticaloffsetaccuracy_m() const {
  // @@protoc_insertion_point(field_get:PositionOffset.verticalOffsetAccuracy_m)
  return verticaloffsetaccuracy_m_;
}
inline void PositionOffset::set_verticaloffsetaccuracy_m(double value) {
  set_has_verticaloffsetaccuracy_m();
  verticaloffsetaccuracy_m_ = value;
  // @@protoc_insertion_point(field_set:PositionOffset.verticalOffsetAccuracy_m)
}

// -------------------------------------------------------------------

// RoadSignRestriction

// required .RoadSignRestriction.RestrictionType restrictionType = 1;
inline bool RoadSignRestriction::has_restrictiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadSignRestriction::set_has_restrictiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadSignRestriction::clear_has_restrictiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadSignRestriction::clear_restrictiontype() {
  restrictiontype_ = 1;
  clear_has_restrictiontype();
}
inline ::RoadSignRestriction_RestrictionType RoadSignRestriction::restrictiontype() const {
  // @@protoc_insertion_point(field_get:RoadSignRestriction.restrictionType)
  return static_cast< ::RoadSignRestriction_RestrictionType >(restrictiontype_);
}
inline void RoadSignRestriction::set_restrictiontype(::RoadSignRestriction_RestrictionType value) {
  assert(::RoadSignRestriction_RestrictionType_IsValid(value));
  set_has_restrictiontype();
  restrictiontype_ = value;
  // @@protoc_insertion_point(field_set:RoadSignRestriction.restrictionType)
}

// optional string restrictionValue = 2;
inline bool RoadSignRestriction::has_restrictionvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadSignRestriction::set_has_restrictionvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadSignRestriction::clear_has_restrictionvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoadSignRestriction::clear_restrictionvalue() {
  restrictionvalue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_restrictionvalue();
}
inline const ::std::string& RoadSignRestriction::restrictionvalue() const {
  // @@protoc_insertion_point(field_get:RoadSignRestriction.restrictionValue)
  return restrictionvalue_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadSignRestriction::set_restrictionvalue(const ::std::string& value) {
  set_has_restrictionvalue();
  restrictionvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoadSignRestriction.restrictionValue)
}
inline void RoadSignRestriction::set_restrictionvalue(const char* value) {
  set_has_restrictionvalue();
  restrictionvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoadSignRestriction.restrictionValue)
}
inline void RoadSignRestriction::set_restrictionvalue(const char* value, size_t size) {
  set_has_restrictionvalue();
  restrictionvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoadSignRestriction.restrictionValue)
}
inline ::std::string* RoadSignRestriction::mutable_restrictionvalue() {
  set_has_restrictionvalue();
  // @@protoc_insertion_point(field_mutable:RoadSignRestriction.restrictionValue)
  return restrictionvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadSignRestriction::release_restrictionvalue() {
  // @@protoc_insertion_point(field_release:RoadSignRestriction.restrictionValue)
  clear_has_restrictionvalue();
  return restrictionvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadSignRestriction::set_allocated_restrictionvalue(::std::string* restrictionvalue) {
  if (restrictionvalue != NULL) {
    set_has_restrictionvalue();
  } else {
    clear_has_restrictionvalue();
  }
  restrictionvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), restrictionvalue);
  // @@protoc_insertion_point(field_set_allocated:RoadSignRestriction.restrictionValue)
}

// optional uint32 restrictionConfidence_percent = 3;
inline bool RoadSignRestriction::has_restrictionconfidence_percent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoadSignRestriction::set_has_restrictionconfidence_percent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoadSignRestriction::clear_has_restrictionconfidence_percent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoadSignRestriction::clear_restrictionconfidence_percent() {
  restrictionconfidence_percent_ = 0u;
  clear_has_restrictionconfidence_percent();
}
inline ::google::protobuf::uint32 RoadSignRestriction::restrictionconfidence_percent() const {
  // @@protoc_insertion_point(field_get:RoadSignRestriction.restrictionConfidence_percent)
  return restrictionconfidence_percent_;
}
inline void RoadSignRestriction::set_restrictionconfidence_percent(::google::protobuf::uint32 value) {
  set_has_restrictionconfidence_percent();
  restrictionconfidence_percent_ = value;
  // @@protoc_insertion_point(field_set:RoadSignRestriction.restrictionConfidence_percent)
}

// -------------------------------------------------------------------

// SignRecognition

// required int64 timeStampUTC_ms = 1;
inline bool SignRecognition::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignRecognition::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignRecognition::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignRecognition::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 SignRecognition::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:SignRecognition.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void SignRecognition::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:SignRecognition.timeStampUTC_ms)
}

// optional .PositionOffset positionOffset = 2;
inline bool SignRecognition::has_positionoffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignRecognition::set_has_positionoffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignRecognition::clear_has_positionoffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignRecognition::clear_positionoffset() {
  if (positionoffset_ != NULL) positionoffset_->::PositionOffset::Clear();
  clear_has_positionoffset();
}
inline const ::PositionOffset& SignRecognition::positionoffset() const {
  // @@protoc_insertion_point(field_get:SignRecognition.positionOffset)
  return positionoffset_ != NULL ? *positionoffset_ : *default_instance_->positionoffset_;
}
inline ::PositionOffset* SignRecognition::mutable_positionoffset() {
  set_has_positionoffset();
  if (positionoffset_ == NULL) {
    positionoffset_ = new ::PositionOffset;
  }
  // @@protoc_insertion_point(field_mutable:SignRecognition.positionOffset)
  return positionoffset_;
}
inline ::PositionOffset* SignRecognition::release_positionoffset() {
  // @@protoc_insertion_point(field_release:SignRecognition.positionOffset)
  clear_has_positionoffset();
  ::PositionOffset* temp = positionoffset_;
  positionoffset_ = NULL;
  return temp;
}
inline void SignRecognition::set_allocated_positionoffset(::PositionOffset* positionoffset) {
  delete positionoffset_;
  positionoffset_ = positionoffset;
  if (positionoffset) {
    set_has_positionoffset();
  } else {
    clear_has_positionoffset();
  }
  // @@protoc_insertion_point(field_set_allocated:SignRecognition.positionOffset)
}

// required .SignRecognition.RoadSignTypeEnum roadSignType = 3;
inline bool SignRecognition::has_roadsigntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignRecognition::set_has_roadsigntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignRecognition::clear_has_roadsigntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignRecognition::clear_roadsigntype() {
  roadsigntype_ = 1;
  clear_has_roadsigntype();
}
inline ::SignRecognition_RoadSignTypeEnum SignRecognition::roadsigntype() const {
  // @@protoc_insertion_point(field_get:SignRecognition.roadSignType)
  return static_cast< ::SignRecognition_RoadSignTypeEnum >(roadsigntype_);
}
inline void SignRecognition::set_roadsigntype(::SignRecognition_RoadSignTypeEnum value) {
  assert(::SignRecognition_RoadSignTypeEnum_IsValid(value));
  set_has_roadsigntype();
  roadsigntype_ = value;
  // @@protoc_insertion_point(field_set:SignRecognition.roadSignType)
}

// optional .SignRecognition.RoadSignPermanencyEnum roadSignPermanency = 4;
inline bool SignRecognition::has_roadsignpermanency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignRecognition::set_has_roadsignpermanency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignRecognition::clear_has_roadsignpermanency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignRecognition::clear_roadsignpermanency() {
  roadsignpermanency_ = 1;
  clear_has_roadsignpermanency();
}
inline ::SignRecognition_RoadSignPermanencyEnum SignRecognition::roadsignpermanency() const {
  // @@protoc_insertion_point(field_get:SignRecognition.roadSignPermanency)
  return static_cast< ::SignRecognition_RoadSignPermanencyEnum >(roadsignpermanency_);
}
inline void SignRecognition::set_roadsignpermanency(::SignRecognition_RoadSignPermanencyEnum value) {
  assert(::SignRecognition_RoadSignPermanencyEnum_IsValid(value));
  set_has_roadsignpermanency();
  roadsignpermanency_ = value;
  // @@protoc_insertion_point(field_set:SignRecognition.roadSignPermanency)
}

// optional string roadSignValue = 5;
inline bool SignRecognition::has_roadsignvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignRecognition::set_has_roadsignvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignRecognition::clear_has_roadsignvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignRecognition::clear_roadsignvalue() {
  roadsignvalue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roadsignvalue();
}
inline const ::std::string& SignRecognition::roadsignvalue() const {
  // @@protoc_insertion_point(field_get:SignRecognition.roadSignValue)
  return roadsignvalue_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignRecognition::set_roadsignvalue(const ::std::string& value) {
  set_has_roadsignvalue();
  roadsignvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignRecognition.roadSignValue)
}
inline void SignRecognition::set_roadsignvalue(const char* value) {
  set_has_roadsignvalue();
  roadsignvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignRecognition.roadSignValue)
}
inline void SignRecognition::set_roadsignvalue(const char* value, size_t size) {
  set_has_roadsignvalue();
  roadsignvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignRecognition.roadSignValue)
}
inline ::std::string* SignRecognition::mutable_roadsignvalue() {
  set_has_roadsignvalue();
  // @@protoc_insertion_point(field_mutable:SignRecognition.roadSignValue)
  return roadsignvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignRecognition::release_roadsignvalue() {
  // @@protoc_insertion_point(field_release:SignRecognition.roadSignValue)
  clear_has_roadsignvalue();
  return roadsignvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignRecognition::set_allocated_roadsignvalue(::std::string* roadsignvalue) {
  if (roadsignvalue != NULL) {
    set_has_roadsignvalue();
  } else {
    clear_has_roadsignvalue();
  }
  roadsignvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roadsignvalue);
  // @@protoc_insertion_point(field_set_allocated:SignRecognition.roadSignValue)
}

// optional .SignRecognition.RoadSignDependenciesEnum roadSignDependencies = 6;
inline bool SignRecognition::has_roadsigndependencies() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignRecognition::set_has_roadsigndependencies() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignRecognition::clear_has_roadsigndependencies() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignRecognition::clear_roadsigndependencies() {
  roadsigndependencies_ = 1;
  clear_has_roadsigndependencies();
}
inline ::SignRecognition_RoadSignDependenciesEnum SignRecognition::roadsigndependencies() const {
  // @@protoc_insertion_point(field_get:SignRecognition.roadSignDependencies)
  return static_cast< ::SignRecognition_RoadSignDependenciesEnum >(roadsigndependencies_);
}
inline void SignRecognition::set_roadsigndependencies(::SignRecognition_RoadSignDependenciesEnum value) {
  assert(::SignRecognition_RoadSignDependenciesEnum_IsValid(value));
  set_has_roadsigndependencies();
  roadsigndependencies_ = value;
  // @@protoc_insertion_point(field_set:SignRecognition.roadSignDependencies)
}

// optional .SignRecognition.RoadSignValidityEnum roadSignValidity = 7;
inline bool SignRecognition::has_roadsignvalidity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignRecognition::set_has_roadsignvalidity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignRecognition::clear_has_roadsignvalidity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignRecognition::clear_roadsignvalidity() {
  roadsignvalidity_ = 1;
  clear_has_roadsignvalidity();
}
inline ::SignRecognition_RoadSignValidityEnum SignRecognition::roadsignvalidity() const {
  // @@protoc_insertion_point(field_get:SignRecognition.roadSignValidity)
  return static_cast< ::SignRecognition_RoadSignValidityEnum >(roadsignvalidity_);
}
inline void SignRecognition::set_roadsignvalidity(::SignRecognition_RoadSignValidityEnum value) {
  assert(::SignRecognition_RoadSignValidityEnum_IsValid(value));
  set_has_roadsignvalidity();
  roadsignvalidity_ = value;
  // @@protoc_insertion_point(field_set:SignRecognition.roadSignValidity)
}

// optional string roadSignValidityValue = 8;
inline bool SignRecognition::has_roadsignvalidityvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SignRecognition::set_has_roadsignvalidityvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SignRecognition::clear_has_roadsignvalidityvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SignRecognition::clear_roadsignvalidityvalue() {
  roadsignvalidityvalue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roadsignvalidityvalue();
}
inline const ::std::string& SignRecognition::roadsignvalidityvalue() const {
  // @@protoc_insertion_point(field_get:SignRecognition.roadSignValidityValue)
  return roadsignvalidityvalue_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignRecognition::set_roadsignvalidityvalue(const ::std::string& value) {
  set_has_roadsignvalidityvalue();
  roadsignvalidityvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignRecognition.roadSignValidityValue)
}
inline void SignRecognition::set_roadsignvalidityvalue(const char* value) {
  set_has_roadsignvalidityvalue();
  roadsignvalidityvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignRecognition.roadSignValidityValue)
}
inline void SignRecognition::set_roadsignvalidityvalue(const char* value, size_t size) {
  set_has_roadsignvalidityvalue();
  roadsignvalidityvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignRecognition.roadSignValidityValue)
}
inline ::std::string* SignRecognition::mutable_roadsignvalidityvalue() {
  set_has_roadsignvalidityvalue();
  // @@protoc_insertion_point(field_mutable:SignRecognition.roadSignValidityValue)
  return roadsignvalidityvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignRecognition::release_roadsignvalidityvalue() {
  // @@protoc_insertion_point(field_release:SignRecognition.roadSignValidityValue)
  clear_has_roadsignvalidityvalue();
  return roadsignvalidityvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignRecognition::set_allocated_roadsignvalidityvalue(::std::string* roadsignvalidityvalue) {
  if (roadsignvalidityvalue != NULL) {
    set_has_roadsignvalidityvalue();
  } else {
    clear_has_roadsignvalidityvalue();
  }
  roadsignvalidityvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roadsignvalidityvalue);
  // @@protoc_insertion_point(field_set_allocated:SignRecognition.roadSignValidityValue)
}

// optional .SignRecognition.RoadSignRecognitionTypeEnum roadSignRecognitionType = 9;
inline bool SignRecognition::has_roadsignrecognitiontype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SignRecognition::set_has_roadsignrecognitiontype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SignRecognition::clear_has_roadsignrecognitiontype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SignRecognition::clear_roadsignrecognitiontype() {
  roadsignrecognitiontype_ = 1;
  clear_has_roadsignrecognitiontype();
}
inline ::SignRecognition_RoadSignRecognitionTypeEnum SignRecognition::roadsignrecognitiontype() const {
  // @@protoc_insertion_point(field_get:SignRecognition.roadSignRecognitionType)
  return static_cast< ::SignRecognition_RoadSignRecognitionTypeEnum >(roadsignrecognitiontype_);
}
inline void SignRecognition::set_roadsignrecognitiontype(::SignRecognition_RoadSignRecognitionTypeEnum value) {
  assert(::SignRecognition_RoadSignRecognitionTypeEnum_IsValid(value));
  set_has_roadsignrecognitiontype();
  roadsignrecognitiontype_ = value;
  // @@protoc_insertion_point(field_set:SignRecognition.roadSignRecognitionType)
}

// optional int64 detectedObjectID = 10;
inline bool SignRecognition::has_detectedobjectid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SignRecognition::set_has_detectedobjectid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SignRecognition::clear_has_detectedobjectid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SignRecognition::clear_detectedobjectid() {
  detectedobjectid_ = GOOGLE_LONGLONG(0);
  clear_has_detectedobjectid();
}
inline ::google::protobuf::int64 SignRecognition::detectedobjectid() const {
  // @@protoc_insertion_point(field_get:SignRecognition.detectedObjectID)
  return detectedobjectid_;
}
inline void SignRecognition::set_detectedobjectid(::google::protobuf::int64 value) {
  set_has_detectedobjectid();
  detectedobjectid_ = value;
  // @@protoc_insertion_point(field_set:SignRecognition.detectedObjectID)
}

// optional int64 mediaID = 11;
inline bool SignRecognition::has_mediaid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SignRecognition::set_has_mediaid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SignRecognition::clear_has_mediaid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SignRecognition::clear_mediaid() {
  mediaid_ = GOOGLE_LONGLONG(0);
  clear_has_mediaid();
}
inline ::google::protobuf::int64 SignRecognition::mediaid() const {
  // @@protoc_insertion_point(field_get:SignRecognition.mediaID)
  return mediaid_;
}
inline void SignRecognition::set_mediaid(::google::protobuf::int64 value) {
  set_has_mediaid();
  mediaid_ = value;
  // @@protoc_insertion_point(field_set:SignRecognition.mediaID)
}

// optional uint32 roadSignRecognitionConfidence_percent = 12;
inline bool SignRecognition::has_roadsignrecognitionconfidence_percent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SignRecognition::set_has_roadsignrecognitionconfidence_percent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SignRecognition::clear_has_roadsignrecognitionconfidence_percent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SignRecognition::clear_roadsignrecognitionconfidence_percent() {
  roadsignrecognitionconfidence_percent_ = 0u;
  clear_has_roadsignrecognitionconfidence_percent();
}
inline ::google::protobuf::uint32 SignRecognition::roadsignrecognitionconfidence_percent() const {
  // @@protoc_insertion_point(field_get:SignRecognition.roadSignRecognitionConfidence_percent)
  return roadsignrecognitionconfidence_percent_;
}
inline void SignRecognition::set_roadsignrecognitionconfidence_percent(::google::protobuf::uint32 value) {
  set_has_roadsignrecognitionconfidence_percent();
  roadsignrecognitionconfidence_percent_ = value;
  // @@protoc_insertion_point(field_set:SignRecognition.roadSignRecognitionConfidence_percent)
}

// repeated .RoadSignRestriction roadSignRestrictions = 1001;
inline int SignRecognition::roadsignrestrictions_size() const {
  return roadsignrestrictions_.size();
}
inline void SignRecognition::clear_roadsignrestrictions() {
  roadsignrestrictions_.Clear();
}
inline const ::RoadSignRestriction& SignRecognition::roadsignrestrictions(int index) const {
  // @@protoc_insertion_point(field_get:SignRecognition.roadSignRestrictions)
  return roadsignrestrictions_.Get(index);
}
inline ::RoadSignRestriction* SignRecognition::mutable_roadsignrestrictions(int index) {
  // @@protoc_insertion_point(field_mutable:SignRecognition.roadSignRestrictions)
  return roadsignrestrictions_.Mutable(index);
}
inline ::RoadSignRestriction* SignRecognition::add_roadsignrestrictions() {
  // @@protoc_insertion_point(field_add:SignRecognition.roadSignRestrictions)
  return roadsignrestrictions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::RoadSignRestriction >*
SignRecognition::mutable_roadsignrestrictions() {
  // @@protoc_insertion_point(field_mutable_list:SignRecognition.roadSignRestrictions)
  return &roadsignrestrictions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::RoadSignRestriction >&
SignRecognition::roadsignrestrictions() const {
  // @@protoc_insertion_point(field_list:SignRecognition.roadSignRestrictions)
  return roadsignrestrictions_;
}

// -------------------------------------------------------------------

// LinePoint

// required .PositionOffset positionOffset = 1;
inline bool LinePoint::has_positionoffset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinePoint::set_has_positionoffset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinePoint::clear_has_positionoffset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinePoint::clear_positionoffset() {
  if (positionoffset_ != NULL) positionoffset_->::PositionOffset::Clear();
  clear_has_positionoffset();
}
inline const ::PositionOffset& LinePoint::positionoffset() const {
  // @@protoc_insertion_point(field_get:LinePoint.positionOffset)
  return positionoffset_ != NULL ? *positionoffset_ : *default_instance_->positionoffset_;
}
inline ::PositionOffset* LinePoint::mutable_positionoffset() {
  set_has_positionoffset();
  if (positionoffset_ == NULL) {
    positionoffset_ = new ::PositionOffset;
  }
  // @@protoc_insertion_point(field_mutable:LinePoint.positionOffset)
  return positionoffset_;
}
inline ::PositionOffset* LinePoint::release_positionoffset() {
  // @@protoc_insertion_point(field_release:LinePoint.positionOffset)
  clear_has_positionoffset();
  ::PositionOffset* temp = positionoffset_;
  positionoffset_ = NULL;
  return temp;
}
inline void LinePoint::set_allocated_positionoffset(::PositionOffset* positionoffset) {
  delete positionoffset_;
  positionoffset_ = positionoffset;
  if (positionoffset) {
    set_has_positionoffset();
  } else {
    clear_has_positionoffset();
  }
  // @@protoc_insertion_point(field_set_allocated:LinePoint.positionOffset)
}

// optional .LinePoint.LinePointTypeEnum linePointType = 2;
inline bool LinePoint::has_linepointtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinePoint::set_has_linepointtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinePoint::clear_has_linepointtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinePoint::clear_linepointtype() {
  linepointtype_ = 1;
  clear_has_linepointtype();
}
inline ::LinePoint_LinePointTypeEnum LinePoint::linepointtype() const {
  // @@protoc_insertion_point(field_get:LinePoint.linePointType)
  return static_cast< ::LinePoint_LinePointTypeEnum >(linepointtype_);
}
inline void LinePoint::set_linepointtype(::LinePoint_LinePointTypeEnum value) {
  assert(::LinePoint_LinePointTypeEnum_IsValid(value));
  set_has_linepointtype();
  linepointtype_ = value;
  // @@protoc_insertion_point(field_set:LinePoint.linePointType)
}

// -------------------------------------------------------------------

// LaneBoundaryRecognition

// required int64 timeStampUTC_ms = 1;
inline bool LaneBoundaryRecognition::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneBoundaryRecognition::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneBoundaryRecognition::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneBoundaryRecognition::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 LaneBoundaryRecognition::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void LaneBoundaryRecognition::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundaryRecognition.timeStampUTC_ms)
}

// required .PositionOffset positionOffset = 2;
inline bool LaneBoundaryRecognition::has_positionoffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneBoundaryRecognition::set_has_positionoffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneBoundaryRecognition::clear_has_positionoffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneBoundaryRecognition::clear_positionoffset() {
  if (positionoffset_ != NULL) positionoffset_->::PositionOffset::Clear();
  clear_has_positionoffset();
}
inline const ::PositionOffset& LaneBoundaryRecognition::positionoffset() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.positionOffset)
  return positionoffset_ != NULL ? *positionoffset_ : *default_instance_->positionoffset_;
}
inline ::PositionOffset* LaneBoundaryRecognition::mutable_positionoffset() {
  set_has_positionoffset();
  if (positionoffset_ == NULL) {
    positionoffset_ = new ::PositionOffset;
  }
  // @@protoc_insertion_point(field_mutable:LaneBoundaryRecognition.positionOffset)
  return positionoffset_;
}
inline ::PositionOffset* LaneBoundaryRecognition::release_positionoffset() {
  // @@protoc_insertion_point(field_release:LaneBoundaryRecognition.positionOffset)
  clear_has_positionoffset();
  ::PositionOffset* temp = positionoffset_;
  positionoffset_ = NULL;
  return temp;
}
inline void LaneBoundaryRecognition::set_allocated_positionoffset(::PositionOffset* positionoffset) {
  delete positionoffset_;
  positionoffset_ = positionoffset;
  if (positionoffset) {
    set_has_positionoffset();
  } else {
    clear_has_positionoffset();
  }
  // @@protoc_insertion_point(field_set_allocated:LaneBoundaryRecognition.positionOffset)
}

// optional .LaneBoundaryRecognition.LaneBoundaryTypeEnum laneBoundaryType = 3;
inline bool LaneBoundaryRecognition::has_laneboundarytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneBoundaryRecognition::set_has_laneboundarytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneBoundaryRecognition::clear_has_laneboundarytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneBoundaryRecognition::clear_laneboundarytype() {
  laneboundarytype_ = 1;
  clear_has_laneboundarytype();
}
inline ::LaneBoundaryRecognition_LaneBoundaryTypeEnum LaneBoundaryRecognition::laneboundarytype() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.laneBoundaryType)
  return static_cast< ::LaneBoundaryRecognition_LaneBoundaryTypeEnum >(laneboundarytype_);
}
inline void LaneBoundaryRecognition::set_laneboundarytype(::LaneBoundaryRecognition_LaneBoundaryTypeEnum value) {
  assert(::LaneBoundaryRecognition_LaneBoundaryTypeEnum_IsValid(value));
  set_has_laneboundarytype();
  laneboundarytype_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundaryRecognition.laneBoundaryType)
}

// optional .LaneBoundaryRecognition.LaneBoundaryColorEnum laneBoundaryColor = 4;
inline bool LaneBoundaryRecognition::has_laneboundarycolor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneBoundaryRecognition::set_has_laneboundarycolor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneBoundaryRecognition::clear_has_laneboundarycolor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneBoundaryRecognition::clear_laneboundarycolor() {
  laneboundarycolor_ = 1;
  clear_has_laneboundarycolor();
}
inline ::LaneBoundaryRecognition_LaneBoundaryColorEnum LaneBoundaryRecognition::laneboundarycolor() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.laneBoundaryColor)
  return static_cast< ::LaneBoundaryRecognition_LaneBoundaryColorEnum >(laneboundarycolor_);
}
inline void LaneBoundaryRecognition::set_laneboundarycolor(::LaneBoundaryRecognition_LaneBoundaryColorEnum value) {
  assert(::LaneBoundaryRecognition_LaneBoundaryColorEnum_IsValid(value));
  set_has_laneboundarycolor();
  laneboundarycolor_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundaryRecognition.laneBoundaryColor)
}

// optional double curvature_1pm = 5;
inline bool LaneBoundaryRecognition::has_curvature_1pm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneBoundaryRecognition::set_has_curvature_1pm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneBoundaryRecognition::clear_has_curvature_1pm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaneBoundaryRecognition::clear_curvature_1pm() {
  curvature_1pm_ = 0;
  clear_has_curvature_1pm();
}
inline double LaneBoundaryRecognition::curvature_1pm() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.curvature_1pm)
  return curvature_1pm_;
}
inline void LaneBoundaryRecognition::set_curvature_1pm(double value) {
  set_has_curvature_1pm();
  curvature_1pm_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundaryRecognition.curvature_1pm)
}

// optional int32 laneMarkerWidth_mm = 6;
inline bool LaneBoundaryRecognition::has_lanemarkerwidth_mm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaneBoundaryRecognition::set_has_lanemarkerwidth_mm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaneBoundaryRecognition::clear_has_lanemarkerwidth_mm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaneBoundaryRecognition::clear_lanemarkerwidth_mm() {
  lanemarkerwidth_mm_ = 0;
  clear_has_lanemarkerwidth_mm();
}
inline ::google::protobuf::int32 LaneBoundaryRecognition::lanemarkerwidth_mm() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.laneMarkerWidth_mm)
  return lanemarkerwidth_mm_;
}
inline void LaneBoundaryRecognition::set_lanemarkerwidth_mm(::google::protobuf::int32 value) {
  set_has_lanemarkerwidth_mm();
  lanemarkerwidth_mm_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundaryRecognition.laneMarkerWidth_mm)
}

// optional int32 laneMarkerWidthAccuracy_mm = 7;
inline bool LaneBoundaryRecognition::has_lanemarkerwidthaccuracy_mm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LaneBoundaryRecognition::set_has_lanemarkerwidthaccuracy_mm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LaneBoundaryRecognition::clear_has_lanemarkerwidthaccuracy_mm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LaneBoundaryRecognition::clear_lanemarkerwidthaccuracy_mm() {
  lanemarkerwidthaccuracy_mm_ = 0;
  clear_has_lanemarkerwidthaccuracy_mm();
}
inline ::google::protobuf::int32 LaneBoundaryRecognition::lanemarkerwidthaccuracy_mm() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.laneMarkerWidthAccuracy_mm)
  return lanemarkerwidthaccuracy_mm_;
}
inline void LaneBoundaryRecognition::set_lanemarkerwidthaccuracy_mm(::google::protobuf::int32 value) {
  set_has_lanemarkerwidthaccuracy_mm();
  lanemarkerwidthaccuracy_mm_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundaryRecognition.laneMarkerWidthAccuracy_mm)
}

// optional double laneDeclination_deg = 8;
inline bool LaneBoundaryRecognition::has_lanedeclination_deg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LaneBoundaryRecognition::set_has_lanedeclination_deg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LaneBoundaryRecognition::clear_has_lanedeclination_deg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LaneBoundaryRecognition::clear_lanedeclination_deg() {
  lanedeclination_deg_ = 0;
  clear_has_lanedeclination_deg();
}
inline double LaneBoundaryRecognition::lanedeclination_deg() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.laneDeclination_deg)
  return lanedeclination_deg_;
}
inline void LaneBoundaryRecognition::set_lanedeclination_deg(double value) {
  set_has_lanedeclination_deg();
  lanedeclination_deg_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundaryRecognition.laneDeclination_deg)
}

// optional double laneDeclinationAccuracy_deg = 9;
inline bool LaneBoundaryRecognition::has_lanedeclinationaccuracy_deg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LaneBoundaryRecognition::set_has_lanedeclinationaccuracy_deg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LaneBoundaryRecognition::clear_has_lanedeclinationaccuracy_deg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LaneBoundaryRecognition::clear_lanedeclinationaccuracy_deg() {
  lanedeclinationaccuracy_deg_ = 0;
  clear_has_lanedeclinationaccuracy_deg();
}
inline double LaneBoundaryRecognition::lanedeclinationaccuracy_deg() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.laneDeclinationAccuracy_deg)
  return lanedeclinationaccuracy_deg_;
}
inline void LaneBoundaryRecognition::set_lanedeclinationaccuracy_deg(double value) {
  set_has_lanedeclinationaccuracy_deg();
  lanedeclinationaccuracy_deg_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundaryRecognition.laneDeclinationAccuracy_deg)
}

// optional int32 laneBoundaryTypeConfidence_percent = 10;
inline bool LaneBoundaryRecognition::has_laneboundarytypeconfidence_percent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LaneBoundaryRecognition::set_has_laneboundarytypeconfidence_percent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LaneBoundaryRecognition::clear_has_laneboundarytypeconfidence_percent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LaneBoundaryRecognition::clear_laneboundarytypeconfidence_percent() {
  laneboundarytypeconfidence_percent_ = 0;
  clear_has_laneboundarytypeconfidence_percent();
}
inline ::google::protobuf::int32 LaneBoundaryRecognition::laneboundarytypeconfidence_percent() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.laneBoundaryTypeConfidence_percent)
  return laneboundarytypeconfidence_percent_;
}
inline void LaneBoundaryRecognition::set_laneboundarytypeconfidence_percent(::google::protobuf::int32 value) {
  set_has_laneboundarytypeconfidence_percent();
  laneboundarytypeconfidence_percent_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundaryRecognition.laneBoundaryTypeConfidence_percent)
}

// repeated .LinePoint linePoint = 1000;
inline int LaneBoundaryRecognition::linepoint_size() const {
  return linepoint_.size();
}
inline void LaneBoundaryRecognition::clear_linepoint() {
  linepoint_.Clear();
}
inline const ::LinePoint& LaneBoundaryRecognition::linepoint(int index) const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.linePoint)
  return linepoint_.Get(index);
}
inline ::LinePoint* LaneBoundaryRecognition::mutable_linepoint(int index) {
  // @@protoc_insertion_point(field_mutable:LaneBoundaryRecognition.linePoint)
  return linepoint_.Mutable(index);
}
inline ::LinePoint* LaneBoundaryRecognition::add_linepoint() {
  // @@protoc_insertion_point(field_add:LaneBoundaryRecognition.linePoint)
  return linepoint_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::LinePoint >*
LaneBoundaryRecognition::mutable_linepoint() {
  // @@protoc_insertion_point(field_mutable_list:LaneBoundaryRecognition.linePoint)
  return &linepoint_;
}
inline const ::google::protobuf::RepeatedPtrField< ::LinePoint >&
LaneBoundaryRecognition::linepoint() const {
  // @@protoc_insertion_point(field_list:LaneBoundaryRecognition.linePoint)
  return linepoint_;
}

// optional .Vector3D LM_Orientation = 1001;
inline bool LaneBoundaryRecognition::has_lm_orientation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LaneBoundaryRecognition::set_has_lm_orientation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LaneBoundaryRecognition::clear_has_lm_orientation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LaneBoundaryRecognition::clear_lm_orientation() {
  if (lm_orientation_ != NULL) lm_orientation_->::Vector3D::Clear();
  clear_has_lm_orientation();
}
inline const ::Vector3D& LaneBoundaryRecognition::lm_orientation() const {
  // @@protoc_insertion_point(field_get:LaneBoundaryRecognition.LM_Orientation)
  return lm_orientation_ != NULL ? *lm_orientation_ : *default_instance_->lm_orientation_;
}
inline ::Vector3D* LaneBoundaryRecognition::mutable_lm_orientation() {
  set_has_lm_orientation();
  if (lm_orientation_ == NULL) {
    lm_orientation_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:LaneBoundaryRecognition.LM_Orientation)
  return lm_orientation_;
}
inline ::Vector3D* LaneBoundaryRecognition::release_lm_orientation() {
  // @@protoc_insertion_point(field_release:LaneBoundaryRecognition.LM_Orientation)
  clear_has_lm_orientation();
  ::Vector3D* temp = lm_orientation_;
  lm_orientation_ = NULL;
  return temp;
}
inline void LaneBoundaryRecognition::set_allocated_lm_orientation(::Vector3D* lm_orientation) {
  delete lm_orientation_;
  lm_orientation_ = lm_orientation;
  if (lm_orientation) {
    set_has_lm_orientation();
  } else {
    clear_has_lm_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:LaneBoundaryRecognition.LM_Orientation)
}

// -------------------------------------------------------------------

// TireSlippageEvent

// -------------------------------------------------------------------

// CrashDetectedEvent

// optional bool vehicleIsDrivable = 1;
inline bool CrashDetectedEvent::has_vehicleisdrivable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrashDetectedEvent::set_has_vehicleisdrivable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrashDetectedEvent::clear_has_vehicleisdrivable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrashDetectedEvent::clear_vehicleisdrivable() {
  vehicleisdrivable_ = false;
  clear_has_vehicleisdrivable();
}
inline bool CrashDetectedEvent::vehicleisdrivable() const {
  // @@protoc_insertion_point(field_get:CrashDetectedEvent.vehicleIsDrivable)
  return vehicleisdrivable_;
}
inline void CrashDetectedEvent::set_vehicleisdrivable(bool value) {
  set_has_vehicleisdrivable();
  vehicleisdrivable_ = value;
  // @@protoc_insertion_point(field_set:CrashDetectedEvent.vehicleIsDrivable)
}

// optional bool airbagsDeployed = 2;
inline bool CrashDetectedEvent::has_airbagsdeployed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrashDetectedEvent::set_has_airbagsdeployed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CrashDetectedEvent::clear_has_airbagsdeployed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CrashDetectedEvent::clear_airbagsdeployed() {
  airbagsdeployed_ = false;
  clear_has_airbagsdeployed();
}
inline bool CrashDetectedEvent::airbagsdeployed() const {
  // @@protoc_insertion_point(field_get:CrashDetectedEvent.airbagsDeployed)
  return airbagsdeployed_;
}
inline void CrashDetectedEvent::set_airbagsdeployed(bool value) {
  set_has_airbagsdeployed();
  airbagsdeployed_ = value;
  // @@protoc_insertion_point(field_set:CrashDetectedEvent.airbagsDeployed)
}

// optional bool eCallActivated = 3;
inline bool CrashDetectedEvent::has_ecallactivated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrashDetectedEvent::set_has_ecallactivated() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CrashDetectedEvent::clear_has_ecallactivated() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CrashDetectedEvent::clear_ecallactivated() {
  ecallactivated_ = false;
  clear_has_ecallactivated();
}
inline bool CrashDetectedEvent::ecallactivated() const {
  // @@protoc_insertion_point(field_get:CrashDetectedEvent.eCallActivated)
  return ecallactivated_;
}
inline void CrashDetectedEvent::set_ecallactivated(bool value) {
  set_has_ecallactivated();
  ecallactivated_ = value;
  // @@protoc_insertion_point(field_set:CrashDetectedEvent.eCallActivated)
}

// optional bool vehicleIsObstacleOnRoad = 4;
inline bool CrashDetectedEvent::has_vehicleisobstacleonroad() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CrashDetectedEvent::set_has_vehicleisobstacleonroad() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CrashDetectedEvent::clear_has_vehicleisobstacleonroad() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CrashDetectedEvent::clear_vehicleisobstacleonroad() {
  vehicleisobstacleonroad_ = false;
  clear_has_vehicleisobstacleonroad();
}
inline bool CrashDetectedEvent::vehicleisobstacleonroad() const {
  // @@protoc_insertion_point(field_get:CrashDetectedEvent.vehicleIsObstacleOnRoad)
  return vehicleisobstacleonroad_;
}
inline void CrashDetectedEvent::set_vehicleisobstacleonroad(bool value) {
  set_has_vehicleisobstacleonroad();
  vehicleisobstacleonroad_ = value;
  // @@protoc_insertion_point(field_set:CrashDetectedEvent.vehicleIsObstacleOnRoad)
}

// optional .Vector3D maxAccelerationVector_mps2 = 5;
inline bool CrashDetectedEvent::has_maxaccelerationvector_mps2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CrashDetectedEvent::set_has_maxaccelerationvector_mps2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CrashDetectedEvent::clear_has_maxaccelerationvector_mps2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CrashDetectedEvent::clear_maxaccelerationvector_mps2() {
  if (maxaccelerationvector_mps2_ != NULL) maxaccelerationvector_mps2_->::Vector3D::Clear();
  clear_has_maxaccelerationvector_mps2();
}
inline const ::Vector3D& CrashDetectedEvent::maxaccelerationvector_mps2() const {
  // @@protoc_insertion_point(field_get:CrashDetectedEvent.maxAccelerationVector_mps2)
  return maxaccelerationvector_mps2_ != NULL ? *maxaccelerationvector_mps2_ : *default_instance_->maxaccelerationvector_mps2_;
}
inline ::Vector3D* CrashDetectedEvent::mutable_maxaccelerationvector_mps2() {
  set_has_maxaccelerationvector_mps2();
  if (maxaccelerationvector_mps2_ == NULL) {
    maxaccelerationvector_mps2_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:CrashDetectedEvent.maxAccelerationVector_mps2)
  return maxaccelerationvector_mps2_;
}
inline ::Vector3D* CrashDetectedEvent::release_maxaccelerationvector_mps2() {
  // @@protoc_insertion_point(field_release:CrashDetectedEvent.maxAccelerationVector_mps2)
  clear_has_maxaccelerationvector_mps2();
  ::Vector3D* temp = maxaccelerationvector_mps2_;
  maxaccelerationvector_mps2_ = NULL;
  return temp;
}
inline void CrashDetectedEvent::set_allocated_maxaccelerationvector_mps2(::Vector3D* maxaccelerationvector_mps2) {
  delete maxaccelerationvector_mps2_;
  maxaccelerationvector_mps2_ = maxaccelerationvector_mps2;
  if (maxaccelerationvector_mps2) {
    set_has_maxaccelerationvector_mps2();
  } else {
    clear_has_maxaccelerationvector_mps2();
  }
  // @@protoc_insertion_point(field_set_allocated:CrashDetectedEvent.maxAccelerationVector_mps2)
}

// -------------------------------------------------------------------

// EmergencyBrakingEvent

// optional .Vector3D maxAccelerationVector_mps2 = 1;
inline bool EmergencyBrakingEvent::has_maxaccelerationvector_mps2() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmergencyBrakingEvent::set_has_maxaccelerationvector_mps2() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmergencyBrakingEvent::clear_has_maxaccelerationvector_mps2() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmergencyBrakingEvent::clear_maxaccelerationvector_mps2() {
  if (maxaccelerationvector_mps2_ != NULL) maxaccelerationvector_mps2_->::Vector3D::Clear();
  clear_has_maxaccelerationvector_mps2();
}
inline const ::Vector3D& EmergencyBrakingEvent::maxaccelerationvector_mps2() const {
  // @@protoc_insertion_point(field_get:EmergencyBrakingEvent.maxAccelerationVector_mps2)
  return maxaccelerationvector_mps2_ != NULL ? *maxaccelerationvector_mps2_ : *default_instance_->maxaccelerationvector_mps2_;
}
inline ::Vector3D* EmergencyBrakingEvent::mutable_maxaccelerationvector_mps2() {
  set_has_maxaccelerationvector_mps2();
  if (maxaccelerationvector_mps2_ == NULL) {
    maxaccelerationvector_mps2_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:EmergencyBrakingEvent.maxAccelerationVector_mps2)
  return maxaccelerationvector_mps2_;
}
inline ::Vector3D* EmergencyBrakingEvent::release_maxaccelerationvector_mps2() {
  // @@protoc_insertion_point(field_release:EmergencyBrakingEvent.maxAccelerationVector_mps2)
  clear_has_maxaccelerationvector_mps2();
  ::Vector3D* temp = maxaccelerationvector_mps2_;
  maxaccelerationvector_mps2_ = NULL;
  return temp;
}
inline void EmergencyBrakingEvent::set_allocated_maxaccelerationvector_mps2(::Vector3D* maxaccelerationvector_mps2) {
  delete maxaccelerationvector_mps2_;
  maxaccelerationvector_mps2_ = maxaccelerationvector_mps2;
  if (maxaccelerationvector_mps2) {
    set_has_maxaccelerationvector_mps2();
  } else {
    clear_has_maxaccelerationvector_mps2();
  }
  // @@protoc_insertion_point(field_set_allocated:EmergencyBrakingEvent.maxAccelerationVector_mps2)
}

// -------------------------------------------------------------------

// DynamicStabilityControlEvent

// -------------------------------------------------------------------

// AntiLockBrakingSystemEvent

// -------------------------------------------------------------------

// ElectronicStabilityControlEvent

// optional bool antiSlipActionEvent = 1;
inline bool ElectronicStabilityControlEvent::has_antislipactionevent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ElectronicStabilityControlEvent::set_has_antislipactionevent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ElectronicStabilityControlEvent::clear_has_antislipactionevent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ElectronicStabilityControlEvent::clear_antislipactionevent() {
  antislipactionevent_ = false;
  clear_has_antislipactionevent();
}
inline bool ElectronicStabilityControlEvent::antislipactionevent() const {
  // @@protoc_insertion_point(field_get:ElectronicStabilityControlEvent.antiSlipActionEvent)
  return antislipactionevent_;
}
inline void ElectronicStabilityControlEvent::set_antislipactionevent(bool value) {
  set_has_antislipactionevent();
  antislipactionevent_ = value;
  // @@protoc_insertion_point(field_set:ElectronicStabilityControlEvent.antiSlipActionEvent)
}

// optional bool antiLockActionEvent = 2;
inline bool ElectronicStabilityControlEvent::has_antilockactionevent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ElectronicStabilityControlEvent::set_has_antilockactionevent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ElectronicStabilityControlEvent::clear_has_antilockactionevent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ElectronicStabilityControlEvent::clear_antilockactionevent() {
  antilockactionevent_ = false;
  clear_has_antilockactionevent();
}
inline bool ElectronicStabilityControlEvent::antilockactionevent() const {
  // @@protoc_insertion_point(field_get:ElectronicStabilityControlEvent.antiLockActionEvent)
  return antilockactionevent_;
}
inline void ElectronicStabilityControlEvent::set_antilockactionevent(bool value) {
  set_has_antilockactionevent();
  antilockactionevent_ = value;
  // @@protoc_insertion_point(field_set:ElectronicStabilityControlEvent.antiLockActionEvent)
}

// optional bool electronicStabilityControlEvent = 3;
inline bool ElectronicStabilityControlEvent::has_electronicstabilitycontrolevent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ElectronicStabilityControlEvent::set_has_electronicstabilitycontrolevent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ElectronicStabilityControlEvent::clear_has_electronicstabilitycontrolevent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ElectronicStabilityControlEvent::clear_electronicstabilitycontrolevent() {
  electronicstabilitycontrolevent_ = false;
  clear_has_electronicstabilitycontrolevent();
}
inline bool ElectronicStabilityControlEvent::electronicstabilitycontrolevent() const {
  // @@protoc_insertion_point(field_get:ElectronicStabilityControlEvent.electronicStabilityControlEvent)
  return electronicstabilitycontrolevent_;
}
inline void ElectronicStabilityControlEvent::set_electronicstabilitycontrolevent(bool value) {
  set_has_electronicstabilitycontrolevent();
  electronicstabilitycontrolevent_ = value;
  // @@protoc_insertion_point(field_set:ElectronicStabilityControlEvent.electronicStabilityControlEvent)
}

// optional .Vector3D requestedAccelerationVector_mps2 = 4;
inline bool ElectronicStabilityControlEvent::has_requestedaccelerationvector_mps2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ElectronicStabilityControlEvent::set_has_requestedaccelerationvector_mps2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ElectronicStabilityControlEvent::clear_has_requestedaccelerationvector_mps2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ElectronicStabilityControlEvent::clear_requestedaccelerationvector_mps2() {
  if (requestedaccelerationvector_mps2_ != NULL) requestedaccelerationvector_mps2_->::Vector3D::Clear();
  clear_has_requestedaccelerationvector_mps2();
}
inline const ::Vector3D& ElectronicStabilityControlEvent::requestedaccelerationvector_mps2() const {
  // @@protoc_insertion_point(field_get:ElectronicStabilityControlEvent.requestedAccelerationVector_mps2)
  return requestedaccelerationvector_mps2_ != NULL ? *requestedaccelerationvector_mps2_ : *default_instance_->requestedaccelerationvector_mps2_;
}
inline ::Vector3D* ElectronicStabilityControlEvent::mutable_requestedaccelerationvector_mps2() {
  set_has_requestedaccelerationvector_mps2();
  if (requestedaccelerationvector_mps2_ == NULL) {
    requestedaccelerationvector_mps2_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ElectronicStabilityControlEvent.requestedAccelerationVector_mps2)
  return requestedaccelerationvector_mps2_;
}
inline ::Vector3D* ElectronicStabilityControlEvent::release_requestedaccelerationvector_mps2() {
  // @@protoc_insertion_point(field_release:ElectronicStabilityControlEvent.requestedAccelerationVector_mps2)
  clear_has_requestedaccelerationvector_mps2();
  ::Vector3D* temp = requestedaccelerationvector_mps2_;
  requestedaccelerationvector_mps2_ = NULL;
  return temp;
}
inline void ElectronicStabilityControlEvent::set_allocated_requestedaccelerationvector_mps2(::Vector3D* requestedaccelerationvector_mps2) {
  delete requestedaccelerationvector_mps2_;
  requestedaccelerationvector_mps2_ = requestedaccelerationvector_mps2;
  if (requestedaccelerationvector_mps2) {
    set_has_requestedaccelerationvector_mps2();
  } else {
    clear_has_requestedaccelerationvector_mps2();
  }
  // @@protoc_insertion_point(field_set_allocated:ElectronicStabilityControlEvent.requestedAccelerationVector_mps2)
}

// optional .Vector3D requestedRotationRateVector_omega = 5;
inline bool ElectronicStabilityControlEvent::has_requestedrotationratevector_omega() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ElectronicStabilityControlEvent::set_has_requestedrotationratevector_omega() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ElectronicStabilityControlEvent::clear_has_requestedrotationratevector_omega() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ElectronicStabilityControlEvent::clear_requestedrotationratevector_omega() {
  if (requestedrotationratevector_omega_ != NULL) requestedrotationratevector_omega_->::Vector3D::Clear();
  clear_has_requestedrotationratevector_omega();
}
inline const ::Vector3D& ElectronicStabilityControlEvent::requestedrotationratevector_omega() const {
  // @@protoc_insertion_point(field_get:ElectronicStabilityControlEvent.requestedRotationRateVector_omega)
  return requestedrotationratevector_omega_ != NULL ? *requestedrotationratevector_omega_ : *default_instance_->requestedrotationratevector_omega_;
}
inline ::Vector3D* ElectronicStabilityControlEvent::mutable_requestedrotationratevector_omega() {
  set_has_requestedrotationratevector_omega();
  if (requestedrotationratevector_omega_ == NULL) {
    requestedrotationratevector_omega_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ElectronicStabilityControlEvent.requestedRotationRateVector_omega)
  return requestedrotationratevector_omega_;
}
inline ::Vector3D* ElectronicStabilityControlEvent::release_requestedrotationratevector_omega() {
  // @@protoc_insertion_point(field_release:ElectronicStabilityControlEvent.requestedRotationRateVector_omega)
  clear_has_requestedrotationratevector_omega();
  ::Vector3D* temp = requestedrotationratevector_omega_;
  requestedrotationratevector_omega_ = NULL;
  return temp;
}
inline void ElectronicStabilityControlEvent::set_allocated_requestedrotationratevector_omega(::Vector3D* requestedrotationratevector_omega) {
  delete requestedrotationratevector_omega_;
  requestedrotationratevector_omega_ = requestedrotationratevector_omega;
  if (requestedrotationratevector_omega) {
    set_has_requestedrotationratevector_omega();
  } else {
    clear_has_requestedrotationratevector_omega();
  }
  // @@protoc_insertion_point(field_set_allocated:ElectronicStabilityControlEvent.requestedRotationRateVector_omega)
}

// -------------------------------------------------------------------

// ExceptionalVehicleState

// required int64 timeStampUTC_ms = 1;
inline bool ExceptionalVehicleState::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExceptionalVehicleState::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExceptionalVehicleState::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExceptionalVehicleState::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 ExceptionalVehicleState::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:ExceptionalVehicleState.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void ExceptionalVehicleState::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:ExceptionalVehicleState.timeStampUTC_ms)
}

// optional .TireSlippageEvent tireSlippage = 2 [deprecated = true];
inline bool ExceptionalVehicleState::has_tireslippage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExceptionalVehicleState::set_has_tireslippage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExceptionalVehicleState::clear_has_tireslippage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExceptionalVehicleState::clear_tireslippage() {
  if (tireslippage_ != NULL) tireslippage_->::TireSlippageEvent::Clear();
  clear_has_tireslippage();
}
inline const ::TireSlippageEvent& ExceptionalVehicleState::tireslippage() const {
  // @@protoc_insertion_point(field_get:ExceptionalVehicleState.tireSlippage)
  return tireslippage_ != NULL ? *tireslippage_ : *default_instance_->tireslippage_;
}
inline ::TireSlippageEvent* ExceptionalVehicleState::mutable_tireslippage() {
  set_has_tireslippage();
  if (tireslippage_ == NULL) {
    tireslippage_ = new ::TireSlippageEvent;
  }
  // @@protoc_insertion_point(field_mutable:ExceptionalVehicleState.tireSlippage)
  return tireslippage_;
}
inline ::TireSlippageEvent* ExceptionalVehicleState::release_tireslippage() {
  // @@protoc_insertion_point(field_release:ExceptionalVehicleState.tireSlippage)
  clear_has_tireslippage();
  ::TireSlippageEvent* temp = tireslippage_;
  tireslippage_ = NULL;
  return temp;
}
inline void ExceptionalVehicleState::set_allocated_tireslippage(::TireSlippageEvent* tireslippage) {
  delete tireslippage_;
  tireslippage_ = tireslippage;
  if (tireslippage) {
    set_has_tireslippage();
  } else {
    clear_has_tireslippage();
  }
  // @@protoc_insertion_point(field_set_allocated:ExceptionalVehicleState.tireSlippage)
}

// optional .CrashDetectedEvent crashDetected = 3;
inline bool ExceptionalVehicleState::has_crashdetected() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExceptionalVehicleState::set_has_crashdetected() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExceptionalVehicleState::clear_has_crashdetected() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExceptionalVehicleState::clear_crashdetected() {
  if (crashdetected_ != NULL) crashdetected_->::CrashDetectedEvent::Clear();
  clear_has_crashdetected();
}
inline const ::CrashDetectedEvent& ExceptionalVehicleState::crashdetected() const {
  // @@protoc_insertion_point(field_get:ExceptionalVehicleState.crashDetected)
  return crashdetected_ != NULL ? *crashdetected_ : *default_instance_->crashdetected_;
}
inline ::CrashDetectedEvent* ExceptionalVehicleState::mutable_crashdetected() {
  set_has_crashdetected();
  if (crashdetected_ == NULL) {
    crashdetected_ = new ::CrashDetectedEvent;
  }
  // @@protoc_insertion_point(field_mutable:ExceptionalVehicleState.crashDetected)
  return crashdetected_;
}
inline ::CrashDetectedEvent* ExceptionalVehicleState::release_crashdetected() {
  // @@protoc_insertion_point(field_release:ExceptionalVehicleState.crashDetected)
  clear_has_crashdetected();
  ::CrashDetectedEvent* temp = crashdetected_;
  crashdetected_ = NULL;
  return temp;
}
inline void ExceptionalVehicleState::set_allocated_crashdetected(::CrashDetectedEvent* crashdetected) {
  delete crashdetected_;
  crashdetected_ = crashdetected;
  if (crashdetected) {
    set_has_crashdetected();
  } else {
    clear_has_crashdetected();
  }
  // @@protoc_insertion_point(field_set_allocated:ExceptionalVehicleState.crashDetected)
}

// optional .EmergencyBrakingEvent emergencyBraking = 4;
inline bool ExceptionalVehicleState::has_emergencybraking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExceptionalVehicleState::set_has_emergencybraking() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExceptionalVehicleState::clear_has_emergencybraking() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExceptionalVehicleState::clear_emergencybraking() {
  if (emergencybraking_ != NULL) emergencybraking_->::EmergencyBrakingEvent::Clear();
  clear_has_emergencybraking();
}
inline const ::EmergencyBrakingEvent& ExceptionalVehicleState::emergencybraking() const {
  // @@protoc_insertion_point(field_get:ExceptionalVehicleState.emergencyBraking)
  return emergencybraking_ != NULL ? *emergencybraking_ : *default_instance_->emergencybraking_;
}
inline ::EmergencyBrakingEvent* ExceptionalVehicleState::mutable_emergencybraking() {
  set_has_emergencybraking();
  if (emergencybraking_ == NULL) {
    emergencybraking_ = new ::EmergencyBrakingEvent;
  }
  // @@protoc_insertion_point(field_mutable:ExceptionalVehicleState.emergencyBraking)
  return emergencybraking_;
}
inline ::EmergencyBrakingEvent* ExceptionalVehicleState::release_emergencybraking() {
  // @@protoc_insertion_point(field_release:ExceptionalVehicleState.emergencyBraking)
  clear_has_emergencybraking();
  ::EmergencyBrakingEvent* temp = emergencybraking_;
  emergencybraking_ = NULL;
  return temp;
}
inline void ExceptionalVehicleState::set_allocated_emergencybraking(::EmergencyBrakingEvent* emergencybraking) {
  delete emergencybraking_;
  emergencybraking_ = emergencybraking;
  if (emergencybraking) {
    set_has_emergencybraking();
  } else {
    clear_has_emergencybraking();
  }
  // @@protoc_insertion_point(field_set_allocated:ExceptionalVehicleState.emergencyBraking)
}

// optional .DynamicStabilityControlEvent dynamicStabilityControl = 5 [deprecated = true];
inline bool ExceptionalVehicleState::has_dynamicstabilitycontrol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExceptionalVehicleState::set_has_dynamicstabilitycontrol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExceptionalVehicleState::clear_has_dynamicstabilitycontrol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExceptionalVehicleState::clear_dynamicstabilitycontrol() {
  if (dynamicstabilitycontrol_ != NULL) dynamicstabilitycontrol_->::DynamicStabilityControlEvent::Clear();
  clear_has_dynamicstabilitycontrol();
}
inline const ::DynamicStabilityControlEvent& ExceptionalVehicleState::dynamicstabilitycontrol() const {
  // @@protoc_insertion_point(field_get:ExceptionalVehicleState.dynamicStabilityControl)
  return dynamicstabilitycontrol_ != NULL ? *dynamicstabilitycontrol_ : *default_instance_->dynamicstabilitycontrol_;
}
inline ::DynamicStabilityControlEvent* ExceptionalVehicleState::mutable_dynamicstabilitycontrol() {
  set_has_dynamicstabilitycontrol();
  if (dynamicstabilitycontrol_ == NULL) {
    dynamicstabilitycontrol_ = new ::DynamicStabilityControlEvent;
  }
  // @@protoc_insertion_point(field_mutable:ExceptionalVehicleState.dynamicStabilityControl)
  return dynamicstabilitycontrol_;
}
inline ::DynamicStabilityControlEvent* ExceptionalVehicleState::release_dynamicstabilitycontrol() {
  // @@protoc_insertion_point(field_release:ExceptionalVehicleState.dynamicStabilityControl)
  clear_has_dynamicstabilitycontrol();
  ::DynamicStabilityControlEvent* temp = dynamicstabilitycontrol_;
  dynamicstabilitycontrol_ = NULL;
  return temp;
}
inline void ExceptionalVehicleState::set_allocated_dynamicstabilitycontrol(::DynamicStabilityControlEvent* dynamicstabilitycontrol) {
  delete dynamicstabilitycontrol_;
  dynamicstabilitycontrol_ = dynamicstabilitycontrol;
  if (dynamicstabilitycontrol) {
    set_has_dynamicstabilitycontrol();
  } else {
    clear_has_dynamicstabilitycontrol();
  }
  // @@protoc_insertion_point(field_set_allocated:ExceptionalVehicleState.dynamicStabilityControl)
}

// optional .AntiLockBrakingSystemEvent antiLockBrakingSystem = 6 [deprecated = true];
inline bool ExceptionalVehicleState::has_antilockbrakingsystem() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExceptionalVehicleState::set_has_antilockbrakingsystem() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExceptionalVehicleState::clear_has_antilockbrakingsystem() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExceptionalVehicleState::clear_antilockbrakingsystem() {
  if (antilockbrakingsystem_ != NULL) antilockbrakingsystem_->::AntiLockBrakingSystemEvent::Clear();
  clear_has_antilockbrakingsystem();
}
inline const ::AntiLockBrakingSystemEvent& ExceptionalVehicleState::antilockbrakingsystem() const {
  // @@protoc_insertion_point(field_get:ExceptionalVehicleState.antiLockBrakingSystem)
  return antilockbrakingsystem_ != NULL ? *antilockbrakingsystem_ : *default_instance_->antilockbrakingsystem_;
}
inline ::AntiLockBrakingSystemEvent* ExceptionalVehicleState::mutable_antilockbrakingsystem() {
  set_has_antilockbrakingsystem();
  if (antilockbrakingsystem_ == NULL) {
    antilockbrakingsystem_ = new ::AntiLockBrakingSystemEvent;
  }
  // @@protoc_insertion_point(field_mutable:ExceptionalVehicleState.antiLockBrakingSystem)
  return antilockbrakingsystem_;
}
inline ::AntiLockBrakingSystemEvent* ExceptionalVehicleState::release_antilockbrakingsystem() {
  // @@protoc_insertion_point(field_release:ExceptionalVehicleState.antiLockBrakingSystem)
  clear_has_antilockbrakingsystem();
  ::AntiLockBrakingSystemEvent* temp = antilockbrakingsystem_;
  antilockbrakingsystem_ = NULL;
  return temp;
}
inline void ExceptionalVehicleState::set_allocated_antilockbrakingsystem(::AntiLockBrakingSystemEvent* antilockbrakingsystem) {
  delete antilockbrakingsystem_;
  antilockbrakingsystem_ = antilockbrakingsystem;
  if (antilockbrakingsystem) {
    set_has_antilockbrakingsystem();
  } else {
    clear_has_antilockbrakingsystem();
  }
  // @@protoc_insertion_point(field_set_allocated:ExceptionalVehicleState.antiLockBrakingSystem)
}

// optional .ElectronicStabilityControlEvent electronicStabilityControl = 7;
inline bool ExceptionalVehicleState::has_electronicstabilitycontrol() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExceptionalVehicleState::set_has_electronicstabilitycontrol() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExceptionalVehicleState::clear_has_electronicstabilitycontrol() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExceptionalVehicleState::clear_electronicstabilitycontrol() {
  if (electronicstabilitycontrol_ != NULL) electronicstabilitycontrol_->::ElectronicStabilityControlEvent::Clear();
  clear_has_electronicstabilitycontrol();
}
inline const ::ElectronicStabilityControlEvent& ExceptionalVehicleState::electronicstabilitycontrol() const {
  // @@protoc_insertion_point(field_get:ExceptionalVehicleState.electronicStabilityControl)
  return electronicstabilitycontrol_ != NULL ? *electronicstabilitycontrol_ : *default_instance_->electronicstabilitycontrol_;
}
inline ::ElectronicStabilityControlEvent* ExceptionalVehicleState::mutable_electronicstabilitycontrol() {
  set_has_electronicstabilitycontrol();
  if (electronicstabilitycontrol_ == NULL) {
    electronicstabilitycontrol_ = new ::ElectronicStabilityControlEvent;
  }
  // @@protoc_insertion_point(field_mutable:ExceptionalVehicleState.electronicStabilityControl)
  return electronicstabilitycontrol_;
}
inline ::ElectronicStabilityControlEvent* ExceptionalVehicleState::release_electronicstabilitycontrol() {
  // @@protoc_insertion_point(field_release:ExceptionalVehicleState.electronicStabilityControl)
  clear_has_electronicstabilitycontrol();
  ::ElectronicStabilityControlEvent* temp = electronicstabilitycontrol_;
  electronicstabilitycontrol_ = NULL;
  return temp;
}
inline void ExceptionalVehicleState::set_allocated_electronicstabilitycontrol(::ElectronicStabilityControlEvent* electronicstabilitycontrol) {
  delete electronicstabilitycontrol_;
  electronicstabilitycontrol_ = electronicstabilitycontrol;
  if (electronicstabilitycontrol) {
    set_has_electronicstabilitycontrol();
  } else {
    clear_has_electronicstabilitycontrol();
  }
  // @@protoc_insertion_point(field_set_allocated:ExceptionalVehicleState.electronicStabilityControl)
}

// -------------------------------------------------------------------

// ProprietaryInfo

// required int64 timeStampUTC_ms = 1;
inline bool ProprietaryInfo::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProprietaryInfo::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProprietaryInfo::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProprietaryInfo::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 ProprietaryInfo::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:ProprietaryInfo.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void ProprietaryInfo::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:ProprietaryInfo.timeStampUTC_ms)
}

// repeated .KeyValuePairString keyValuePairs = 2;
inline int ProprietaryInfo::keyvaluepairs_size() const {
  return keyvaluepairs_.size();
}
inline void ProprietaryInfo::clear_keyvaluepairs() {
  keyvaluepairs_.Clear();
}
inline const ::KeyValuePairString& ProprietaryInfo::keyvaluepairs(int index) const {
  // @@protoc_insertion_point(field_get:ProprietaryInfo.keyValuePairs)
  return keyvaluepairs_.Get(index);
}
inline ::KeyValuePairString* ProprietaryInfo::mutable_keyvaluepairs(int index) {
  // @@protoc_insertion_point(field_mutable:ProprietaryInfo.keyValuePairs)
  return keyvaluepairs_.Mutable(index);
}
inline ::KeyValuePairString* ProprietaryInfo::add_keyvaluepairs() {
  // @@protoc_insertion_point(field_add:ProprietaryInfo.keyValuePairs)
  return keyvaluepairs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValuePairString >*
ProprietaryInfo::mutable_keyvaluepairs() {
  // @@protoc_insertion_point(field_mutable_list:ProprietaryInfo.keyValuePairs)
  return &keyvaluepairs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValuePairString >&
ProprietaryInfo::keyvaluepairs() const {
  // @@protoc_insertion_point(field_list:ProprietaryInfo.keyValuePairs)
  return keyvaluepairs_;
}

// -------------------------------------------------------------------

// EnvironmentStatus

// required int64 timeStampUTC_ms = 1;
inline bool EnvironmentStatus::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnvironmentStatus::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnvironmentStatus::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnvironmentStatus::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 EnvironmentStatus::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:EnvironmentStatus.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void EnvironmentStatus::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:EnvironmentStatus.timeStampUTC_ms)
}

// optional .EnvironmentStatus.LightConditionsEnum lightConditions = 2;
inline bool EnvironmentStatus::has_lightconditions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnvironmentStatus::set_has_lightconditions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnvironmentStatus::clear_has_lightconditions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnvironmentStatus::clear_lightconditions() {
  lightconditions_ = 1;
  clear_has_lightconditions();
}
inline ::EnvironmentStatus_LightConditionsEnum EnvironmentStatus::lightconditions() const {
  // @@protoc_insertion_point(field_get:EnvironmentStatus.lightConditions)
  return static_cast< ::EnvironmentStatus_LightConditionsEnum >(lightconditions_);
}
inline void EnvironmentStatus::set_lightconditions(::EnvironmentStatus_LightConditionsEnum value) {
  assert(::EnvironmentStatus_LightConditionsEnum_IsValid(value));
  set_has_lightconditions();
  lightconditions_ = value;
  // @@protoc_insertion_point(field_set:EnvironmentStatus.lightConditions)
}

// optional double externalAirTemperature_DegC = 3;
inline bool EnvironmentStatus::has_externalairtemperature_degc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnvironmentStatus::set_has_externalairtemperature_degc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnvironmentStatus::clear_has_externalairtemperature_degc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnvironmentStatus::clear_externalairtemperature_degc() {
  externalairtemperature_degc_ = 0;
  clear_has_externalairtemperature_degc();
}
inline double EnvironmentStatus::externalairtemperature_degc() const {
  // @@protoc_insertion_point(field_get:EnvironmentStatus.externalAirTemperature_DegC)
  return externalairtemperature_degc_;
}
inline void EnvironmentStatus::set_externalairtemperature_degc(double value) {
  set_has_externalairtemperature_degc();
  externalairtemperature_degc_ = value;
  // @@protoc_insertion_point(field_set:EnvironmentStatus.externalAirTemperature_DegC)
}

// optional double externalAirTemperatureAccuracy_DegC = 4;
inline bool EnvironmentStatus::has_externalairtemperatureaccuracy_degc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnvironmentStatus::set_has_externalairtemperatureaccuracy_degc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnvironmentStatus::clear_has_externalairtemperatureaccuracy_degc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnvironmentStatus::clear_externalairtemperatureaccuracy_degc() {
  externalairtemperatureaccuracy_degc_ = 0;
  clear_has_externalairtemperatureaccuracy_degc();
}
inline double EnvironmentStatus::externalairtemperatureaccuracy_degc() const {
  // @@protoc_insertion_point(field_get:EnvironmentStatus.externalAirTemperatureAccuracy_DegC)
  return externalairtemperatureaccuracy_degc_;
}
inline void EnvironmentStatus::set_externalairtemperatureaccuracy_degc(double value) {
  set_has_externalairtemperatureaccuracy_degc();
  externalairtemperatureaccuracy_degc_ = value;
  // @@protoc_insertion_point(field_set:EnvironmentStatus.externalAirTemperatureAccuracy_DegC)
}

// optional .EnvironmentStatus.PrecipitationEnum precipitation = 5;
inline bool EnvironmentStatus::has_precipitation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnvironmentStatus::set_has_precipitation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnvironmentStatus::clear_has_precipitation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnvironmentStatus::clear_precipitation() {
  precipitation_ = 1;
  clear_has_precipitation();
}
inline ::EnvironmentStatus_PrecipitationEnum EnvironmentStatus::precipitation() const {
  // @@protoc_insertion_point(field_get:EnvironmentStatus.precipitation)
  return static_cast< ::EnvironmentStatus_PrecipitationEnum >(precipitation_);
}
inline void EnvironmentStatus::set_precipitation(::EnvironmentStatus_PrecipitationEnum value) {
  assert(::EnvironmentStatus_PrecipitationEnum_IsValid(value));
  set_has_precipitation();
  precipitation_ = value;
  // @@protoc_insertion_point(field_set:EnvironmentStatus.precipitation)
}

// optional double visibleDistance_m = 6;
inline bool EnvironmentStatus::has_visibledistance_m() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EnvironmentStatus::set_has_visibledistance_m() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EnvironmentStatus::clear_has_visibledistance_m() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EnvironmentStatus::clear_visibledistance_m() {
  visibledistance_m_ = 0;
  clear_has_visibledistance_m();
}
inline double EnvironmentStatus::visibledistance_m() const {
  // @@protoc_insertion_point(field_get:EnvironmentStatus.visibleDistance_m)
  return visibledistance_m_;
}
inline void EnvironmentStatus::set_visibledistance_m(double value) {
  set_has_visibledistance_m();
  visibledistance_m_ = value;
  // @@protoc_insertion_point(field_set:EnvironmentStatus.visibleDistance_m)
}

// optional double roadSurfaceTemperature_DegC = 7;
inline bool EnvironmentStatus::has_roadsurfacetemperature_degc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EnvironmentStatus::set_has_roadsurfacetemperature_degc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EnvironmentStatus::clear_has_roadsurfacetemperature_degc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EnvironmentStatus::clear_roadsurfacetemperature_degc() {
  roadsurfacetemperature_degc_ = 0;
  clear_has_roadsurfacetemperature_degc();
}
inline double EnvironmentStatus::roadsurfacetemperature_degc() const {
  // @@protoc_insertion_point(field_get:EnvironmentStatus.roadSurfaceTemperature_DegC)
  return roadsurfacetemperature_degc_;
}
inline void EnvironmentStatus::set_roadsurfacetemperature_degc(double value) {
  set_has_roadsurfacetemperature_degc();
  roadsurfacetemperature_degc_ = value;
  // @@protoc_insertion_point(field_set:EnvironmentStatus.roadSurfaceTemperature_DegC)
}

// optional double roadSurfaceTemperatureAccuracy_DegC = 8;
inline bool EnvironmentStatus::has_roadsurfacetemperatureaccuracy_degc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EnvironmentStatus::set_has_roadsurfacetemperatureaccuracy_degc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EnvironmentStatus::clear_has_roadsurfacetemperatureaccuracy_degc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EnvironmentStatus::clear_roadsurfacetemperatureaccuracy_degc() {
  roadsurfacetemperatureaccuracy_degc_ = 0;
  clear_has_roadsurfacetemperatureaccuracy_degc();
}
inline double EnvironmentStatus::roadsurfacetemperatureaccuracy_degc() const {
  // @@protoc_insertion_point(field_get:EnvironmentStatus.roadSurfaceTemperatureAccuracy_DegC)
  return roadsurfacetemperatureaccuracy_degc_;
}
inline void EnvironmentStatus::set_roadsurfacetemperatureaccuracy_degc(double value) {
  set_has_roadsurfacetemperatureaccuracy_degc();
  roadsurfacetemperatureaccuracy_degc_ = value;
  // @@protoc_insertion_point(field_set:EnvironmentStatus.roadSurfaceTemperatureAccuracy_DegC)
}

// optional .EnvironmentStatus.RoadSurfaceTypeEnum roadSurfaceType = 9;
inline bool EnvironmentStatus::has_roadsurfacetype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EnvironmentStatus::set_has_roadsurfacetype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EnvironmentStatus::clear_has_roadsurfacetype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EnvironmentStatus::clear_roadsurfacetype() {
  roadsurfacetype_ = 1;
  clear_has_roadsurfacetype();
}
inline ::EnvironmentStatus_RoadSurfaceTypeEnum EnvironmentStatus::roadsurfacetype() const {
  // @@protoc_insertion_point(field_get:EnvironmentStatus.roadSurfaceType)
  return static_cast< ::EnvironmentStatus_RoadSurfaceTypeEnum >(roadsurfacetype_);
}
inline void EnvironmentStatus::set_roadsurfacetype(::EnvironmentStatus_RoadSurfaceTypeEnum value) {
  assert(::EnvironmentStatus_RoadSurfaceTypeEnum_IsValid(value));
  set_has_roadsurfacetype();
  roadsurfacetype_ = value;
  // @@protoc_insertion_point(field_set:EnvironmentStatus.roadSurfaceType)
}

// -------------------------------------------------------------------

// TrafficLightStatus

// optional .TrafficLightStatus.LightStatus green = 1;
inline bool TrafficLightStatus::has_green() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightStatus::set_has_green() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightStatus::clear_has_green() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightStatus::clear_green() {
  green_ = 1;
  clear_has_green();
}
inline ::TrafficLightStatus_LightStatus TrafficLightStatus::green() const {
  // @@protoc_insertion_point(field_get:TrafficLightStatus.green)
  return static_cast< ::TrafficLightStatus_LightStatus >(green_);
}
inline void TrafficLightStatus::set_green(::TrafficLightStatus_LightStatus value) {
  assert(::TrafficLightStatus_LightStatus_IsValid(value));
  set_has_green();
  green_ = value;
  // @@protoc_insertion_point(field_set:TrafficLightStatus.green)
}

// optional .TrafficLightStatus.LightStatus yellow = 2;
inline bool TrafficLightStatus::has_yellow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightStatus::set_has_yellow() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightStatus::clear_has_yellow() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightStatus::clear_yellow() {
  yellow_ = 1;
  clear_has_yellow();
}
inline ::TrafficLightStatus_LightStatus TrafficLightStatus::yellow() const {
  // @@protoc_insertion_point(field_get:TrafficLightStatus.yellow)
  return static_cast< ::TrafficLightStatus_LightStatus >(yellow_);
}
inline void TrafficLightStatus::set_yellow(::TrafficLightStatus_LightStatus value) {
  assert(::TrafficLightStatus_LightStatus_IsValid(value));
  set_has_yellow();
  yellow_ = value;
  // @@protoc_insertion_point(field_set:TrafficLightStatus.yellow)
}

// optional .TrafficLightStatus.LightStatus red = 3;
inline bool TrafficLightStatus::has_red() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightStatus::set_has_red() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightStatus::clear_has_red() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightStatus::clear_red() {
  red_ = 1;
  clear_has_red();
}
inline ::TrafficLightStatus_LightStatus TrafficLightStatus::red() const {
  // @@protoc_insertion_point(field_get:TrafficLightStatus.red)
  return static_cast< ::TrafficLightStatus_LightStatus >(red_);
}
inline void TrafficLightStatus::set_red(::TrafficLightStatus_LightStatus value) {
  assert(::TrafficLightStatus_LightStatus_IsValid(value));
  set_has_red();
  red_ = value;
  // @@protoc_insertion_point(field_set:TrafficLightStatus.red)
}

// optional .TrafficLightStatus.LightStatus other = 4;
inline bool TrafficLightStatus::has_other() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightStatus::set_has_other() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightStatus::clear_has_other() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLightStatus::clear_other() {
  other_ = 1;
  clear_has_other();
}
inline ::TrafficLightStatus_LightStatus TrafficLightStatus::other() const {
  // @@protoc_insertion_point(field_get:TrafficLightStatus.other)
  return static_cast< ::TrafficLightStatus_LightStatus >(other_);
}
inline void TrafficLightStatus::set_other(::TrafficLightStatus_LightStatus value) {
  assert(::TrafficLightStatus_LightStatus_IsValid(value));
  set_has_other();
  other_ = value;
  // @@protoc_insertion_point(field_set:TrafficLightStatus.other)
}

// -------------------------------------------------------------------

// ObjectDetection

// required int64 timeStampUTC_ms = 1;
inline bool ObjectDetection::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectDetection::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectDetection::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectDetection::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 ObjectDetection::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void ObjectDetection::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:ObjectDetection.timeStampUTC_ms)
}

// optional int64 detectedObjectID = 2;
inline bool ObjectDetection::has_detectedobjectid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectDetection::set_has_detectedobjectid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectDetection::clear_has_detectedobjectid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectDetection::clear_detectedobjectid() {
  detectedobjectid_ = GOOGLE_LONGLONG(0);
  clear_has_detectedobjectid();
}
inline ::google::protobuf::int64 ObjectDetection::detectedobjectid() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.detectedObjectID)
  return detectedobjectid_;
}
inline void ObjectDetection::set_detectedobjectid(::google::protobuf::int64 value) {
  set_has_detectedobjectid();
  detectedobjectid_ = value;
  // @@protoc_insertion_point(field_set:ObjectDetection.detectedObjectID)
}

// optional .PositionOffset positionOffset = 3;
inline bool ObjectDetection::has_positionoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectDetection::set_has_positionoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectDetection::clear_has_positionoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectDetection::clear_positionoffset() {
  if (positionoffset_ != NULL) positionoffset_->::PositionOffset::Clear();
  clear_has_positionoffset();
}
inline const ::PositionOffset& ObjectDetection::positionoffset() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.positionOffset)
  return positionoffset_ != NULL ? *positionoffset_ : *default_instance_->positionoffset_;
}
inline ::PositionOffset* ObjectDetection::mutable_positionoffset() {
  set_has_positionoffset();
  if (positionoffset_ == NULL) {
    positionoffset_ = new ::PositionOffset;
  }
  // @@protoc_insertion_point(field_mutable:ObjectDetection.positionOffset)
  return positionoffset_;
}
inline ::PositionOffset* ObjectDetection::release_positionoffset() {
  // @@protoc_insertion_point(field_release:ObjectDetection.positionOffset)
  clear_has_positionoffset();
  ::PositionOffset* temp = positionoffset_;
  positionoffset_ = NULL;
  return temp;
}
inline void ObjectDetection::set_allocated_positionoffset(::PositionOffset* positionoffset) {
  delete positionoffset_;
  positionoffset_ = positionoffset;
  if (positionoffset) {
    set_has_positionoffset();
  } else {
    clear_has_positionoffset();
  }
  // @@protoc_insertion_point(field_set_allocated:ObjectDetection.positionOffset)
}

// optional .Vector3D movingVector_mps = 4;
inline bool ObjectDetection::has_movingvector_mps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectDetection::set_has_movingvector_mps() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObjectDetection::clear_has_movingvector_mps() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObjectDetection::clear_movingvector_mps() {
  if (movingvector_mps_ != NULL) movingvector_mps_->::Vector3D::Clear();
  clear_has_movingvector_mps();
}
inline const ::Vector3D& ObjectDetection::movingvector_mps() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.movingVector_mps)
  return movingvector_mps_ != NULL ? *movingvector_mps_ : *default_instance_->movingvector_mps_;
}
inline ::Vector3D* ObjectDetection::mutable_movingvector_mps() {
  set_has_movingvector_mps();
  if (movingvector_mps_ == NULL) {
    movingvector_mps_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ObjectDetection.movingVector_mps)
  return movingvector_mps_;
}
inline ::Vector3D* ObjectDetection::release_movingvector_mps() {
  // @@protoc_insertion_point(field_release:ObjectDetection.movingVector_mps)
  clear_has_movingvector_mps();
  ::Vector3D* temp = movingvector_mps_;
  movingvector_mps_ = NULL;
  return temp;
}
inline void ObjectDetection::set_allocated_movingvector_mps(::Vector3D* movingvector_mps) {
  delete movingvector_mps_;
  movingvector_mps_ = movingvector_mps;
  if (movingvector_mps) {
    set_has_movingvector_mps();
  } else {
    clear_has_movingvector_mps();
  }
  // @@protoc_insertion_point(field_set_allocated:ObjectDetection.movingVector_mps)
}

// optional .ObjectDetection.ObjectTypeEnum objectType = 5;
inline bool ObjectDetection::has_objecttype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObjectDetection::set_has_objecttype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObjectDetection::clear_has_objecttype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObjectDetection::clear_objecttype() {
  objecttype_ = 1;
  clear_has_objecttype();
}
inline ::ObjectDetection_ObjectTypeEnum ObjectDetection::objecttype() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.objectType)
  return static_cast< ::ObjectDetection_ObjectTypeEnum >(objecttype_);
}
inline void ObjectDetection::set_objecttype(::ObjectDetection_ObjectTypeEnum value) {
  assert(::ObjectDetection_ObjectTypeEnum_IsValid(value));
  set_has_objecttype();
  objecttype_ = value;
  // @@protoc_insertion_point(field_set:ObjectDetection.objectType)
}

// optional .Vector3D objectSizeVector_m = 6;
inline bool ObjectDetection::has_objectsizevector_m() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObjectDetection::set_has_objectsizevector_m() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObjectDetection::clear_has_objectsizevector_m() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObjectDetection::clear_objectsizevector_m() {
  if (objectsizevector_m_ != NULL) objectsizevector_m_->::Vector3D::Clear();
  clear_has_objectsizevector_m();
}
inline const ::Vector3D& ObjectDetection::objectsizevector_m() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.objectSizeVector_m)
  return objectsizevector_m_ != NULL ? *objectsizevector_m_ : *default_instance_->objectsizevector_m_;
}
inline ::Vector3D* ObjectDetection::mutable_objectsizevector_m() {
  set_has_objectsizevector_m();
  if (objectsizevector_m_ == NULL) {
    objectsizevector_m_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ObjectDetection.objectSizeVector_m)
  return objectsizevector_m_;
}
inline ::Vector3D* ObjectDetection::release_objectsizevector_m() {
  // @@protoc_insertion_point(field_release:ObjectDetection.objectSizeVector_m)
  clear_has_objectsizevector_m();
  ::Vector3D* temp = objectsizevector_m_;
  objectsizevector_m_ = NULL;
  return temp;
}
inline void ObjectDetection::set_allocated_objectsizevector_m(::Vector3D* objectsizevector_m) {
  delete objectsizevector_m_;
  objectsizevector_m_ = objectsizevector_m;
  if (objectsizevector_m) {
    set_has_objectsizevector_m();
  } else {
    clear_has_objectsizevector_m();
  }
  // @@protoc_insertion_point(field_set_allocated:ObjectDetection.objectSizeVector_m)
}

// optional .Vector3D objectSizeAccuracyVector_m = 7;
inline bool ObjectDetection::has_objectsizeaccuracyvector_m() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObjectDetection::set_has_objectsizeaccuracyvector_m() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObjectDetection::clear_has_objectsizeaccuracyvector_m() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObjectDetection::clear_objectsizeaccuracyvector_m() {
  if (objectsizeaccuracyvector_m_ != NULL) objectsizeaccuracyvector_m_->::Vector3D::Clear();
  clear_has_objectsizeaccuracyvector_m();
}
inline const ::Vector3D& ObjectDetection::objectsizeaccuracyvector_m() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.objectSizeAccuracyVector_m)
  return objectsizeaccuracyvector_m_ != NULL ? *objectsizeaccuracyvector_m_ : *default_instance_->objectsizeaccuracyvector_m_;
}
inline ::Vector3D* ObjectDetection::mutable_objectsizeaccuracyvector_m() {
  set_has_objectsizeaccuracyvector_m();
  if (objectsizeaccuracyvector_m_ == NULL) {
    objectsizeaccuracyvector_m_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:ObjectDetection.objectSizeAccuracyVector_m)
  return objectsizeaccuracyvector_m_;
}
inline ::Vector3D* ObjectDetection::release_objectsizeaccuracyvector_m() {
  // @@protoc_insertion_point(field_release:ObjectDetection.objectSizeAccuracyVector_m)
  clear_has_objectsizeaccuracyvector_m();
  ::Vector3D* temp = objectsizeaccuracyvector_m_;
  objectsizeaccuracyvector_m_ = NULL;
  return temp;
}
inline void ObjectDetection::set_allocated_objectsizeaccuracyvector_m(::Vector3D* objectsizeaccuracyvector_m) {
  delete objectsizeaccuracyvector_m_;
  objectsizeaccuracyvector_m_ = objectsizeaccuracyvector_m;
  if (objectsizeaccuracyvector_m) {
    set_has_objectsizeaccuracyvector_m();
  } else {
    clear_has_objectsizeaccuracyvector_m();
  }
  // @@protoc_insertion_point(field_set_allocated:ObjectDetection.objectSizeAccuracyVector_m)
}

// optional int64 mediaID = 8;
inline bool ObjectDetection::has_mediaid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ObjectDetection::set_has_mediaid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ObjectDetection::clear_has_mediaid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ObjectDetection::clear_mediaid() {
  mediaid_ = GOOGLE_LONGLONG(0);
  clear_has_mediaid();
}
inline ::google::protobuf::int64 ObjectDetection::mediaid() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.mediaID)
  return mediaid_;
}
inline void ObjectDetection::set_mediaid(::google::protobuf::int64 value) {
  set_has_mediaid();
  mediaid_ = value;
  // @@protoc_insertion_point(field_set:ObjectDetection.mediaID)
}

// optional .TrafficLightStatus trafficLightStatus = 1000;
inline bool ObjectDetection::has_trafficlightstatus() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ObjectDetection::set_has_trafficlightstatus() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ObjectDetection::clear_has_trafficlightstatus() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ObjectDetection::clear_trafficlightstatus() {
  if (trafficlightstatus_ != NULL) trafficlightstatus_->::TrafficLightStatus::Clear();
  clear_has_trafficlightstatus();
}
inline const ::TrafficLightStatus& ObjectDetection::trafficlightstatus() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.trafficLightStatus)
  return trafficlightstatus_ != NULL ? *trafficlightstatus_ : *default_instance_->trafficlightstatus_;
}
inline ::TrafficLightStatus* ObjectDetection::mutable_trafficlightstatus() {
  set_has_trafficlightstatus();
  if (trafficlightstatus_ == NULL) {
    trafficlightstatus_ = new ::TrafficLightStatus;
  }
  // @@protoc_insertion_point(field_mutable:ObjectDetection.trafficLightStatus)
  return trafficlightstatus_;
}
inline ::TrafficLightStatus* ObjectDetection::release_trafficlightstatus() {
  // @@protoc_insertion_point(field_release:ObjectDetection.trafficLightStatus)
  clear_has_trafficlightstatus();
  ::TrafficLightStatus* temp = trafficlightstatus_;
  trafficlightstatus_ = NULL;
  return temp;
}
inline void ObjectDetection::set_allocated_trafficlightstatus(::TrafficLightStatus* trafficlightstatus) {
  delete trafficlightstatus_;
  trafficlightstatus_ = trafficlightstatus;
  if (trafficlightstatus) {
    set_has_trafficlightstatus();
  } else {
    clear_has_trafficlightstatus();
  }
  // @@protoc_insertion_point(field_set_allocated:ObjectDetection.trafficLightStatus)
}

// optional uint32 objectDetectionConfidence_percent = 1001;
inline bool ObjectDetection::has_objectdetectionconfidence_percent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ObjectDetection::set_has_objectdetectionconfidence_percent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ObjectDetection::clear_has_objectdetectionconfidence_percent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ObjectDetection::clear_objectdetectionconfidence_percent() {
  objectdetectionconfidence_percent_ = 0u;
  clear_has_objectdetectionconfidence_percent();
}
inline ::google::protobuf::uint32 ObjectDetection::objectdetectionconfidence_percent() const {
  // @@protoc_insertion_point(field_get:ObjectDetection.objectDetectionConfidence_percent)
  return objectdetectionconfidence_percent_;
}
inline void ObjectDetection::set_objectdetectionconfidence_percent(::google::protobuf::uint32 value) {
  set_has_objectdetectionconfidence_percent();
  objectdetectionconfidence_percent_ = value;
  // @@protoc_insertion_point(field_set:ObjectDetection.objectDetectionConfidence_percent)
}

// -------------------------------------------------------------------

// ADServiceAndSensorState

// required int64 timeStampUTC_ms = 1;
inline bool ADServiceAndSensorState::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ADServiceAndSensorState::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ADServiceAndSensorState::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ADServiceAndSensorState::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 ADServiceAndSensorState::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void ADServiceAndSensorState::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.timeStampUTC_ms)
}

// optional bool adSpeedControl = 2;
inline bool ADServiceAndSensorState::has_adspeedcontrol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ADServiceAndSensorState::set_has_adspeedcontrol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ADServiceAndSensorState::clear_has_adspeedcontrol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ADServiceAndSensorState::clear_adspeedcontrol() {
  adspeedcontrol_ = false;
  clear_has_adspeedcontrol();
}
inline bool ADServiceAndSensorState::adspeedcontrol() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.adSpeedControl)
  return adspeedcontrol_;
}
inline void ADServiceAndSensorState::set_adspeedcontrol(bool value) {
  set_has_adspeedcontrol();
  adspeedcontrol_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.adSpeedControl)
}

// optional bool adBrakeControl = 3;
inline bool ADServiceAndSensorState::has_adbrakecontrol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ADServiceAndSensorState::set_has_adbrakecontrol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ADServiceAndSensorState::clear_has_adbrakecontrol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ADServiceAndSensorState::clear_adbrakecontrol() {
  adbrakecontrol_ = false;
  clear_has_adbrakecontrol();
}
inline bool ADServiceAndSensorState::adbrakecontrol() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.adBrakeControl)
  return adbrakecontrol_;
}
inline void ADServiceAndSensorState::set_adbrakecontrol(bool value) {
  set_has_adbrakecontrol();
  adbrakecontrol_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.adBrakeControl)
}

// optional bool adSteeringControl = 4;
inline bool ADServiceAndSensorState::has_adsteeringcontrol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ADServiceAndSensorState::set_has_adsteeringcontrol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ADServiceAndSensorState::clear_has_adsteeringcontrol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ADServiceAndSensorState::clear_adsteeringcontrol() {
  adsteeringcontrol_ = false;
  clear_has_adsteeringcontrol();
}
inline bool ADServiceAndSensorState::adsteeringcontrol() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.adSteeringControl)
  return adsteeringcontrol_;
}
inline void ADServiceAndSensorState::set_adsteeringcontrol(bool value) {
  set_has_adsteeringcontrol();
  adsteeringcontrol_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.adSteeringControl)
}

// optional bool adConnectionAvailable = 5;
inline bool ADServiceAndSensorState::has_adconnectionavailable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ADServiceAndSensorState::set_has_adconnectionavailable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ADServiceAndSensorState::clear_has_adconnectionavailable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ADServiceAndSensorState::clear_adconnectionavailable() {
  adconnectionavailable_ = false;
  clear_has_adconnectionavailable();
}
inline bool ADServiceAndSensorState::adconnectionavailable() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.adConnectionAvailable)
  return adconnectionavailable_;
}
inline void ADServiceAndSensorState::set_adconnectionavailable(bool value) {
  set_has_adconnectionavailable();
  adconnectionavailable_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.adConnectionAvailable)
}

// optional bool sensorObjectRecognition = 6;
inline bool ADServiceAndSensorState::has_sensorobjectrecognition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ADServiceAndSensorState::set_has_sensorobjectrecognition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ADServiceAndSensorState::clear_has_sensorobjectrecognition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ADServiceAndSensorState::clear_sensorobjectrecognition() {
  sensorobjectrecognition_ = false;
  clear_has_sensorobjectrecognition();
}
inline bool ADServiceAndSensorState::sensorobjectrecognition() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.sensorObjectRecognition)
  return sensorobjectrecognition_;
}
inline void ADServiceAndSensorState::set_sensorobjectrecognition(bool value) {
  set_has_sensorobjectrecognition();
  sensorobjectrecognition_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.sensorObjectRecognition)
}

// optional bool sensorSignRecognition = 7;
inline bool ADServiceAndSensorState::has_sensorsignrecognition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ADServiceAndSensorState::set_has_sensorsignrecognition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ADServiceAndSensorState::clear_has_sensorsignrecognition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ADServiceAndSensorState::clear_sensorsignrecognition() {
  sensorsignrecognition_ = false;
  clear_has_sensorsignrecognition();
}
inline bool ADServiceAndSensorState::sensorsignrecognition() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.sensorSignRecognition)
  return sensorsignrecognition_;
}
inline void ADServiceAndSensorState::set_sensorsignrecognition(bool value) {
  set_has_sensorsignrecognition();
  sensorsignrecognition_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.sensorSignRecognition)
}

// optional bool sensorLaneRecognition = 8;
inline bool ADServiceAndSensorState::has_sensorlanerecognition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ADServiceAndSensorState::set_has_sensorlanerecognition() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ADServiceAndSensorState::clear_has_sensorlanerecognition() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ADServiceAndSensorState::clear_sensorlanerecognition() {
  sensorlanerecognition_ = false;
  clear_has_sensorlanerecognition();
}
inline bool ADServiceAndSensorState::sensorlanerecognition() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.sensorLaneRecognition)
  return sensorlanerecognition_;
}
inline void ADServiceAndSensorState::set_sensorlanerecognition(bool value) {
  set_has_sensorlanerecognition();
  sensorlanerecognition_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.sensorLaneRecognition)
}

// optional bool sensorRoadSurface = 9;
inline bool ADServiceAndSensorState::has_sensorroadsurface() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ADServiceAndSensorState::set_has_sensorroadsurface() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ADServiceAndSensorState::clear_has_sensorroadsurface() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ADServiceAndSensorState::clear_sensorroadsurface() {
  sensorroadsurface_ = false;
  clear_has_sensorroadsurface();
}
inline bool ADServiceAndSensorState::sensorroadsurface() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.sensorRoadSurface)
  return sensorroadsurface_;
}
inline void ADServiceAndSensorState::set_sensorroadsurface(bool value) {
  set_has_sensorroadsurface();
  sensorroadsurface_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.sensorRoadSurface)
}

// optional bool sensorEnvironment = 10;
inline bool ADServiceAndSensorState::has_sensorenvironment() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ADServiceAndSensorState::set_has_sensorenvironment() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ADServiceAndSensorState::clear_has_sensorenvironment() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ADServiceAndSensorState::clear_sensorenvironment() {
  sensorenvironment_ = false;
  clear_has_sensorenvironment();
}
inline bool ADServiceAndSensorState::sensorenvironment() const {
  // @@protoc_insertion_point(field_get:ADServiceAndSensorState.sensorEnvironment)
  return sensorenvironment_;
}
inline void ADServiceAndSensorState::set_sensorenvironment(bool value) {
  set_has_sensorenvironment();
  sensorenvironment_ = value;
  // @@protoc_insertion_point(field_set:ADServiceAndSensorState.sensorEnvironment)
}

// -------------------------------------------------------------------

// EgoMotion

// required int64 timeStampUTC_ms = 1;
inline bool EgoMotion::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgoMotion::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgoMotion::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgoMotion::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 EgoMotion::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:EgoMotion.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void EgoMotion::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:EgoMotion.timeStampUTC_ms)
}

// optional int64 egoMotionVariant = 2;
inline bool EgoMotion::has_egomotionvariant() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgoMotion::set_has_egomotionvariant() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgoMotion::clear_has_egomotionvariant() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgoMotion::clear_egomotionvariant() {
  egomotionvariant_ = GOOGLE_LONGLONG(0);
  clear_has_egomotionvariant();
}
inline ::google::protobuf::int64 EgoMotion::egomotionvariant() const {
  // @@protoc_insertion_point(field_get:EgoMotion.egoMotionVariant)
  return egomotionvariant_;
}
inline void EgoMotion::set_egomotionvariant(::google::protobuf::int64 value) {
  set_has_egomotionvariant();
  egomotionvariant_ = value;
  // @@protoc_insertion_point(field_set:EgoMotion.egoMotionVariant)
}

// optional .PositionOffset egoPosition = 3;
inline bool EgoMotion::has_egoposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgoMotion::set_has_egoposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgoMotion::clear_has_egoposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgoMotion::clear_egoposition() {
  if (egoposition_ != NULL) egoposition_->::PositionOffset::Clear();
  clear_has_egoposition();
}
inline const ::PositionOffset& EgoMotion::egoposition() const {
  // @@protoc_insertion_point(field_get:EgoMotion.egoPosition)
  return egoposition_ != NULL ? *egoposition_ : *default_instance_->egoposition_;
}
inline ::PositionOffset* EgoMotion::mutable_egoposition() {
  set_has_egoposition();
  if (egoposition_ == NULL) {
    egoposition_ = new ::PositionOffset;
  }
  // @@protoc_insertion_point(field_mutable:EgoMotion.egoPosition)
  return egoposition_;
}
inline ::PositionOffset* EgoMotion::release_egoposition() {
  // @@protoc_insertion_point(field_release:EgoMotion.egoPosition)
  clear_has_egoposition();
  ::PositionOffset* temp = egoposition_;
  egoposition_ = NULL;
  return temp;
}
inline void EgoMotion::set_allocated_egoposition(::PositionOffset* egoposition) {
  delete egoposition_;
  egoposition_ = egoposition;
  if (egoposition) {
    set_has_egoposition();
  } else {
    clear_has_egoposition();
  }
  // @@protoc_insertion_point(field_set_allocated:EgoMotion.egoPosition)
}

// optional .Vector3D egoOrientation = 4;
inline bool EgoMotion::has_egoorientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EgoMotion::set_has_egoorientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EgoMotion::clear_has_egoorientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EgoMotion::clear_egoorientation() {
  if (egoorientation_ != NULL) egoorientation_->::Vector3D::Clear();
  clear_has_egoorientation();
}
inline const ::Vector3D& EgoMotion::egoorientation() const {
  // @@protoc_insertion_point(field_get:EgoMotion.egoOrientation)
  return egoorientation_ != NULL ? *egoorientation_ : *default_instance_->egoorientation_;
}
inline ::Vector3D* EgoMotion::mutable_egoorientation() {
  set_has_egoorientation();
  if (egoorientation_ == NULL) {
    egoorientation_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:EgoMotion.egoOrientation)
  return egoorientation_;
}
inline ::Vector3D* EgoMotion::release_egoorientation() {
  // @@protoc_insertion_point(field_release:EgoMotion.egoOrientation)
  clear_has_egoorientation();
  ::Vector3D* temp = egoorientation_;
  egoorientation_ = NULL;
  return temp;
}
inline void EgoMotion::set_allocated_egoorientation(::Vector3D* egoorientation) {
  delete egoorientation_;
  egoorientation_ = egoorientation;
  if (egoorientation) {
    set_has_egoorientation();
  } else {
    clear_has_egoorientation();
  }
  // @@protoc_insertion_point(field_set_allocated:EgoMotion.egoOrientation)
}

// optional int64 mediaID = 8;
inline bool EgoMotion::has_mediaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EgoMotion::set_has_mediaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EgoMotion::clear_has_mediaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EgoMotion::clear_mediaid() {
  mediaid_ = GOOGLE_LONGLONG(0);
  clear_has_mediaid();
}
inline ::google::protobuf::int64 EgoMotion::mediaid() const {
  // @@protoc_insertion_point(field_get:EgoMotion.mediaID)
  return mediaid_;
}
inline void EgoMotion::set_mediaid(::google::protobuf::int64 value) {
  set_has_mediaid();
  mediaid_ = value;
  // @@protoc_insertion_point(field_set:EgoMotion.mediaID)
}

// -------------------------------------------------------------------

// RawGNSSSatData

// required int64 timeStampUTC_ms = 1;
inline bool RawGNSSSatData::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawGNSSSatData::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawGNSSSatData::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawGNSSSatData::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 RawGNSSSatData::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:RawGNSSSatData.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void RawGNSSSatData::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:RawGNSSSatData.timeStampUTC_ms)
}

// required .RawGNSSSatData.RawGNSSSatDataType rawGNSSSatDataType = 2;
inline bool RawGNSSSatData::has_rawgnsssatdatatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawGNSSSatData::set_has_rawgnsssatdatatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawGNSSSatData::clear_has_rawgnsssatdatatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawGNSSSatData::clear_rawgnsssatdatatype() {
  rawgnsssatdatatype_ = 1;
  clear_has_rawgnsssatdatatype();
}
inline ::RawGNSSSatData_RawGNSSSatDataType RawGNSSSatData::rawgnsssatdatatype() const {
  // @@protoc_insertion_point(field_get:RawGNSSSatData.rawGNSSSatDataType)
  return static_cast< ::RawGNSSSatData_RawGNSSSatDataType >(rawgnsssatdatatype_);
}
inline void RawGNSSSatData::set_rawgnsssatdatatype(::RawGNSSSatData_RawGNSSSatDataType value) {
  assert(::RawGNSSSatData_RawGNSSSatDataType_IsValid(value));
  set_has_rawgnsssatdatatype();
  rawgnsssatdatatype_ = value;
  // @@protoc_insertion_point(field_set:RawGNSSSatData.rawGNSSSatDataType)
}

// optional bytes rawData = 3;
inline bool RawGNSSSatData::has_rawdata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RawGNSSSatData::set_has_rawdata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RawGNSSSatData::clear_has_rawdata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RawGNSSSatData::clear_rawdata() {
  rawdata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rawdata();
}
inline const ::std::string& RawGNSSSatData::rawdata() const {
  // @@protoc_insertion_point(field_get:RawGNSSSatData.rawData)
  return rawdata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawGNSSSatData::set_rawdata(const ::std::string& value) {
  set_has_rawdata();
  rawdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RawGNSSSatData.rawData)
}
inline void RawGNSSSatData::set_rawdata(const char* value) {
  set_has_rawdata();
  rawdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RawGNSSSatData.rawData)
}
inline void RawGNSSSatData::set_rawdata(const void* value, size_t size) {
  set_has_rawdata();
  rawdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RawGNSSSatData.rawData)
}
inline ::std::string* RawGNSSSatData::mutable_rawdata() {
  set_has_rawdata();
  // @@protoc_insertion_point(field_mutable:RawGNSSSatData.rawData)
  return rawdata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawGNSSSatData::release_rawdata() {
  // @@protoc_insertion_point(field_release:RawGNSSSatData.rawData)
  clear_has_rawdata();
  return rawdata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawGNSSSatData::set_allocated_rawdata(::std::string* rawdata) {
  if (rawdata != NULL) {
    set_has_rawdata();
  } else {
    clear_has_rawdata();
  }
  rawdata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rawdata);
  // @@protoc_insertion_point(field_set_allocated:RawGNSSSatData.rawData)
}

// -------------------------------------------------------------------

// PathEvents

// repeated .VehicleStatus vehicleStatus = 1;
inline int PathEvents::vehiclestatus_size() const {
  return vehiclestatus_.size();
}
inline void PathEvents::clear_vehiclestatus() {
  vehiclestatus_.Clear();
}
inline const ::VehicleStatus& PathEvents::vehiclestatus(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.vehicleStatus)
  return vehiclestatus_.Get(index);
}
inline ::VehicleStatus* PathEvents::mutable_vehiclestatus(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.vehicleStatus)
  return vehiclestatus_.Mutable(index);
}
inline ::VehicleStatus* PathEvents::add_vehiclestatus() {
  // @@protoc_insertion_point(field_add:PathEvents.vehicleStatus)
  return vehiclestatus_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::VehicleStatus >*
PathEvents::mutable_vehiclestatus() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.vehicleStatus)
  return &vehiclestatus_;
}
inline const ::google::protobuf::RepeatedPtrField< ::VehicleStatus >&
PathEvents::vehiclestatus() const {
  // @@protoc_insertion_point(field_list:PathEvents.vehicleStatus)
  return vehiclestatus_;
}

// repeated .VehicleDynamics vehicleDynamics = 2;
inline int PathEvents::vehicledynamics_size() const {
  return vehicledynamics_.size();
}
inline void PathEvents::clear_vehicledynamics() {
  vehicledynamics_.Clear();
}
inline const ::VehicleDynamics& PathEvents::vehicledynamics(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.vehicleDynamics)
  return vehicledynamics_.Get(index);
}
inline ::VehicleDynamics* PathEvents::mutable_vehicledynamics(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.vehicleDynamics)
  return vehicledynamics_.Mutable(index);
}
inline ::VehicleDynamics* PathEvents::add_vehicledynamics() {
  // @@protoc_insertion_point(field_add:PathEvents.vehicleDynamics)
  return vehicledynamics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::VehicleDynamics >*
PathEvents::mutable_vehicledynamics() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.vehicleDynamics)
  return &vehicledynamics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::VehicleDynamics >&
PathEvents::vehicledynamics() const {
  // @@protoc_insertion_point(field_list:PathEvents.vehicleDynamics)
  return vehicledynamics_;
}

// repeated .SignRecognition signRecognition = 3;
inline int PathEvents::signrecognition_size() const {
  return signrecognition_.size();
}
inline void PathEvents::clear_signrecognition() {
  signrecognition_.Clear();
}
inline const ::SignRecognition& PathEvents::signrecognition(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.signRecognition)
  return signrecognition_.Get(index);
}
inline ::SignRecognition* PathEvents::mutable_signrecognition(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.signRecognition)
  return signrecognition_.Mutable(index);
}
inline ::SignRecognition* PathEvents::add_signrecognition() {
  // @@protoc_insertion_point(field_add:PathEvents.signRecognition)
  return signrecognition_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SignRecognition >*
PathEvents::mutable_signrecognition() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.signRecognition)
  return &signrecognition_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SignRecognition >&
PathEvents::signrecognition() const {
  // @@protoc_insertion_point(field_list:PathEvents.signRecognition)
  return signrecognition_;
}

// repeated .LaneBoundaryRecognition laneBoundaryRecognition = 4;
inline int PathEvents::laneboundaryrecognition_size() const {
  return laneboundaryrecognition_.size();
}
inline void PathEvents::clear_laneboundaryrecognition() {
  laneboundaryrecognition_.Clear();
}
inline const ::LaneBoundaryRecognition& PathEvents::laneboundaryrecognition(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.laneBoundaryRecognition)
  return laneboundaryrecognition_.Get(index);
}
inline ::LaneBoundaryRecognition* PathEvents::mutable_laneboundaryrecognition(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.laneBoundaryRecognition)
  return laneboundaryrecognition_.Mutable(index);
}
inline ::LaneBoundaryRecognition* PathEvents::add_laneboundaryrecognition() {
  // @@protoc_insertion_point(field_add:PathEvents.laneBoundaryRecognition)
  return laneboundaryrecognition_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::LaneBoundaryRecognition >*
PathEvents::mutable_laneboundaryrecognition() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.laneBoundaryRecognition)
  return &laneboundaryrecognition_;
}
inline const ::google::protobuf::RepeatedPtrField< ::LaneBoundaryRecognition >&
PathEvents::laneboundaryrecognition() const {
  // @@protoc_insertion_point(field_list:PathEvents.laneBoundaryRecognition)
  return laneboundaryrecognition_;
}

// repeated .ExceptionalVehicleState exceptionalVehicleState = 5;
inline int PathEvents::exceptionalvehiclestate_size() const {
  return exceptionalvehiclestate_.size();
}
inline void PathEvents::clear_exceptionalvehiclestate() {
  exceptionalvehiclestate_.Clear();
}
inline const ::ExceptionalVehicleState& PathEvents::exceptionalvehiclestate(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.exceptionalVehicleState)
  return exceptionalvehiclestate_.Get(index);
}
inline ::ExceptionalVehicleState* PathEvents::mutable_exceptionalvehiclestate(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.exceptionalVehicleState)
  return exceptionalvehiclestate_.Mutable(index);
}
inline ::ExceptionalVehicleState* PathEvents::add_exceptionalvehiclestate() {
  // @@protoc_insertion_point(field_add:PathEvents.exceptionalVehicleState)
  return exceptionalvehiclestate_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ExceptionalVehicleState >*
PathEvents::mutable_exceptionalvehiclestate() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.exceptionalVehicleState)
  return &exceptionalvehiclestate_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ExceptionalVehicleState >&
PathEvents::exceptionalvehiclestate() const {
  // @@protoc_insertion_point(field_list:PathEvents.exceptionalVehicleState)
  return exceptionalvehiclestate_;
}

// repeated .ProprietaryInfo proprietaryInfo = 6;
inline int PathEvents::proprietaryinfo_size() const {
  return proprietaryinfo_.size();
}
inline void PathEvents::clear_proprietaryinfo() {
  proprietaryinfo_.Clear();
}
inline const ::ProprietaryInfo& PathEvents::proprietaryinfo(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.proprietaryInfo)
  return proprietaryinfo_.Get(index);
}
inline ::ProprietaryInfo* PathEvents::mutable_proprietaryinfo(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.proprietaryInfo)
  return proprietaryinfo_.Mutable(index);
}
inline ::ProprietaryInfo* PathEvents::add_proprietaryinfo() {
  // @@protoc_insertion_point(field_add:PathEvents.proprietaryInfo)
  return proprietaryinfo_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ProprietaryInfo >*
PathEvents::mutable_proprietaryinfo() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.proprietaryInfo)
  return &proprietaryinfo_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ProprietaryInfo >&
PathEvents::proprietaryinfo() const {
  // @@protoc_insertion_point(field_list:PathEvents.proprietaryInfo)
  return proprietaryinfo_;
}

// repeated .EnvironmentStatus environmentStatus = 7;
inline int PathEvents::environmentstatus_size() const {
  return environmentstatus_.size();
}
inline void PathEvents::clear_environmentstatus() {
  environmentstatus_.Clear();
}
inline const ::EnvironmentStatus& PathEvents::environmentstatus(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.environmentStatus)
  return environmentstatus_.Get(index);
}
inline ::EnvironmentStatus* PathEvents::mutable_environmentstatus(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.environmentStatus)
  return environmentstatus_.Mutable(index);
}
inline ::EnvironmentStatus* PathEvents::add_environmentstatus() {
  // @@protoc_insertion_point(field_add:PathEvents.environmentStatus)
  return environmentstatus_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::EnvironmentStatus >*
PathEvents::mutable_environmentstatus() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.environmentStatus)
  return &environmentstatus_;
}
inline const ::google::protobuf::RepeatedPtrField< ::EnvironmentStatus >&
PathEvents::environmentstatus() const {
  // @@protoc_insertion_point(field_list:PathEvents.environmentStatus)
  return environmentstatus_;
}

// repeated .ObjectDetection objectDetection = 8;
inline int PathEvents::objectdetection_size() const {
  return objectdetection_.size();
}
inline void PathEvents::clear_objectdetection() {
  objectdetection_.Clear();
}
inline const ::ObjectDetection& PathEvents::objectdetection(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.objectDetection)
  return objectdetection_.Get(index);
}
inline ::ObjectDetection* PathEvents::mutable_objectdetection(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.objectDetection)
  return objectdetection_.Mutable(index);
}
inline ::ObjectDetection* PathEvents::add_objectdetection() {
  // @@protoc_insertion_point(field_add:PathEvents.objectDetection)
  return objectdetection_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ObjectDetection >*
PathEvents::mutable_objectdetection() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.objectDetection)
  return &objectdetection_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ObjectDetection >&
PathEvents::objectdetection() const {
  // @@protoc_insertion_point(field_list:PathEvents.objectDetection)
  return objectdetection_;
}

// repeated .ADServiceAndSensorState adServiceAndSensorState = 9;
inline int PathEvents::adserviceandsensorstate_size() const {
  return adserviceandsensorstate_.size();
}
inline void PathEvents::clear_adserviceandsensorstate() {
  adserviceandsensorstate_.Clear();
}
inline const ::ADServiceAndSensorState& PathEvents::adserviceandsensorstate(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.adServiceAndSensorState)
  return adserviceandsensorstate_.Get(index);
}
inline ::ADServiceAndSensorState* PathEvents::mutable_adserviceandsensorstate(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.adServiceAndSensorState)
  return adserviceandsensorstate_.Mutable(index);
}
inline ::ADServiceAndSensorState* PathEvents::add_adserviceandsensorstate() {
  // @@protoc_insertion_point(field_add:PathEvents.adServiceAndSensorState)
  return adserviceandsensorstate_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ADServiceAndSensorState >*
PathEvents::mutable_adserviceandsensorstate() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.adServiceAndSensorState)
  return &adserviceandsensorstate_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ADServiceAndSensorState >&
PathEvents::adserviceandsensorstate() const {
  // @@protoc_insertion_point(field_list:PathEvents.adServiceAndSensorState)
  return adserviceandsensorstate_;
}

// repeated .EgoMotion egoMotion = 1000;
inline int PathEvents::egomotion_size() const {
  return egomotion_.size();
}
inline void PathEvents::clear_egomotion() {
  egomotion_.Clear();
}
inline const ::EgoMotion& PathEvents::egomotion(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.egoMotion)
  return egomotion_.Get(index);
}
inline ::EgoMotion* PathEvents::mutable_egomotion(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.egoMotion)
  return egomotion_.Mutable(index);
}
inline ::EgoMotion* PathEvents::add_egomotion() {
  // @@protoc_insertion_point(field_add:PathEvents.egoMotion)
  return egomotion_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::EgoMotion >*
PathEvents::mutable_egomotion() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.egoMotion)
  return &egomotion_;
}
inline const ::google::protobuf::RepeatedPtrField< ::EgoMotion >&
PathEvents::egomotion() const {
  // @@protoc_insertion_point(field_list:PathEvents.egoMotion)
  return egomotion_;
}

// repeated .RawGNSSSatData rawGNSSSatData = 1001;
inline int PathEvents::rawgnsssatdata_size() const {
  return rawgnsssatdata_.size();
}
inline void PathEvents::clear_rawgnsssatdata() {
  rawgnsssatdata_.Clear();
}
inline const ::RawGNSSSatData& PathEvents::rawgnsssatdata(int index) const {
  // @@protoc_insertion_point(field_get:PathEvents.rawGNSSSatData)
  return rawgnsssatdata_.Get(index);
}
inline ::RawGNSSSatData* PathEvents::mutable_rawgnsssatdata(int index) {
  // @@protoc_insertion_point(field_mutable:PathEvents.rawGNSSSatData)
  return rawgnsssatdata_.Mutable(index);
}
inline ::RawGNSSSatData* PathEvents::add_rawgnsssatdata() {
  // @@protoc_insertion_point(field_add:PathEvents.rawGNSSSatData)
  return rawgnsssatdata_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::RawGNSSSatData >*
PathEvents::mutable_rawgnsssatdata() {
  // @@protoc_insertion_point(field_mutable_list:PathEvents.rawGNSSSatData)
  return &rawgnsssatdata_;
}
inline const ::google::protobuf::RepeatedPtrField< ::RawGNSSSatData >&
PathEvents::rawgnsssatdata() const {
  // @@protoc_insertion_point(field_list:PathEvents.rawGNSSSatData)
  return rawgnsssatdata_;
}

// -------------------------------------------------------------------

// MediaContainer

// required int64 timeStampUTC_ms = 1;
inline bool MediaContainer::has_timestamputc_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaContainer::set_has_timestamputc_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaContainer::clear_has_timestamputc_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaContainer::clear_timestamputc_ms() {
  timestamputc_ms_ = GOOGLE_LONGLONG(0);
  clear_has_timestamputc_ms();
}
inline ::google::protobuf::int64 MediaContainer::timestamputc_ms() const {
  // @@protoc_insertion_point(field_get:MediaContainer.timeStampUTC_ms)
  return timestamputc_ms_;
}
inline void MediaContainer::set_timestamputc_ms(::google::protobuf::int64 value) {
  set_has_timestamputc_ms();
  timestamputc_ms_ = value;
  // @@protoc_insertion_point(field_set:MediaContainer.timeStampUTC_ms)
}

// required .MediaContainer.MediaTypeEnum mediaType = 2;
inline bool MediaContainer::has_mediatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaContainer::set_has_mediatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaContainer::clear_has_mediatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaContainer::clear_mediatype() {
  mediatype_ = 1;
  clear_has_mediatype();
}
inline ::MediaContainer_MediaTypeEnum MediaContainer::mediatype() const {
  // @@protoc_insertion_point(field_get:MediaContainer.mediaType)
  return static_cast< ::MediaContainer_MediaTypeEnum >(mediatype_);
}
inline void MediaContainer::set_mediatype(::MediaContainer_MediaTypeEnum value) {
  assert(::MediaContainer_MediaTypeEnum_IsValid(value));
  set_has_mediatype();
  mediatype_ = value;
  // @@protoc_insertion_point(field_set:MediaContainer.mediaType)
}

// required string mediaFormat = 3;
inline bool MediaContainer::has_mediaformat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaContainer::set_has_mediaformat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaContainer::clear_has_mediaformat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaContainer::clear_mediaformat() {
  mediaformat_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mediaformat();
}
inline const ::std::string& MediaContainer::mediaformat() const {
  // @@protoc_insertion_point(field_get:MediaContainer.mediaFormat)
  return mediaformat_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MediaContainer::set_mediaformat(const ::std::string& value) {
  set_has_mediaformat();
  mediaformat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MediaContainer.mediaFormat)
}
inline void MediaContainer::set_mediaformat(const char* value) {
  set_has_mediaformat();
  mediaformat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MediaContainer.mediaFormat)
}
inline void MediaContainer::set_mediaformat(const char* value, size_t size) {
  set_has_mediaformat();
  mediaformat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MediaContainer.mediaFormat)
}
inline ::std::string* MediaContainer::mutable_mediaformat() {
  set_has_mediaformat();
  // @@protoc_insertion_point(field_mutable:MediaContainer.mediaFormat)
  return mediaformat_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MediaContainer::release_mediaformat() {
  // @@protoc_insertion_point(field_release:MediaContainer.mediaFormat)
  clear_has_mediaformat();
  return mediaformat_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MediaContainer::set_allocated_mediaformat(::std::string* mediaformat) {
  if (mediaformat != NULL) {
    set_has_mediaformat();
  } else {
    clear_has_mediaformat();
  }
  mediaformat_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mediaformat);
  // @@protoc_insertion_point(field_set_allocated:MediaContainer.mediaFormat)
}

// required bytes mediaContent = 4;
inline bool MediaContainer::has_mediacontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MediaContainer::set_has_mediacontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MediaContainer::clear_has_mediacontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MediaContainer::clear_mediacontent() {
  mediacontent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mediacontent();
}
inline const ::std::string& MediaContainer::mediacontent() const {
  // @@protoc_insertion_point(field_get:MediaContainer.mediaContent)
  return mediacontent_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MediaContainer::set_mediacontent(const ::std::string& value) {
  set_has_mediacontent();
  mediacontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MediaContainer.mediaContent)
}
inline void MediaContainer::set_mediacontent(const char* value) {
  set_has_mediacontent();
  mediacontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MediaContainer.mediaContent)
}
inline void MediaContainer::set_mediacontent(const void* value, size_t size) {
  set_has_mediacontent();
  mediacontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MediaContainer.mediaContent)
}
inline ::std::string* MediaContainer::mutable_mediacontent() {
  set_has_mediacontent();
  // @@protoc_insertion_point(field_mutable:MediaContainer.mediaContent)
  return mediacontent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MediaContainer::release_mediacontent() {
  // @@protoc_insertion_point(field_release:MediaContainer.mediaContent)
  clear_has_mediacontent();
  return mediacontent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MediaContainer::set_allocated_mediacontent(::std::string* mediacontent) {
  if (mediacontent != NULL) {
    set_has_mediacontent();
  } else {
    clear_has_mediacontent();
  }
  mediacontent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mediacontent);
  // @@protoc_insertion_point(field_set_allocated:MediaContainer.mediaContent)
}

// optional int64 mediaID = 5;
inline bool MediaContainer::has_mediaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MediaContainer::set_has_mediaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MediaContainer::clear_has_mediaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MediaContainer::clear_mediaid() {
  mediaid_ = GOOGLE_LONGLONG(0);
  clear_has_mediaid();
}
inline ::google::protobuf::int64 MediaContainer::mediaid() const {
  // @@protoc_insertion_point(field_get:MediaContainer.mediaID)
  return mediaid_;
}
inline void MediaContainer::set_mediaid(::google::protobuf::int64 value) {
  set_has_mediaid();
  mediaid_ = value;
  // @@protoc_insertion_point(field_set:MediaContainer.mediaID)
}

// optional .PositionOffset sensorOffset = 6;
inline bool MediaContainer::has_sensoroffset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MediaContainer::set_has_sensoroffset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MediaContainer::clear_has_sensoroffset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MediaContainer::clear_sensoroffset() {
  if (sensoroffset_ != NULL) sensoroffset_->::PositionOffset::Clear();
  clear_has_sensoroffset();
}
inline const ::PositionOffset& MediaContainer::sensoroffset() const {
  // @@protoc_insertion_point(field_get:MediaContainer.sensorOffset)
  return sensoroffset_ != NULL ? *sensoroffset_ : *default_instance_->sensoroffset_;
}
inline ::PositionOffset* MediaContainer::mutable_sensoroffset() {
  set_has_sensoroffset();
  if (sensoroffset_ == NULL) {
    sensoroffset_ = new ::PositionOffset;
  }
  // @@protoc_insertion_point(field_mutable:MediaContainer.sensorOffset)
  return sensoroffset_;
}
inline ::PositionOffset* MediaContainer::release_sensoroffset() {
  // @@protoc_insertion_point(field_release:MediaContainer.sensorOffset)
  clear_has_sensoroffset();
  ::PositionOffset* temp = sensoroffset_;
  sensoroffset_ = NULL;
  return temp;
}
inline void MediaContainer::set_allocated_sensoroffset(::PositionOffset* sensoroffset) {
  delete sensoroffset_;
  sensoroffset_ = sensoroffset;
  if (sensoroffset) {
    set_has_sensoroffset();
  } else {
    clear_has_sensoroffset();
  }
  // @@protoc_insertion_point(field_set_allocated:MediaContainer.sensorOffset)
}

// optional .Vector3D sensorDirection = 7;
inline bool MediaContainer::has_sensordirection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MediaContainer::set_has_sensordirection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MediaContainer::clear_has_sensordirection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MediaContainer::clear_sensordirection() {
  if (sensordirection_ != NULL) sensordirection_->::Vector3D::Clear();
  clear_has_sensordirection();
}
inline const ::Vector3D& MediaContainer::sensordirection() const {
  // @@protoc_insertion_point(field_get:MediaContainer.sensorDirection)
  return sensordirection_ != NULL ? *sensordirection_ : *default_instance_->sensordirection_;
}
inline ::Vector3D* MediaContainer::mutable_sensordirection() {
  set_has_sensordirection();
  if (sensordirection_ == NULL) {
    sensordirection_ = new ::Vector3D;
  }
  // @@protoc_insertion_point(field_mutable:MediaContainer.sensorDirection)
  return sensordirection_;
}
inline ::Vector3D* MediaContainer::release_sensordirection() {
  // @@protoc_insertion_point(field_release:MediaContainer.sensorDirection)
  clear_has_sensordirection();
  ::Vector3D* temp = sensordirection_;
  sensordirection_ = NULL;
  return temp;
}
inline void MediaContainer::set_allocated_sensordirection(::Vector3D* sensordirection) {
  delete sensordirection_;
  sensordirection_ = sensordirection;
  if (sensordirection) {
    set_has_sensordirection();
  } else {
    clear_has_sensordirection();
  }
  // @@protoc_insertion_point(field_set_allocated:MediaContainer.sensorDirection)
}

// optional int32 duration_s = 8;
inline bool MediaContainer::has_duration_s() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MediaContainer::set_has_duration_s() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MediaContainer::clear_has_duration_s() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MediaContainer::clear_duration_s() {
  duration_s_ = 0;
  clear_has_duration_s();
}
inline ::google::protobuf::int32 MediaContainer::duration_s() const {
  // @@protoc_insertion_point(field_get:MediaContainer.duration_s)
  return duration_s_;
}
inline void MediaContainer::set_duration_s(::google::protobuf::int32 value) {
  set_has_duration_s();
  duration_s_ = value;
  // @@protoc_insertion_point(field_set:MediaContainer.duration_s)
}

// optional double verticalViewingAngle_deg = 9;
inline bool MediaContainer::has_verticalviewingangle_deg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MediaContainer::set_has_verticalviewingangle_deg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MediaContainer::clear_has_verticalviewingangle_deg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MediaContainer::clear_verticalviewingangle_deg() {
  verticalviewingangle_deg_ = 0;
  clear_has_verticalviewingangle_deg();
}
inline double MediaContainer::verticalviewingangle_deg() const {
  // @@protoc_insertion_point(field_get:MediaContainer.verticalViewingAngle_deg)
  return verticalviewingangle_deg_;
}
inline void MediaContainer::set_verticalviewingangle_deg(double value) {
  set_has_verticalviewingangle_deg();
  verticalviewingangle_deg_ = value;
  // @@protoc_insertion_point(field_set:MediaContainer.verticalViewingAngle_deg)
}

// optional double horizontalViewingAngle_deg = 10;
inline bool MediaContainer::has_horizontalviewingangle_deg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MediaContainer::set_has_horizontalviewingangle_deg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MediaContainer::clear_has_horizontalviewingangle_deg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MediaContainer::clear_horizontalviewingangle_deg() {
  horizontalviewingangle_deg_ = 0;
  clear_has_horizontalviewingangle_deg();
}
inline double MediaContainer::horizontalviewingangle_deg() const {
  // @@protoc_insertion_point(field_get:MediaContainer.horizontalViewingAngle_deg)
  return horizontalviewingangle_deg_;
}
inline void MediaContainer::set_horizontalviewingangle_deg(double value) {
  set_has_horizontalviewingangle_deg();
  horizontalviewingangle_deg_ = value;
  // @@protoc_insertion_point(field_set:MediaContainer.horizontalViewingAngle_deg)
}

// -------------------------------------------------------------------

// PathMedia

// repeated .MediaContainer mediaContainer = 1;
inline int PathMedia::mediacontainer_size() const {
  return mediacontainer_.size();
}
inline void PathMedia::clear_mediacontainer() {
  mediacontainer_.Clear();
}
inline const ::MediaContainer& PathMedia::mediacontainer(int index) const {
  // @@protoc_insertion_point(field_get:PathMedia.mediaContainer)
  return mediacontainer_.Get(index);
}
inline ::MediaContainer* PathMedia::mutable_mediacontainer(int index) {
  // @@protoc_insertion_point(field_mutable:PathMedia.mediaContainer)
  return mediacontainer_.Mutable(index);
}
inline ::MediaContainer* PathMedia::add_mediacontainer() {
  // @@protoc_insertion_point(field_add:PathMedia.mediaContainer)
  return mediacontainer_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MediaContainer >*
PathMedia::mutable_mediacontainer() {
  // @@protoc_insertion_point(field_mutable_list:PathMedia.mediaContainer)
  return &mediacontainer_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MediaContainer >&
PathMedia::mediacontainer() const {
  // @@protoc_insertion_point(field_list:PathMedia.mediaContainer)
  return mediacontainer_;
}

// -------------------------------------------------------------------

// Message

// required .Envelope envelope = 1;
inline bool Message::has_envelope() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_envelope() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_envelope() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_envelope() {
  if (envelope_ != NULL) envelope_->::Envelope::Clear();
  clear_has_envelope();
}
inline const ::Envelope& Message::envelope() const {
  // @@protoc_insertion_point(field_get:Message.envelope)
  return envelope_ != NULL ? *envelope_ : *default_instance_->envelope_;
}
inline ::Envelope* Message::mutable_envelope() {
  set_has_envelope();
  if (envelope_ == NULL) {
    envelope_ = new ::Envelope;
  }
  // @@protoc_insertion_point(field_mutable:Message.envelope)
  return envelope_;
}
inline ::Envelope* Message::release_envelope() {
  // @@protoc_insertion_point(field_release:Message.envelope)
  clear_has_envelope();
  ::Envelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline void Message::set_allocated_envelope(::Envelope* envelope) {
  delete envelope_;
  envelope_ = envelope;
  if (envelope) {
    set_has_envelope();
  } else {
    clear_has_envelope();
  }
  // @@protoc_insertion_point(field_set_allocated:Message.envelope)
}

// required .Path path = 2;
inline bool Message::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_path() {
  if (path_ != NULL) path_->::Path::Clear();
  clear_has_path();
}
inline const ::Path& Message::path() const {
  // @@protoc_insertion_point(field_get:Message.path)
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::Path* Message::mutable_path() {
  set_has_path();
  if (path_ == NULL) {
    path_ = new ::Path;
  }
  // @@protoc_insertion_point(field_mutable:Message.path)
  return path_;
}
inline ::Path* Message::release_path() {
  // @@protoc_insertion_point(field_release:Message.path)
  clear_has_path();
  ::Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline void Message::set_allocated_path(::Path* path) {
  delete path_;
  path_ = path;
  if (path) {
    set_has_path();
  } else {
    clear_has_path();
  }
  // @@protoc_insertion_point(field_set_allocated:Message.path)
}

// optional .PathEvents pathEvents = 3;
inline bool Message::has_pathevents() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_pathevents() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_pathevents() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_pathevents() {
  if (pathevents_ != NULL) pathevents_->::PathEvents::Clear();
  clear_has_pathevents();
}
inline const ::PathEvents& Message::pathevents() const {
  // @@protoc_insertion_point(field_get:Message.pathEvents)
  return pathevents_ != NULL ? *pathevents_ : *default_instance_->pathevents_;
}
inline ::PathEvents* Message::mutable_pathevents() {
  set_has_pathevents();
  if (pathevents_ == NULL) {
    pathevents_ = new ::PathEvents;
  }
  // @@protoc_insertion_point(field_mutable:Message.pathEvents)
  return pathevents_;
}
inline ::PathEvents* Message::release_pathevents() {
  // @@protoc_insertion_point(field_release:Message.pathEvents)
  clear_has_pathevents();
  ::PathEvents* temp = pathevents_;
  pathevents_ = NULL;
  return temp;
}
inline void Message::set_allocated_pathevents(::PathEvents* pathevents) {
  delete pathevents_;
  pathevents_ = pathevents;
  if (pathevents) {
    set_has_pathevents();
  } else {
    clear_has_pathevents();
  }
  // @@protoc_insertion_point(field_set_allocated:Message.pathEvents)
}

// optional .PathMedia pathMedia = 4;
inline bool Message::has_pathmedia() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_pathmedia() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_pathmedia() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_pathmedia() {
  if (pathmedia_ != NULL) pathmedia_->::PathMedia::Clear();
  clear_has_pathmedia();
}
inline const ::PathMedia& Message::pathmedia() const {
  // @@protoc_insertion_point(field_get:Message.pathMedia)
  return pathmedia_ != NULL ? *pathmedia_ : *default_instance_->pathmedia_;
}
inline ::PathMedia* Message::mutable_pathmedia() {
  set_has_pathmedia();
  if (pathmedia_ == NULL) {
    pathmedia_ = new ::PathMedia;
  }
  // @@protoc_insertion_point(field_mutable:Message.pathMedia)
  return pathmedia_;
}
inline ::PathMedia* Message::release_pathmedia() {
  // @@protoc_insertion_point(field_release:Message.pathMedia)
  clear_has_pathmedia();
  ::PathMedia* temp = pathmedia_;
  pathmedia_ = NULL;
  return temp;
}
inline void Message::set_allocated_pathmedia(::PathMedia* pathmedia) {
  delete pathmedia_;
  pathmedia_ = pathmedia;
  if (pathmedia) {
    set_has_pathmedia();
  } else {
    clear_has_pathmedia();
  }
  // @@protoc_insertion_point(field_set_allocated:Message.pathMedia)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::VehicleMetaData_VehicleTypeGenericEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VehicleMetaData_VehicleTypeGenericEnum>() {
  return ::VehicleMetaData_VehicleTypeGenericEnum_descriptor();
}
template <> struct is_proto_enum< ::VehicleMetaData_FuelTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VehicleMetaData_FuelTypeEnum>() {
  return ::VehicleMetaData_FuelTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::PositionEstimate_PositionTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PositionEstimate_PositionTypeEnum>() {
  return ::PositionEstimate_PositionTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::PositionEstimate_SpeedDetectionEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PositionEstimate_SpeedDetectionEnum>() {
  return ::PositionEstimate_SpeedDetectionEnum_descriptor();
}
template <> struct is_proto_enum< ::PositionEstimate_HeadingDetectionEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PositionEstimate_HeadingDetectionEnum>() {
  return ::PositionEstimate_HeadingDetectionEnum_descriptor();
}
template <> struct is_proto_enum< ::VehicleStatus_TransmissionModeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VehicleStatus_TransmissionModeEnum>() {
  return ::VehicleStatus_TransmissionModeEnum_descriptor();
}
template <> struct is_proto_enum< ::VehicleStatus_LightStateBitfield> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VehicleStatus_LightStateBitfield>() {
  return ::VehicleStatus_LightStateBitfield_descriptor();
}
template <> struct is_proto_enum< ::VehicleStatus_WiperStateEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VehicleStatus_WiperStateEnum>() {
  return ::VehicleStatus_WiperStateEnum_descriptor();
}
template <> struct is_proto_enum< ::VehicleStatus_MaintenanceLightStateBitfield> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VehicleStatus_MaintenanceLightStateBitfield>() {
  return ::VehicleStatus_MaintenanceLightStateBitfield_descriptor();
}
template <> struct is_proto_enum< ::PositionOffset_LateralOffsetSimpleEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PositionOffset_LateralOffsetSimpleEnum>() {
  return ::PositionOffset_LateralOffsetSimpleEnum_descriptor();
}
template <> struct is_proto_enum< ::PositionOffset_LongitudinalOffsetSimpleEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PositionOffset_LongitudinalOffsetSimpleEnum>() {
  return ::PositionOffset_LongitudinalOffsetSimpleEnum_descriptor();
}
template <> struct is_proto_enum< ::PositionOffset_VerticalOffsetSimpleEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PositionOffset_VerticalOffsetSimpleEnum>() {
  return ::PositionOffset_VerticalOffsetSimpleEnum_descriptor();
}
template <> struct is_proto_enum< ::RoadSignRestriction_RestrictionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadSignRestriction_RestrictionType>() {
  return ::RoadSignRestriction_RestrictionType_descriptor();
}
template <> struct is_proto_enum< ::SignRecognition_RoadSignTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SignRecognition_RoadSignTypeEnum>() {
  return ::SignRecognition_RoadSignTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::SignRecognition_RoadSignPermanencyEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SignRecognition_RoadSignPermanencyEnum>() {
  return ::SignRecognition_RoadSignPermanencyEnum_descriptor();
}
template <> struct is_proto_enum< ::SignRecognition_RoadSignDependenciesEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SignRecognition_RoadSignDependenciesEnum>() {
  return ::SignRecognition_RoadSignDependenciesEnum_descriptor();
}
template <> struct is_proto_enum< ::SignRecognition_RoadSignValidityEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SignRecognition_RoadSignValidityEnum>() {
  return ::SignRecognition_RoadSignValidityEnum_descriptor();
}
template <> struct is_proto_enum< ::SignRecognition_RoadSignRecognitionTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SignRecognition_RoadSignRecognitionTypeEnum>() {
  return ::SignRecognition_RoadSignRecognitionTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::LinePoint_LinePointTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LinePoint_LinePointTypeEnum>() {
  return ::LinePoint_LinePointTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::LaneBoundaryRecognition_LaneBoundaryTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LaneBoundaryRecognition_LaneBoundaryTypeEnum>() {
  return ::LaneBoundaryRecognition_LaneBoundaryTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::LaneBoundaryRecognition_LaneBoundaryColorEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LaneBoundaryRecognition_LaneBoundaryColorEnum>() {
  return ::LaneBoundaryRecognition_LaneBoundaryColorEnum_descriptor();
}
template <> struct is_proto_enum< ::EnvironmentStatus_LightConditionsEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EnvironmentStatus_LightConditionsEnum>() {
  return ::EnvironmentStatus_LightConditionsEnum_descriptor();
}
template <> struct is_proto_enum< ::EnvironmentStatus_PrecipitationEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EnvironmentStatus_PrecipitationEnum>() {
  return ::EnvironmentStatus_PrecipitationEnum_descriptor();
}
template <> struct is_proto_enum< ::EnvironmentStatus_RoadSurfaceTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EnvironmentStatus_RoadSurfaceTypeEnum>() {
  return ::EnvironmentStatus_RoadSurfaceTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::TrafficLightStatus_LightStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrafficLightStatus_LightStatus>() {
  return ::TrafficLightStatus_LightStatus_descriptor();
}
template <> struct is_proto_enum< ::ObjectDetection_ObjectTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ObjectDetection_ObjectTypeEnum>() {
  return ::ObjectDetection_ObjectTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::RawGNSSSatData_RawGNSSSatDataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RawGNSSSatData_RawGNSSSatDataType>() {
  return ::RawGNSSSatData_RawGNSSSatDataType_descriptor();
}
template <> struct is_proto_enum< ::MediaContainer_MediaTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MediaContainer_MediaTypeEnum>() {
  return ::MediaContainer_MediaTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::WheelReferenceBitfield> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WheelReferenceBitfield>() {
  return ::WheelReferenceBitfield_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sensoris_2eproto__INCLUDED
